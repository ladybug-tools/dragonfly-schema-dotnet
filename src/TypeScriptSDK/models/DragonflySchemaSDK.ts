//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming



/** An enumeration. */
export enum ExteriorFaceType {
    Wall = "Wall",
    Roof = "Roof",
    Floor = "Floor",
    All = "All",
}

export class _OpenAPIGenBaseModel implements I_OpenAPIGenBaseModel {

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: I_OpenAPIGenBaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "_OpenAPIGenBaseModel";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): _OpenAPIGenBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ExteriorFaceGridParameter") {
            let result = new ExteriorFaceGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "_GridParameterBase") {
            let result = new _GridParameterBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "Void") {
            let result = new Void();
            result.init(data);
            return result;
        }
        if (data["type"] === "Mirror") {
            let result = new Mirror();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierBase") {
            let result = new ModifierBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "IDdRadianceBaseModel") {
            let result = new IDdRadianceBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "Plastic") {
            let result = new Plastic();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glass") {
            let result = new Glass();
            result.init(data);
            return result;
        }
        if (data["type"] === "BSDF") {
            let result = new BSDF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glow") {
            let result = new Glow();
            result.init(data);
            return result;
        }
        if (data["type"] === "Light") {
            let result = new Light();
            result.init(data);
            return result;
        }
        if (data["type"] === "Trans") {
            let result = new Trans();
            result.init(data);
            return result;
        }
        if (data["type"] === "Metal") {
            let result = new Metal();
            result.init(data);
            return result;
        }
        if (data["type"] === "Plane") {
            let result = new Plane();
            result.init(data);
            return result;
        }
        if (data["type"] === "Face3D") {
            let result = new Face3D();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGas") {
            let result = new EnergyWindowMaterialGas();
            result.init(data);
            return result;
        }
        if (data["type"] === "IDdEnergyBaseModel") {
            let result = new IDdEnergyBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyBaseModel") {
            let result = new EnergyBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "ContextShadeRadiancePropertiesAbridged") {
            let result = new ContextShadeRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterial") {
            let result = new EnergyMaterial();
            result.init(data);
            return result;
        }
        if (data["type"] === "Ground") {
            let result = new Ground();
            result.init(data);
            return result;
        }
        if (data["type"] === "Autocalculate") {
            let result = new Autocalculate();
            result.init(data);
            return result;
        }
        if (data["type"] === "Outdoors") {
            let result = new Outdoors();
            result.init(data);
            return result;
        }
        if (data["type"] === "Adiabatic") {
            let result = new Adiabatic();
            result.init(data);
            return result;
        }
        if (data["type"] === "Surface") {
            let result = new Surface();
            result.init(data);
            return result;
        }
        if (data["type"] === "OtherSideTemperature") {
            let result = new OtherSideTemperature();
            result.init(data);
            return result;
        }
        if (data["type"] === "PVProperties") {
            let result = new PVProperties();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeEnergyPropertiesAbridged") {
            let result = new ShadeEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "StateGeometryAbridged") {
            let result = new StateGeometryAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RadianceShadeStateAbridged") {
            let result = new RadianceShadeStateAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeRadiancePropertiesAbridged") {
            let result = new ShadeRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_PropertiesBaseAbridged") {
            let result = new _PropertiesBaseAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadePropertiesAbridged") {
            let result = new ShadePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Shade") {
            let result = new Shade();
            result.init(data);
            return result;
        }
        if (data["type"] === "IDdBaseModel") {
            let result = new IDdBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationOpening") {
            let result = new VentilationOpening();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureEnergyPropertiesAbridged") {
            let result = new ApertureEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RadianceSubFaceStateAbridged") {
            let result = new RadianceSubFaceStateAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureRadiancePropertiesAbridged") {
            let result = new ApertureRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "AperturePropertiesAbridged") {
            let result = new AperturePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Aperture") {
            let result = new Aperture();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorEnergyPropertiesAbridged") {
            let result = new DoorEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorRadiancePropertiesAbridged") {
            let result = new DoorRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorPropertiesAbridged") {
            let result = new DoorPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Door") {
            let result = new Door();
            result.init(data);
            return result;
        }
        if (data["type"] === "AFNCrack") {
            let result = new AFNCrack();
            result.init(data);
            return result;
        }
        if (data["type"] === "FaceEnergyPropertiesAbridged") {
            let result = new FaceEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FaceRadiancePropertiesAbridged") {
            let result = new FaceRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FacePropertiesAbridged") {
            let result = new FacePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Face") {
            let result = new Face();
            result.init(data);
            return result;
        }
        if (data["type"] === "PeopleAbridged") {
            let result = new PeopleAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "LightingAbridged") {
            let result = new LightingAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipmentAbridged") {
            let result = new ElectricEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_EquipmentBase") {
            let result = new _EquipmentBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipmentAbridged") {
            let result = new GasEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWaterAbridged") {
            let result = new ServiceHotWaterAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "InfiltrationAbridged") {
            let result = new InfiltrationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationAbridged") {
            let result = new VentilationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "SetpointAbridged") {
            let result = new SetpointAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DaylightingControl") {
            let result = new DaylightingControl();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationControlAbridged") {
            let result = new VentilationControlAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationFan") {
            let result = new VentilationFan();
            result.init(data);
            return result;
        }
        if (data["type"] === "InternalMassAbridged") {
            let result = new InternalMassAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProcessAbridged") {
            let result = new ProcessAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomEnergyPropertiesAbridged") {
            let result = new RoomEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomRadiancePropertiesAbridged") {
            let result = new RoomRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomPropertiesAbridged") {
            let result = new RoomPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room") {
            let result = new Room();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGlazing") {
            let result = new EnergyWindowMaterialGlazing();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialNoMass") {
            let result = new EnergyMaterialNoMass();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialVegetation") {
            let result = new EnergyMaterialVegetation();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstruction") {
            let result = new OpaqueConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorConstructionSet") {
            let result = new FloorConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstructionAbridged") {
            let result = new OpaqueConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionAbridged") {
            let result = new WindowConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeConstruction") {
            let result = new ShadeConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstructionAbridged") {
            let result = new AirBoundaryConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WallConstructionSetAbridged") {
            let result = new WallConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_FaceSubSetAbridged") {
            let result = new _FaceSubSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorConstructionSetAbridged") {
            let result = new FloorConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingConstructionSetAbridged") {
            let result = new RoofCeilingConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureConstructionSetAbridged") {
            let result = new ApertureConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorConstructionSetAbridged") {
            let result = new DoorConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "GlobalConstructionSet") {
            let result = new GlobalConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSetAbridged") {
            let result = new ConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WallConstructionSet") {
            let result = new WallConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingConstructionSet") {
            let result = new RoofCeilingConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialSimpleGlazSys") {
            let result = new EnergyWindowMaterialSimpleGlazSys();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasCustom") {
            let result = new EnergyWindowMaterialGasCustom();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasMixture") {
            let result = new EnergyWindowMaterialGasMixture();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowFrame") {
            let result = new EnergyWindowFrame();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstruction") {
            let result = new WindowConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialShade") {
            let result = new EnergyWindowMaterialShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialBlind") {
            let result = new EnergyWindowMaterialBlind();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleDay") {
            let result = new ScheduleDay();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRuleAbridged") {
            let result = new ScheduleRuleAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DatedBaseModel") {
            let result = new DatedBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "NoLimit") {
            let result = new NoLimit();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleTypeLimit") {
            let result = new ScheduleTypeLimit();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRuleset") {
            let result = new ScheduleRuleset();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedInterval") {
            let result = new ScheduleFixedInterval();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShade") {
            let result = new WindowConstructionShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionDynamic") {
            let result = new WindowConstructionDynamic();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureConstructionSet") {
            let result = new ApertureConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorConstructionSet") {
            let result = new DoorConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstruction") {
            let result = new AirBoundaryConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSet") {
            let result = new ConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "Autosize") {
            let result = new Autosize();
            result.init(data);
            return result;
        }
        if (data["type"] === "IdealAirSystemAbridged") {
            let result = new IdealAirSystemAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VAV") {
            let result = new VAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PVAV") {
            let result = new PVAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PSZ") {
            let result = new PSZ();
            result.init(data);
            return result;
        }
        if (data["type"] === "PTAC") {
            let result = new PTAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "ForcedAirFurnace") {
            let result = new ForcedAirFurnace();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCUwithDOASAbridged") {
            let result = new FCUwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHPwithDOASAbridged") {
            let result = new WSHPwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRFwithDOASAbridged") {
            let result = new VRFwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RadiantwithDOASAbridged") {
            let result = new RadiantwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCU") {
            let result = new FCU();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHP") {
            let result = new WSHP();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRF") {
            let result = new VRF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Baseboard") {
            let result = new Baseboard();
            result.init(data);
            return result;
        }
        if (data["type"] === "EvaporativeCooler") {
            let result = new EvaporativeCooler();
            result.init(data);
            return result;
        }
        if (data["type"] === "Residential") {
            let result = new Residential();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowAC") {
            let result = new WindowAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasUnitHeater") {
            let result = new GasUnitHeater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Radiant") {
            let result = new Radiant();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedHVAC") {
            let result = new DetailedHVAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "SHWSystem") {
            let result = new SHWSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramTypeAbridged") {
            let result = new ProgramTypeAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "People") {
            let result = new People();
            result.init(data);
            return result;
        }
        if (data["type"] === "Lighting") {
            let result = new Lighting();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipment") {
            let result = new ElectricEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipment") {
            let result = new GasEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWater") {
            let result = new ServiceHotWater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Infiltration") {
            let result = new Infiltration();
            result.init(data);
            return result;
        }
        if (data["type"] === "Ventilation") {
            let result = new Ventilation();
            result.init(data);
            return result;
        }
        if (data["type"] === "Setpoint") {
            let result = new Setpoint();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramType") {
            let result = new ProgramType();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRulesetAbridged") {
            let result = new ScheduleRulesetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedIntervalAbridged") {
            let result = new ScheduleFixedIntervalAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModelEnergyProperties") {
            let result = new ModelEnergyProperties();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingModifierSet") {
            let result = new RoofCeilingModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "WallModifierSetAbridged") {
            let result = new WallModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "BaseModifierSetAbridged") {
            let result = new BaseModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorModifierSetAbridged") {
            let result = new FloorModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingModifierSetAbridged") {
            let result = new RoofCeilingModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureModifierSetAbridged") {
            let result = new ApertureModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorModifierSetAbridged") {
            let result = new DoorModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeModifierSetAbridged") {
            let result = new ShadeModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "GlobalModifierSet") {
            let result = new GlobalModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "WallModifierSet") {
            let result = new WallModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorModifierSet") {
            let result = new FloorModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureModifierSet") {
            let result = new ApertureModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorModifierSet") {
            let result = new DoorModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeModifierSet") {
            let result = new ShadeModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierSet") {
            let result = new ModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierSetAbridged") {
            let result = new ModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModelRadianceProperties") {
            let result = new ModelRadianceProperties();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room2DEnergyPropertiesAbridged") {
            let result = new Room2DEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "SingleWindow") {
            let result = new SingleWindow();
            result.init(data);
            return result;
        }
        if (data["type"] === "_WindowParameterBase") {
            let result = new _WindowParameterBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "SimpleWindowArea") {
            let result = new SimpleWindowArea();
            result.init(data);
            return result;
        }
        if (data["type"] === "SimpleWindowRatio") {
            let result = new SimpleWindowRatio();
            result.init(data);
            return result;
        }
        if (data["type"] === "RepeatingWindowRatio") {
            let result = new RepeatingWindowRatio();
            result.init(data);
            return result;
        }
        if (data["type"] === "RectangularWindows") {
            let result = new RectangularWindows();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedWindows") {
            let result = new DetailedWindows();
            result.init(data);
            return result;
        }
        if (data["type"] === "ExtrudedBorder") {
            let result = new ExtrudedBorder();
            result.init(data);
            return result;
        }
        if (data["type"] === "Overhang") {
            let result = new Overhang();
            result.init(data);
            return result;
        }
        if (data["type"] === "LouversByDistance") {
            let result = new LouversByDistance();
            result.init(data);
            return result;
        }
        if (data["type"] === "_LouversBase") {
            let result = new _LouversBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "LouversByCount") {
            let result = new LouversByCount();
            result.init(data);
            return result;
        }
        if (data["type"] === "GriddedSkylightArea") {
            let result = new GriddedSkylightArea();
            result.init(data);
            return result;
        }
        if (data["type"] === "GriddedSkylightRatio") {
            let result = new GriddedSkylightRatio();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedSkylights") {
            let result = new DetailedSkylights();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomGridParameter") {
            let result = new RoomGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomRadialGridParameter") {
            let result = new RoomRadialGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "ExteriorApertureGridParameter") {
            let result = new ExteriorApertureGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room2DRadiancePropertiesAbridged") {
            let result = new Room2DRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room2DPropertiesAbridged") {
            let result = new Room2DPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room2D") {
            let result = new Room2D();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofSpecification") {
            let result = new RoofSpecification();
            result.init(data);
            return result;
        }
        if (data["type"] === "StoryEnergyPropertiesAbridged") {
            let result = new StoryEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "StoryRadiancePropertiesAbridged") {
            let result = new StoryRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "StoryPropertiesAbridged") {
            let result = new StoryPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Story") {
            let result = new Story();
            result.init(data);
            return result;
        }
        if (data["type"] === "BuildingEnergyPropertiesAbridged") {
            let result = new BuildingEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "BuildingRadiancePropertiesAbridged") {
            let result = new BuildingRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "BuildingPropertiesAbridged") {
            let result = new BuildingPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "Building") {
            let result = new Building();
            result.init(data);
            return result;
        }
        if (data["type"] === "Color") {
            let result = new Color();
            result.init(data);
            return result;
        }
        if (data["type"] === "Mesh3D") {
            let result = new Mesh3D();
            result.init(data);
            return result;
        }
        if (data["type"] === "ContextShadeEnergyPropertiesAbridged") {
            let result = new ContextShadeEnergyPropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ContextShadePropertiesAbridged") {
            let result = new ContextShadePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ContextShade") {
            let result = new ContextShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModelProperties") {
            let result = new ModelProperties();
            result.init(data);
            return result;
        }
        if (data["type"] === "Model") {
            let result = new Model();
            result.init(data);
            return result;
        }
        if (data["type"] === "_FaceSubSet") {
            let result = new _FaceSubSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "BaseModifierSet") {
            let result = new BaseModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "_HeatCoolBase") {
            let result = new _HeatCoolBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_TemplateSystem") {
            let result = new _TemplateSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "_DOASBase") {
            let result = new _DOASBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_AllAirBase") {
            let result = new _AllAirBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShadeAbridged") {
            let result = new WindowConstructionShadeAbridged();
            result.init(data);
            return result;
        }
        let result = new _OpenAPIGenBaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this._discriminator;
        return data;
    }
}

export interface I_OpenAPIGenBaseModel {

    [key: string]: any;
}

/** Base object for all GridParameters. */
export class _GridParameterBase extends _OpenAPIGenBaseModel implements I_GridParameterBase {
    /** The dimension of the grid cells as a number. */
    dimension!: number;
    /** A boolean to note whether the resulting SensorGrid should include the mesh. */
    include_mesh?: boolean;
    readonly type: string = "_GridParameterBase";

    constructor(data?: I_GridParameterBase) {
        super(data);
        if (!data) {
            this.include_mesh = true;
            this.type = "_GridParameterBase";
        }
        this._discriminator = "_GridParameterBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dimension = _data["dimension"];
            this.include_mesh = _data["include_mesh"] !== undefined ? _data["include_mesh"] : true;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_GridParameterBase";
        }
    }

    static override fromJS(data: any): _GridParameterBase {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ExteriorFaceGridParameter") {
            let result = new ExteriorFaceGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomGridParameter") {
            let result = new RoomGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoomRadialGridParameter") {
            let result = new RoomRadialGridParameter();
            result.init(data);
            return result;
        }
        if (data["type"] === "ExteriorApertureGridParameter") {
            let result = new ExteriorApertureGridParameter();
            result.init(data);
            return result;
        }
        let result = new _GridParameterBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension;
        data["include_mesh"] = this.include_mesh;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base object for all GridParameters. */
export interface I_GridParameterBase extends I_OpenAPIGenBaseModel {
    /** The dimension of the grid cells as a number. */
    dimension: number;
    /** A boolean to note whether the resulting SensorGrid should include the mesh. */
    include_mesh?: boolean;
    type?: string;
}

/** Instructions for a SensorGrid generated from exterior Faces. */
export class ExteriorFaceGridParameter extends _GridParameterBase implements IExteriorFaceGridParameter {
    readonly type: string = "ExteriorFaceGridParameter";
    /** A number for how far to offset the grid from the Faces. (Default: 0.1, suitable for Models in Meters). */
    offset?: number;
    /** Text to specify the type of face that will be used to generate grids. Note that only Faces with Outdoors boundary conditions will be used, meaning that most Floors will typically be excluded unless they represent the underside of a cantilever. */
    face_type?: ExteriorFaceType;
    /** A boolean to note whether the punched_geometry of the faces should be used (True) with the areas of sub-faces removed from the grid or the full geometry should be used (False). */
    punched_geometry?: boolean;

    constructor(data?: IExteriorFaceGridParameter) {
        super(data);
        if (!data) {
            this.type = "ExteriorFaceGridParameter";
            this.offset = 0.1;
            this.face_type = ExteriorFaceType.Wall;
            this.punched_geometry = false;
        }
        this._discriminator = "ExteriorFaceGridParameter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ExteriorFaceGridParameter";
            this.offset = _data["offset"] !== undefined ? _data["offset"] : 0.1;
            this.face_type = _data["face_type"] !== undefined ? _data["face_type"] : ExteriorFaceType.Wall;
            this.punched_geometry = _data["punched_geometry"] !== undefined ? _data["punched_geometry"] : false;
        }
    }

    static override fromJS(data: any): ExteriorFaceGridParameter {
        data = typeof data === 'object' ? data : {};
        let result = new ExteriorFaceGridParameter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["offset"] = this.offset;
        data["face_type"] = this.face_type;
        data["punched_geometry"] = this.punched_geometry;
        super.toJSON(data);
        return data;
    }
}

/** Instructions for a SensorGrid generated from exterior Faces. */
export interface IExteriorFaceGridParameter extends I_GridParameterBase {
    type?: string;
    /** A number for how far to offset the grid from the Faces. (Default: 0.1, suitable for Models in Meters). */
    offset?: number;
    /** Text to specify the type of face that will be used to generate grids. Note that only Faces with Outdoors boundary conditions will be used, meaning that most Floors will typically be excluded unless they represent the underside of a cantilever. */
    face_type?: ExteriorFaceType;
    /** A boolean to note whether the punched_geometry of the faces should be used (True) with the areas of sub-faces removed from the grid or the full geometry should be used (False). */
    punched_geometry?: boolean;
}

/** Void modifier */
export class Void extends _OpenAPIGenBaseModel implements IVoid {
    readonly type: string = "Void";

    [key: string]: any;

    constructor(data?: IVoid) {
        super(data);
        if (!data) {
            this.type = "Void";
        }
        this._discriminator = "Void";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Void";
        }
    }

    static override fromJS(data: any): Void {
        data = typeof data === 'object' ? data : {};
        let result = new Void();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Void modifier */
export interface IVoid extends I_OpenAPIGenBaseModel {
    type?: string;

    [key: string]: any;
}

/** Base class for all objects requiring a valid Radiance identifier. */
export class IDdRadianceBaseModel extends _OpenAPIGenBaseModel implements IIDdRadianceBaseModel {
    /** Text string for a unique Radiance object. Must not contain spaces or special characters. This will be used to identify the object across a model and in the exported Radiance files. */
    identifier!: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    readonly type: string = "IDdRadianceBaseModel";

    constructor(data?: IIDdRadianceBaseModel) {
        super(data);
        if (!data) {
            this.type = "IDdRadianceBaseModel";
        }
        this._discriminator = "IDdRadianceBaseModel";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.identifier = _data["identifier"];
            this.display_name = _data["display_name"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "IDdRadianceBaseModel";
        }
    }

    static override fromJS(data: any): IDdRadianceBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Mirror") {
            let result = new Mirror();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierBase") {
            let result = new ModifierBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "Plastic") {
            let result = new Plastic();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glass") {
            let result = new Glass();
            result.init(data);
            return result;
        }
        if (data["type"] === "BSDF") {
            let result = new BSDF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glow") {
            let result = new Glow();
            result.init(data);
            return result;
        }
        if (data["type"] === "Light") {
            let result = new Light();
            result.init(data);
            return result;
        }
        if (data["type"] === "Trans") {
            let result = new Trans();
            result.init(data);
            return result;
        }
        if (data["type"] === "Metal") {
            let result = new Metal();
            result.init(data);
            return result;
        }
        if (data["type"] === "StateGeometryAbridged") {
            let result = new StateGeometryAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierSet") {
            let result = new ModifierSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "ModifierSetAbridged") {
            let result = new ModifierSetAbridged();
            result.init(data);
            return result;
        }
        let result = new IDdRadianceBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["display_name"] = this.display_name;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a valid Radiance identifier. */
export interface IIDdRadianceBaseModel extends I_OpenAPIGenBaseModel {
    /** Text string for a unique Radiance object. Must not contain spaces or special characters. This will be used to identify the object across a model and in the exported Radiance files. */
    identifier: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    type?: string;
}

/** Base class for Radiance Modifiers */
export class ModifierBase extends IDdRadianceBaseModel implements IModifierBase {
    readonly type: string = "ModifierBase";

    constructor(data?: IModifierBase) {
        super(data);
        if (!data) {
            this.type = "ModifierBase";
        }
        this._discriminator = "ModifierBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModifierBase";
        }
    }

    static override fromJS(data: any): ModifierBase {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Mirror") {
            let result = new Mirror();
            result.init(data);
            return result;
        }
        if (data["type"] === "Plastic") {
            let result = new Plastic();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glass") {
            let result = new Glass();
            result.init(data);
            return result;
        }
        if (data["type"] === "BSDF") {
            let result = new BSDF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Glow") {
            let result = new Glow();
            result.init(data);
            return result;
        }
        if (data["type"] === "Light") {
            let result = new Light();
            result.init(data);
            return result;
        }
        if (data["type"] === "Trans") {
            let result = new Trans();
            result.init(data);
            return result;
        }
        if (data["type"] === "Metal") {
            let result = new Metal();
            result.init(data);
            return result;
        }
        let result = new ModifierBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for Radiance Modifiers */
export interface IModifierBase extends IIDdRadianceBaseModel {
    type?: string;
}

/** Radiance mirror material. */
export class Mirror extends ModifierBase implements IMirror {
    /** Material modifier. */
    modifier?: Modifier;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: Dependencies[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** An optional material (like the illum type) that may be used to specify a different material to be used for shading non-source rays. If None, this will keep the alternat_material as mirror. If this alternate material is given as Void, then the mirror surface will be invisible. Using Void is only appropriate if the surface hides other (more detailed) geometry with the same overall reflectance. */
    alternate_material?: Alternate_material;
    readonly type: string = "Mirror";

    constructor(data?: IMirror) {
        super(data);
        if (!data) {
            this.r_reflectance = 1;
            this.g_reflectance = 1;
            this.b_reflectance = 1;
            this.type = "Mirror";
        }
        this._discriminator = "Mirror";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_reflectance = _data["r_reflectance"] !== undefined ? _data["r_reflectance"] : 1;
            this.g_reflectance = _data["g_reflectance"] !== undefined ? _data["g_reflectance"] : 1;
            this.b_reflectance = _data["b_reflectance"] !== undefined ? _data["b_reflectance"] : 1;
            this.alternate_material = _data["alternate_material"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Mirror";
        }
    }

    static override fromJS(data: any): Mirror {
        data = typeof data === 'object' ? data : {};
        let result = new Mirror();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_reflectance"] = this.r_reflectance;
        data["g_reflectance"] = this.g_reflectance;
        data["b_reflectance"] = this.b_reflectance;
        data["alternate_material"] = this.alternate_material;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance mirror material. */
export interface IMirror extends IModifierBase {
    /** Material modifier. */
    modifier?: Modifier;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: Dependencies[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** An optional material (like the illum type) that may be used to specify a different material to be used for shading non-source rays. If None, this will keep the alternat_material as mirror. If this alternate material is given as Void, then the mirror surface will be invisible. Using Void is only appropriate if the surface hides other (more detailed) geometry with the same overall reflectance. */
    alternate_material?: Alternate_material;
    type?: string;
}

/** Radiance Translucent material. */
export class Trans extends ModifierBase implements ITrans {
    /** Material modifier. */
    modifier?: modifier;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions greater than 0.1 are not realistic for non-metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    /** The fraction of transmitted light that is transmitted diffusely in a scattering fashion. */
    transmitted_diff?: number;
    /** The fraction of transmitted light that is not diffusely scattered. */
    transmitted_spec?: number;
    readonly type: string = "Trans";

    constructor(data?: ITrans) {
        super(data);
        if (!data) {
            this.r_reflectance = 0;
            this.g_reflectance = 0;
            this.b_reflectance = 0;
            this.specularity = 0;
            this.roughness = 0;
            this.transmitted_diff = 0;
            this.transmitted_spec = 0;
            this.type = "Trans";
        }
        this._discriminator = "Trans";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_reflectance = _data["r_reflectance"] !== undefined ? _data["r_reflectance"] : 0;
            this.g_reflectance = _data["g_reflectance"] !== undefined ? _data["g_reflectance"] : 0;
            this.b_reflectance = _data["b_reflectance"] !== undefined ? _data["b_reflectance"] : 0;
            this.specularity = _data["specularity"] !== undefined ? _data["specularity"] : 0;
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : 0;
            this.transmitted_diff = _data["transmitted_diff"] !== undefined ? _data["transmitted_diff"] : 0;
            this.transmitted_spec = _data["transmitted_spec"] !== undefined ? _data["transmitted_spec"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Trans";
        }
    }

    static override fromJS(data: any): Trans {
        data = typeof data === 'object' ? data : {};
        let result = new Trans();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_reflectance"] = this.r_reflectance;
        data["g_reflectance"] = this.g_reflectance;
        data["b_reflectance"] = this.b_reflectance;
        data["specularity"] = this.specularity;
        data["roughness"] = this.roughness;
        data["transmitted_diff"] = this.transmitted_diff;
        data["transmitted_spec"] = this.transmitted_spec;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance Translucent material. */
export interface ITrans extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions greater than 0.1 are not realistic for non-metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    /** The fraction of transmitted light that is transmitted diffusely in a scattering fashion. */
    transmitted_diff?: number;
    /** The fraction of transmitted light that is not diffusely scattered. */
    transmitted_spec?: number;
    type?: string;
}

/** Radiance Light material. */
export class Light extends ModifierBase implements ILight {
    /** Material modifier. */
    modifier?: modifier2;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies2[];
    /** A value between 0 and 1 for the red channel of the modifier. */
    r_emittance?: number;
    /** A value between 0 and 1 for the green channel of the modifier. */
    g_emittance?: number;
    /** A value between 0 and 1 for the blue channel of the modifier. */
    b_emittance?: number;
    readonly type: string = "Light";

    constructor(data?: ILight) {
        super(data);
        if (!data) {
            this.r_emittance = 0;
            this.g_emittance = 0;
            this.b_emittance = 0;
            this.type = "Light";
        }
        this._discriminator = "Light";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_emittance = _data["r_emittance"] !== undefined ? _data["r_emittance"] : 0;
            this.g_emittance = _data["g_emittance"] !== undefined ? _data["g_emittance"] : 0;
            this.b_emittance = _data["b_emittance"] !== undefined ? _data["b_emittance"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Light";
        }
    }

    static override fromJS(data: any): Light {
        data = typeof data === 'object' ? data : {};
        let result = new Light();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_emittance"] = this.r_emittance;
        data["g_emittance"] = this.g_emittance;
        data["b_emittance"] = this.b_emittance;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance Light material. */
export interface ILight extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier2;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies2[];
    /** A value between 0 and 1 for the red channel of the modifier. */
    r_emittance?: number;
    /** A value between 0 and 1 for the green channel of the modifier. */
    g_emittance?: number;
    /** A value between 0 and 1 for the blue channel of the modifier. */
    b_emittance?: number;
    type?: string;
}

/** Radiance Glow material. */
export class Glow extends ModifierBase implements IGlow {
    /** Material modifier. */
    modifier?: modifier3;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies3[];
    /** A value between 0 and 1 for the red channel of the modifier. */
    r_emittance?: number;
    /** A value between 0 and 1 for the green channel of the modifier. */
    g_emittance?: number;
    /** A value between 0 and 1 for the blue channel of the modifier. */
    b_emittance?: number;
    /** Maximum radius for shadow testing. Objects with zero radius are permissable and may participate in interreflection calculation (though they are not representative of real light sources). Negative values will never contribute to scene illumination. */
    max_radius?: number;
    readonly type: string = "Glow";

    constructor(data?: IGlow) {
        super(data);
        if (!data) {
            this.r_emittance = 0;
            this.g_emittance = 0;
            this.b_emittance = 0;
            this.max_radius = 0;
            this.type = "Glow";
        }
        this._discriminator = "Glow";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_emittance = _data["r_emittance"] !== undefined ? _data["r_emittance"] : 0;
            this.g_emittance = _data["g_emittance"] !== undefined ? _data["g_emittance"] : 0;
            this.b_emittance = _data["b_emittance"] !== undefined ? _data["b_emittance"] : 0;
            this.max_radius = _data["max_radius"] !== undefined ? _data["max_radius"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Glow";
        }
    }

    static override fromJS(data: any): Glow {
        data = typeof data === 'object' ? data : {};
        let result = new Glow();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_emittance"] = this.r_emittance;
        data["g_emittance"] = this.g_emittance;
        data["b_emittance"] = this.b_emittance;
        data["max_radius"] = this.max_radius;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance Glow material. */
export interface IGlow extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier3;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies3[];
    /** A value between 0 and 1 for the red channel of the modifier. */
    r_emittance?: number;
    /** A value between 0 and 1 for the green channel of the modifier. */
    g_emittance?: number;
    /** A value between 0 and 1 for the blue channel of the modifier. */
    b_emittance?: number;
    /** Maximum radius for shadow testing. Objects with zero radius are permissable and may participate in interreflection calculation (though they are not representative of real light sources). Negative values will never contribute to scene illumination. */
    max_radius?: number;
    type?: string;
}

/** Radiance BSDF (Bidirectional Scattering Distribution Function) material. */
export class BSDF extends ModifierBase implements IBSDF {
    /** A string with the contents of the BSDF XML file. */
    bsdf_data!: string;
    /** Material modifier. */
    modifier?: modifier4;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies4[];
    /** Vector as sequence that sets the hemisphere that the BSDF material faces. */
    up_orientation?: number[];
    /** Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative). */
    thickness?: number;
    /** Optional input for function file. Using "." will ensure that BSDF data is written to the root of wherever a given study is run. */
    function_file?: string;
    /** Optional transform input to scale the thickness and reorient the up vector. */
    transform?: string;
    /** Optional additional front diffuse reflectance as sequence of three RGB numbers. */
    front_diffuse_reflectance?: number[];
    /** Optional additional back diffuse reflectance as sequence of three RGB numbers. */
    back_diffuse_reflectance?: number[];
    /** Optional additional diffuse transmittance as sequence of three RGB numbers. */
    diffuse_transmittance?: number[];
    readonly type: string = "BSDF";

    constructor(data?: IBSDF) {
        super(data);
        if (!data) {
            this.thickness = 0;
            this.function_file = ".";
            this.type = "BSDF";
        }
        this._discriminator = "BSDF";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bsdf_data = _data["bsdf_data"];
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            if (Array.isArray(_data["up_orientation"])) {
                this.up_orientation = [] as any;
                for (let item of _data["up_orientation"])
                    this.up_orientation!.push(item);
            }
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0;
            this.function_file = _data["function_file"] !== undefined ? _data["function_file"] : ".";
            this.transform = _data["transform"];
            if (Array.isArray(_data["front_diffuse_reflectance"])) {
                this.front_diffuse_reflectance = [] as any;
                for (let item of _data["front_diffuse_reflectance"])
                    this.front_diffuse_reflectance!.push(item);
            }
            if (Array.isArray(_data["back_diffuse_reflectance"])) {
                this.back_diffuse_reflectance = [] as any;
                for (let item of _data["back_diffuse_reflectance"])
                    this.back_diffuse_reflectance!.push(item);
            }
            if (Array.isArray(_data["diffuse_transmittance"])) {
                this.diffuse_transmittance = [] as any;
                for (let item of _data["diffuse_transmittance"])
                    this.diffuse_transmittance!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BSDF";
        }
    }

    static override fromJS(data: any): BSDF {
        data = typeof data === 'object' ? data : {};
        let result = new BSDF();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bsdf_data"] = this.bsdf_data;
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        if (Array.isArray(this.up_orientation)) {
            data["up_orientation"] = [];
            for (let item of this.up_orientation)
                data["up_orientation"].push(item);
        }
        data["thickness"] = this.thickness;
        data["function_file"] = this.function_file;
        data["transform"] = this.transform;
        if (Array.isArray(this.front_diffuse_reflectance)) {
            data["front_diffuse_reflectance"] = [];
            for (let item of this.front_diffuse_reflectance)
                data["front_diffuse_reflectance"].push(item);
        }
        if (Array.isArray(this.back_diffuse_reflectance)) {
            data["back_diffuse_reflectance"] = [];
            for (let item of this.back_diffuse_reflectance)
                data["back_diffuse_reflectance"].push(item);
        }
        if (Array.isArray(this.diffuse_transmittance)) {
            data["diffuse_transmittance"] = [];
            for (let item of this.diffuse_transmittance)
                data["diffuse_transmittance"].push(item);
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance BSDF (Bidirectional Scattering Distribution Function) material. */
export interface IBSDF extends IModifierBase {
    /** A string with the contents of the BSDF XML file. */
    bsdf_data: string;
    /** Material modifier. */
    modifier?: modifier4;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies4[];
    /** Vector as sequence that sets the hemisphere that the BSDF material faces. */
    up_orientation?: number[];
    /** Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative). */
    thickness?: number;
    /** Optional input for function file. Using "." will ensure that BSDF data is written to the root of wherever a given study is run. */
    function_file?: string;
    /** Optional transform input to scale the thickness and reorient the up vector. */
    transform?: string;
    /** Optional additional front diffuse reflectance as sequence of three RGB numbers. */
    front_diffuse_reflectance?: number[];
    /** Optional additional back diffuse reflectance as sequence of three RGB numbers. */
    back_diffuse_reflectance?: number[];
    /** Optional additional diffuse transmittance as sequence of three RGB numbers. */
    diffuse_transmittance?: number[];
    type?: string;
}

/** Radiance glass material. */
export class Glass extends ModifierBase implements IGlass {
    /** Material modifier. */
    modifier?: modifier5;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies5[];
    /** A value between 0 and 1 for the red channel transmissivity. */
    r_transmissivity?: number;
    /** A value between 0 and 1 for the green channel transmissivity. */
    g_transmissivity?: number;
    /** A value between 0 and 1 for the blue channel transmissivity. */
    b_transmissivity?: number;
    /** A value greater than 1 for the index of refraction. Typical values are 1.52 for float glass and 1.4 for ETFE. */
    refraction_index?: number;
    readonly type: string = "Glass";

    constructor(data?: IGlass) {
        super(data);
        if (!data) {
            this.r_transmissivity = 0;
            this.g_transmissivity = 0;
            this.b_transmissivity = 0;
            this.refraction_index = 1.52;
            this.type = "Glass";
        }
        this._discriminator = "Glass";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_transmissivity = _data["r_transmissivity"] !== undefined ? _data["r_transmissivity"] : 0;
            this.g_transmissivity = _data["g_transmissivity"] !== undefined ? _data["g_transmissivity"] : 0;
            this.b_transmissivity = _data["b_transmissivity"] !== undefined ? _data["b_transmissivity"] : 0;
            this.refraction_index = _data["refraction_index"] !== undefined ? _data["refraction_index"] : 1.52;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Glass";
        }
    }

    static override fromJS(data: any): Glass {
        data = typeof data === 'object' ? data : {};
        let result = new Glass();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_transmissivity"] = this.r_transmissivity;
        data["g_transmissivity"] = this.g_transmissivity;
        data["b_transmissivity"] = this.b_transmissivity;
        data["refraction_index"] = this.refraction_index;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance glass material. */
export interface IGlass extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier5;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies5[];
    /** A value between 0 and 1 for the red channel transmissivity. */
    r_transmissivity?: number;
    /** A value between 0 and 1 for the green channel transmissivity. */
    g_transmissivity?: number;
    /** A value between 0 and 1 for the blue channel transmissivity. */
    b_transmissivity?: number;
    /** A value greater than 1 for the index of refraction. Typical values are 1.52 for float glass and 1.4 for ETFE. */
    refraction_index?: number;
    type?: string;
}

/** Radiance plastic material. */
export class Plastic extends ModifierBase implements IPlastic {
    /** Material modifier. */
    modifier?: modifier6;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies6[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions greater than 0.1 are not realistic for non-metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    readonly type: string = "Plastic";

    constructor(data?: IPlastic) {
        super(data);
        if (!data) {
            this.r_reflectance = 0;
            this.g_reflectance = 0;
            this.b_reflectance = 0;
            this.specularity = 0;
            this.roughness = 0;
            this.type = "Plastic";
        }
        this._discriminator = "Plastic";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_reflectance = _data["r_reflectance"] !== undefined ? _data["r_reflectance"] : 0;
            this.g_reflectance = _data["g_reflectance"] !== undefined ? _data["g_reflectance"] : 0;
            this.b_reflectance = _data["b_reflectance"] !== undefined ? _data["b_reflectance"] : 0;
            this.specularity = _data["specularity"] !== undefined ? _data["specularity"] : 0;
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Plastic";
        }
    }

    static override fromJS(data: any): Plastic {
        data = typeof data === 'object' ? data : {};
        let result = new Plastic();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_reflectance"] = this.r_reflectance;
        data["g_reflectance"] = this.g_reflectance;
        data["b_reflectance"] = this.b_reflectance;
        data["specularity"] = this.specularity;
        data["roughness"] = this.roughness;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance plastic material. */
export interface IPlastic extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier6;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies6[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions greater than 0.1 are not realistic for non-metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    type?: string;
}

/** Radiance metal material. */
export class Metal extends ModifierBase implements IMetal {
    /** Material modifier. */
    modifier?: modifier7;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies7[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions lower than 0.9 are not realistic for metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    readonly type: string = "Metal";

    constructor(data?: IMetal) {
        super(data);
        if (!data) {
            this.r_reflectance = 0;
            this.g_reflectance = 0;
            this.b_reflectance = 0;
            this.specularity = 0.9;
            this.roughness = 0;
            this.type = "Metal";
        }
        this._discriminator = "Metal";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.r_reflectance = _data["r_reflectance"] !== undefined ? _data["r_reflectance"] : 0;
            this.g_reflectance = _data["g_reflectance"] !== undefined ? _data["g_reflectance"] : 0;
            this.b_reflectance = _data["b_reflectance"] !== undefined ? _data["b_reflectance"] : 0;
            this.specularity = _data["specularity"] !== undefined ? _data["specularity"] : 0.9;
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Metal";
        }
    }

    static override fromJS(data: any): Metal {
        data = typeof data === 'object' ? data : {};
        let result = new Metal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["r_reflectance"] = this.r_reflectance;
        data["g_reflectance"] = this.g_reflectance;
        data["b_reflectance"] = this.b_reflectance;
        data["specularity"] = this.specularity;
        data["roughness"] = this.roughness;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance metal material. */
export interface IMetal extends IModifierBase {
    /** Material modifier. */
    modifier?: modifier7;
    /** List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers. */
    dependencies?: dependencies7[];
    /** A value between 0 and 1 for the red channel reflectance. */
    r_reflectance?: number;
    /** A value between 0 and 1 for the green channel reflectance. */
    g_reflectance?: number;
    /** A value between 0 and 1 for the blue channel reflectance. */
    b_reflectance?: number;
    /** A value between 0 and 1 for the fraction of specularity. Specularity fractions lower than 0.9 are not realistic for metallic materials. */
    specularity?: number;
    /** A value between 0 and 1 for the roughness, specified as the RMS slope of surface facets. Roughness greater than 0.2 are not realistic. */
    roughness?: number;
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Plane extends _OpenAPIGenBaseModel implements IPlane {
    /** Plane normal as 3 (x, y, z) values. */
    n!: number[];
    /** Plane origin as 3 (x, y, z) values */
    o!: number[];
    readonly type: string = "Plane";
    /** Plane x-axis as 3 (x, y, z) values. If None, it is autocalculated. */
    x?: number[];

    constructor(data?: IPlane) {
        super(data);
        if (!data) {
            this.n = [];
            this.o = [];
            this.type = "Plane";
        }
        this._discriminator = "Plane";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["n"])) {
                this.n = [] as any;
                for (let item of _data["n"])
                    this.n!.push(item);
            }
            if (Array.isArray(_data["o"])) {
                this.o = [] as any;
                for (let item of _data["o"])
                    this.o!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Plane";
            if (Array.isArray(_data["x"])) {
                this.x = [] as any;
                for (let item of _data["x"])
                    this.x!.push(item);
            }
        }
    }

    static override fromJS(data: any): Plane {
        data = typeof data === 'object' ? data : {};
        let result = new Plane();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.n)) {
            data["n"] = [];
            for (let item of this.n)
                data["n"].push(item);
        }
        if (Array.isArray(this.o)) {
            data["o"] = [];
            for (let item of this.o)
                data["o"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.x)) {
            data["x"] = [];
            for (let item of this.x)
                data["x"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IPlane extends I_OpenAPIGenBaseModel {
    /** Plane normal as 3 (x, y, z) values. */
    n: number[];
    /** Plane origin as 3 (x, y, z) values */
    o: number[];
    type?: string;
    /** Plane x-axis as 3 (x, y, z) values. If None, it is autocalculated. */
    x?: number[];
}

/** A single planar face in 3D space. */
export class Face3D extends _OpenAPIGenBaseModel implements IFace3D {
    /** A list of points representing the outer boundary vertices of the face. The list should include at least 3 points and each point should be a list of 3 (x, y, z) values. */
    boundary!: number[][];
    readonly type: string = "Face3D";
    /** Optional list of lists with one list for each hole in the face.Each hole should be a list of at least 3 points and each point a list of 3 (x, y, z) values. If None, it will be assumed that there are no holes in the face. */
    holes?: number[][][];
    /** Optional Plane indicating the plane in which the face exists.If None, the plane will usually be derived from the boundary points. */
    plane?: Plane;

    constructor(data?: IFace3D) {
        super(data);
        if (!data) {
            this.boundary = [];
            this.type = "Face3D";
        }
        this._discriminator = "Face3D";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["boundary"])) {
                this.boundary = [] as any;
                for (let item of _data["boundary"])
                    this.boundary!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Face3D";
            if (Array.isArray(_data["holes"])) {
                this.holes = [] as any;
                for (let item of _data["holes"])
                    this.holes!.push(item);
            }
            this.plane = _data["plane"] ? Plane.fromJS(_data["plane"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Face3D {
        data = typeof data === 'object' ? data : {};
        let result = new Face3D();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.boundary)) {
            data["boundary"] = [];
            for (let item of this.boundary)
                data["boundary"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.holes)) {
            data["holes"] = [];
            for (let item of this.holes)
                data["holes"].push(item);
        }
        data["plane"] = this.plane ? this.plane.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A single planar face in 3D space. */
export interface IFace3D extends I_OpenAPIGenBaseModel {
    /** A list of points representing the outer boundary vertices of the face. The list should include at least 3 points and each point should be a list of 3 (x, y, z) values. */
    boundary: number[][];
    type?: string;
    /** Optional list of lists with one list for each hole in the face.Each hole should be a list of at least 3 points and each point a list of 3 (x, y, z) values. If None, it will be assumed that there are no holes in the face. */
    holes?: number[][][];
    /** Optional Plane indicating the plane in which the face exists.If None, the plane will usually be derived from the boundary points. */
    plane?: Plane;
}

/** An enumeration. */
export enum GasType {
    Air = "Air",
    Argon = "Argon",
    Krypton = "Krypton",
    Xenon = "Xenon",
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export class EnergyBaseModel extends _OpenAPIGenBaseModel implements IEnergyBaseModel {
    /** Text string for a unique object ID. This identifier remains constant as the object is mutated, copied, and serialized to different formats (eg. dict, idf, osm). This identifier is also used to reference the object across a Model. It must be < 100 characters, use only ASCII characters and exclude (, ; ! \n \t). */
    identifier!: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    readonly type: string = "EnergyBaseModel";

    constructor(data?: IEnergyBaseModel) {
        super(data);
        if (!data) {
            this.type = "EnergyBaseModel";
        }
        this._discriminator = "EnergyBaseModel";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.identifier = _data["identifier"];
            this.display_name = _data["display_name"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyBaseModel";
        }
    }

    static override fromJS(data: any): EnergyBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "EnergyWindowMaterialGas") {
            let result = new EnergyWindowMaterialGas();
            result.init(data);
            return result;
        }
        if (data["type"] === "IDdEnergyBaseModel") {
            let result = new IDdEnergyBaseModel();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterial") {
            let result = new EnergyMaterial();
            result.init(data);
            return result;
        }
        if (data["type"] === "PVProperties") {
            let result = new PVProperties();
            result.init(data);
            return result;
        }
        if (data["type"] === "PeopleAbridged") {
            let result = new PeopleAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "LightingAbridged") {
            let result = new LightingAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipmentAbridged") {
            let result = new ElectricEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_EquipmentBase") {
            let result = new _EquipmentBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipmentAbridged") {
            let result = new GasEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWaterAbridged") {
            let result = new ServiceHotWaterAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "InfiltrationAbridged") {
            let result = new InfiltrationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationAbridged") {
            let result = new VentilationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "SetpointAbridged") {
            let result = new SetpointAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationFan") {
            let result = new VentilationFan();
            result.init(data);
            return result;
        }
        if (data["type"] === "InternalMassAbridged") {
            let result = new InternalMassAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProcessAbridged") {
            let result = new ProcessAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGlazing") {
            let result = new EnergyWindowMaterialGlazing();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialNoMass") {
            let result = new EnergyMaterialNoMass();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialVegetation") {
            let result = new EnergyMaterialVegetation();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstruction") {
            let result = new OpaqueConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstructionAbridged") {
            let result = new OpaqueConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionAbridged") {
            let result = new WindowConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeConstruction") {
            let result = new ShadeConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstructionAbridged") {
            let result = new AirBoundaryConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSetAbridged") {
            let result = new ConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialSimpleGlazSys") {
            let result = new EnergyWindowMaterialSimpleGlazSys();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasCustom") {
            let result = new EnergyWindowMaterialGasCustom();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasMixture") {
            let result = new EnergyWindowMaterialGasMixture();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowFrame") {
            let result = new EnergyWindowFrame();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstruction") {
            let result = new WindowConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialShade") {
            let result = new EnergyWindowMaterialShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialBlind") {
            let result = new EnergyWindowMaterialBlind();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleDay") {
            let result = new ScheduleDay();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleTypeLimit") {
            let result = new ScheduleTypeLimit();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRuleset") {
            let result = new ScheduleRuleset();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedInterval") {
            let result = new ScheduleFixedInterval();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShade") {
            let result = new WindowConstructionShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionDynamic") {
            let result = new WindowConstructionDynamic();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstruction") {
            let result = new AirBoundaryConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSet") {
            let result = new ConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "IdealAirSystemAbridged") {
            let result = new IdealAirSystemAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VAV") {
            let result = new VAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PVAV") {
            let result = new PVAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PSZ") {
            let result = new PSZ();
            result.init(data);
            return result;
        }
        if (data["type"] === "PTAC") {
            let result = new PTAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "ForcedAirFurnace") {
            let result = new ForcedAirFurnace();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCUwithDOASAbridged") {
            let result = new FCUwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHPwithDOASAbridged") {
            let result = new WSHPwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRFwithDOASAbridged") {
            let result = new VRFwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RadiantwithDOASAbridged") {
            let result = new RadiantwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCU") {
            let result = new FCU();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHP") {
            let result = new WSHP();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRF") {
            let result = new VRF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Baseboard") {
            let result = new Baseboard();
            result.init(data);
            return result;
        }
        if (data["type"] === "EvaporativeCooler") {
            let result = new EvaporativeCooler();
            result.init(data);
            return result;
        }
        if (data["type"] === "Residential") {
            let result = new Residential();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowAC") {
            let result = new WindowAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasUnitHeater") {
            let result = new GasUnitHeater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Radiant") {
            let result = new Radiant();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedHVAC") {
            let result = new DetailedHVAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "SHWSystem") {
            let result = new SHWSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramTypeAbridged") {
            let result = new ProgramTypeAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "People") {
            let result = new People();
            result.init(data);
            return result;
        }
        if (data["type"] === "Lighting") {
            let result = new Lighting();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipment") {
            let result = new ElectricEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipment") {
            let result = new GasEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWater") {
            let result = new ServiceHotWater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Infiltration") {
            let result = new Infiltration();
            result.init(data);
            return result;
        }
        if (data["type"] === "Ventilation") {
            let result = new Ventilation();
            result.init(data);
            return result;
        }
        if (data["type"] === "Setpoint") {
            let result = new Setpoint();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramType") {
            let result = new ProgramType();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRulesetAbridged") {
            let result = new ScheduleRulesetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedIntervalAbridged") {
            let result = new ScheduleFixedIntervalAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_HeatCoolBase") {
            let result = new _HeatCoolBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_TemplateSystem") {
            let result = new _TemplateSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "_DOASBase") {
            let result = new _DOASBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_AllAirBase") {
            let result = new _AllAirBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShadeAbridged") {
            let result = new WindowConstructionShadeAbridged();
            result.init(data);
            return result;
        }
        let result = new EnergyBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["display_name"] = this.display_name;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export interface IEnergyBaseModel extends I_OpenAPIGenBaseModel {
    /** Text string for a unique object ID. This identifier remains constant as the object is mutated, copied, and serialized to different formats (eg. dict, idf, osm). This identifier is also used to reference the object across a Model. It must be < 100 characters, use only ASCII characters and exclude (, ; ! \n \t). */
    identifier: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class IDdEnergyBaseModel extends EnergyBaseModel implements IIDdEnergyBaseModel {
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). */
    user_data?: any;
    readonly type: string = "IDdEnergyBaseModel";

    constructor(data?: IIDdEnergyBaseModel) {
        super(data);
        if (!data) {
            this.type = "IDdEnergyBaseModel";
        }
        this._discriminator = "IDdEnergyBaseModel";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user_data = _data["user_data"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "IDdEnergyBaseModel";
        }
    }

    static override fromJS(data: any): IDdEnergyBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "EnergyWindowMaterialGas") {
            let result = new EnergyWindowMaterialGas();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterial") {
            let result = new EnergyMaterial();
            result.init(data);
            return result;
        }
        if (data["type"] === "PeopleAbridged") {
            let result = new PeopleAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "LightingAbridged") {
            let result = new LightingAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipmentAbridged") {
            let result = new ElectricEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_EquipmentBase") {
            let result = new _EquipmentBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipmentAbridged") {
            let result = new GasEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWaterAbridged") {
            let result = new ServiceHotWaterAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "InfiltrationAbridged") {
            let result = new InfiltrationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VentilationAbridged") {
            let result = new VentilationAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "SetpointAbridged") {
            let result = new SetpointAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "InternalMassAbridged") {
            let result = new InternalMassAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProcessAbridged") {
            let result = new ProcessAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGlazing") {
            let result = new EnergyWindowMaterialGlazing();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialNoMass") {
            let result = new EnergyMaterialNoMass();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyMaterialVegetation") {
            let result = new EnergyMaterialVegetation();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstruction") {
            let result = new OpaqueConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "OpaqueConstructionAbridged") {
            let result = new OpaqueConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionAbridged") {
            let result = new WindowConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeConstruction") {
            let result = new ShadeConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstructionAbridged") {
            let result = new AirBoundaryConstructionAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSetAbridged") {
            let result = new ConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialSimpleGlazSys") {
            let result = new EnergyWindowMaterialSimpleGlazSys();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasCustom") {
            let result = new EnergyWindowMaterialGasCustom();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialGasMixture") {
            let result = new EnergyWindowMaterialGasMixture();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowFrame") {
            let result = new EnergyWindowFrame();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstruction") {
            let result = new WindowConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialShade") {
            let result = new EnergyWindowMaterialShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "EnergyWindowMaterialBlind") {
            let result = new EnergyWindowMaterialBlind();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRuleset") {
            let result = new ScheduleRuleset();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedInterval") {
            let result = new ScheduleFixedInterval();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShade") {
            let result = new WindowConstructionShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionDynamic") {
            let result = new WindowConstructionDynamic();
            result.init(data);
            return result;
        }
        if (data["type"] === "AirBoundaryConstruction") {
            let result = new AirBoundaryConstruction();
            result.init(data);
            return result;
        }
        if (data["type"] === "ConstructionSet") {
            let result = new ConstructionSet();
            result.init(data);
            return result;
        }
        if (data["type"] === "IdealAirSystemAbridged") {
            let result = new IdealAirSystemAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VAV") {
            let result = new VAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PVAV") {
            let result = new PVAV();
            result.init(data);
            return result;
        }
        if (data["type"] === "PSZ") {
            let result = new PSZ();
            result.init(data);
            return result;
        }
        if (data["type"] === "PTAC") {
            let result = new PTAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "ForcedAirFurnace") {
            let result = new ForcedAirFurnace();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCUwithDOASAbridged") {
            let result = new FCUwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHPwithDOASAbridged") {
            let result = new WSHPwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRFwithDOASAbridged") {
            let result = new VRFwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RadiantwithDOASAbridged") {
            let result = new RadiantwithDOASAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FCU") {
            let result = new FCU();
            result.init(data);
            return result;
        }
        if (data["type"] === "WSHP") {
            let result = new WSHP();
            result.init(data);
            return result;
        }
        if (data["type"] === "VRF") {
            let result = new VRF();
            result.init(data);
            return result;
        }
        if (data["type"] === "Baseboard") {
            let result = new Baseboard();
            result.init(data);
            return result;
        }
        if (data["type"] === "EvaporativeCooler") {
            let result = new EvaporativeCooler();
            result.init(data);
            return result;
        }
        if (data["type"] === "Residential") {
            let result = new Residential();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowAC") {
            let result = new WindowAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasUnitHeater") {
            let result = new GasUnitHeater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Radiant") {
            let result = new Radiant();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedHVAC") {
            let result = new DetailedHVAC();
            result.init(data);
            return result;
        }
        if (data["type"] === "SHWSystem") {
            let result = new SHWSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramTypeAbridged") {
            let result = new ProgramTypeAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "People") {
            let result = new People();
            result.init(data);
            return result;
        }
        if (data["type"] === "Lighting") {
            let result = new Lighting();
            result.init(data);
            return result;
        }
        if (data["type"] === "ElectricEquipment") {
            let result = new ElectricEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipment") {
            let result = new GasEquipment();
            result.init(data);
            return result;
        }
        if (data["type"] === "ServiceHotWater") {
            let result = new ServiceHotWater();
            result.init(data);
            return result;
        }
        if (data["type"] === "Infiltration") {
            let result = new Infiltration();
            result.init(data);
            return result;
        }
        if (data["type"] === "Ventilation") {
            let result = new Ventilation();
            result.init(data);
            return result;
        }
        if (data["type"] === "Setpoint") {
            let result = new Setpoint();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProgramType") {
            let result = new ProgramType();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleRulesetAbridged") {
            let result = new ScheduleRulesetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ScheduleFixedIntervalAbridged") {
            let result = new ScheduleFixedIntervalAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "_HeatCoolBase") {
            let result = new _HeatCoolBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_TemplateSystem") {
            let result = new _TemplateSystem();
            result.init(data);
            return result;
        }
        if (data["type"] === "_DOASBase") {
            let result = new _DOASBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "_AllAirBase") {
            let result = new _AllAirBase();
            result.init(data);
            return result;
        }
        if (data["type"] === "WindowConstructionShadeAbridged") {
            let result = new WindowConstructionShadeAbridged();
            result.init(data);
            return result;
        }
        let result = new IDdEnergyBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_data"] = this.user_data;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IIDdEnergyBaseModel extends IEnergyBaseModel {
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). */
    user_data?: any;
    type?: string;
}

/** Create single layer of gas in a window construction. Can be combined with EnergyWindowMaterialGlazing to make multi-pane windows. */
export class EnergyWindowMaterialGas extends IDdEnergyBaseModel implements IEnergyWindowMaterialGas {
    readonly type: string = "EnergyWindowMaterialGas";
    /** Thickness of the gas layer in meters. Default: 0.0125. */
    thickness?: number;
    gas_type?: GasType;

    constructor(data?: IEnergyWindowMaterialGas) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialGas";
            this.thickness = 0.0125;
            this.gas_type = GasType.Air;
        }
        this._discriminator = "EnergyWindowMaterialGas";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialGas";
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.0125;
            this.gas_type = _data["gas_type"] !== undefined ? _data["gas_type"] : GasType.Air;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialGas {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialGas();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["thickness"] = this.thickness;
        data["gas_type"] = this.gas_type;
        super.toJSON(data);
        return data;
    }
}

/** Create single layer of gas in a window construction. Can be combined with EnergyWindowMaterialGlazing to make multi-pane windows. */
export interface IEnergyWindowMaterialGas extends IIDdEnergyBaseModel {
    type?: string;
    /** Thickness of the gas layer in meters. Default: 0.0125. */
    thickness?: number;
    gas_type?: GasType;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ContextShadeRadiancePropertiesAbridged extends _OpenAPIGenBaseModel implements IContextShadeRadiancePropertiesAbridged {
    readonly type: string = "ContextShadeRadiancePropertiesAbridged";
    /** Name of a Modifier to set the reflectance and specularity of the ContextShade. If None, the the default of 0.2 diffuse reflectance will be used. */
    modifier?: string;

    constructor(data?: IContextShadeRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ContextShadeRadiancePropertiesAbridged";
        }
        this._discriminator = "ContextShadeRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ContextShadeRadiancePropertiesAbridged";
            this.modifier = _data["modifier"];
        }
    }

    static override fromJS(data: any): ContextShadeRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ContextShadeRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier"] = this.modifier;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IContextShadeRadiancePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a Modifier to set the reflectance and specularity of the ContextShade. If None, the the default of 0.2 diffuse reflectance will be used. */
    modifier?: string;
}

/** Relative roughness of a particular material layer. */
export enum Roughness {
    VeryRough = "VeryRough",
    Rough = "Rough",
    MediumRough = "MediumRough",
    MediumSmooth = "MediumSmooth",
    Smooth = "Smooth",
    VerySmooth = "VerySmooth",
}

/** Opaque material representing a layer within an opaque construction. */
export class EnergyMaterial extends IDdEnergyBaseModel implements IEnergyMaterial {
    /** Thickness of the material layer in meters. */
    thickness!: number;
    /** Thermal conductivity of the material layer in W/m-K. */
    conductivity!: number;
    /** Density of the material layer in kg/m3. */
    density!: number;
    /** Specific heat of the material layer in J/kg-K. */
    specific_heat!: number;
    readonly type: string = "EnergyMaterial";
    roughness?: Roughness;
    /** Fraction of incident long wavelength radiation that is absorbed by the material. Default: 0.9. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the material. Default: 0.7. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    visible_absorptance?: number;

    constructor(data?: IEnergyMaterial) {
        super(data);
        if (!data) {
            this.type = "EnergyMaterial";
            this.roughness = Roughness.MediumRough;
            this.thermal_absorptance = 0.9;
            this.solar_absorptance = 0.7;
            this.visible_absorptance = 0.7;
        }
        this._discriminator = "EnergyMaterial";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.thickness = _data["thickness"];
            this.conductivity = _data["conductivity"];
            this.density = _data["density"];
            this.specific_heat = _data["specific_heat"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyMaterial";
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : Roughness.MediumRough;
            this.thermal_absorptance = _data["thermal_absorptance"] !== undefined ? _data["thermal_absorptance"] : 0.9;
            this.solar_absorptance = _data["solar_absorptance"] !== undefined ? _data["solar_absorptance"] : 0.7;
            this.visible_absorptance = _data["visible_absorptance"] !== undefined ? _data["visible_absorptance"] : 0.7;
        }
    }

    static override fromJS(data: any): EnergyMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyMaterial();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thickness"] = this.thickness;
        data["conductivity"] = this.conductivity;
        data["density"] = this.density;
        data["specific_heat"] = this.specific_heat;
        data["type"] = this.type;
        data["roughness"] = this.roughness;
        data["thermal_absorptance"] = this.thermal_absorptance;
        data["solar_absorptance"] = this.solar_absorptance;
        data["visible_absorptance"] = this.visible_absorptance;
        super.toJSON(data);
        return data;
    }
}

/** Opaque material representing a layer within an opaque construction. */
export interface IEnergyMaterial extends IIDdEnergyBaseModel {
    /** Thickness of the material layer in meters. */
    thickness: number;
    /** Thermal conductivity of the material layer in W/m-K. */
    conductivity: number;
    /** Density of the material layer in kg/m3. */
    density: number;
    /** Specific heat of the material layer in J/kg-K. */
    specific_heat: number;
    type?: string;
    roughness?: Roughness;
    /** Fraction of incident long wavelength radiation that is absorbed by the material. Default: 0.9. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the material. Default: 0.7. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    visible_absorptance?: number;
}

/** An enumeration. */
export enum FaceType {
    Wall = "Wall",
    Floor = "Floor",
    RoofCeiling = "RoofCeiling",
    AirBoundary = "AirBoundary",
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Ground extends _OpenAPIGenBaseModel implements IGround {
    readonly type: string = "Ground";

    constructor(data?: IGround) {
        super(data);
        if (!data) {
            this.type = "Ground";
        }
        this._discriminator = "Ground";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Ground";
        }
    }

    static override fromJS(data: any): Ground {
        data = typeof data === 'object' ? data : {};
        let result = new Ground();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IGround extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Autocalculate extends _OpenAPIGenBaseModel implements IAutocalculate {
    readonly type: string = "Autocalculate";

    constructor(data?: IAutocalculate) {
        super(data);
        if (!data) {
            this.type = "Autocalculate";
        }
        this._discriminator = "Autocalculate";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Autocalculate";
        }
    }

    static override fromJS(data: any): Autocalculate {
        data = typeof data === 'object' ? data : {};
        let result = new Autocalculate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IAutocalculate extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Outdoors extends _OpenAPIGenBaseModel implements IOutdoors {
    readonly type: string = "Outdoors";
    /** A boolean noting whether the boundary is exposed to sun. */
    sun_exposure?: boolean;
    /** A boolean noting whether the boundary is exposed to wind. */
    wind_exposure?: boolean;
    /** A number for the view factor to the ground. This can also be an Autocalculate object to have the view factor automatically calculated. */
    view_factor?: View_factor;

    constructor(data?: IOutdoors) {
        super(data);
        if (!data) {
            this.type = "Outdoors";
            this.sun_exposure = true;
            this.wind_exposure = true;
        }
        this._discriminator = "Outdoors";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Outdoors";
            this.sun_exposure = _data["sun_exposure"] !== undefined ? _data["sun_exposure"] : true;
            this.wind_exposure = _data["wind_exposure"] !== undefined ? _data["wind_exposure"] : true;
            this.view_factor = _data["view_factor"];
        }
    }

    static override fromJS(data: any): Outdoors {
        data = typeof data === 'object' ? data : {};
        let result = new Outdoors();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["sun_exposure"] = this.sun_exposure;
        data["wind_exposure"] = this.wind_exposure;
        data["view_factor"] = this.view_factor;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IOutdoors extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A boolean noting whether the boundary is exposed to sun. */
    sun_exposure?: boolean;
    /** A boolean noting whether the boundary is exposed to wind. */
    wind_exposure?: boolean;
    /** A number for the view factor to the ground. This can also be an Autocalculate object to have the view factor automatically calculated. */
    view_factor?: View_factor;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Adiabatic extends _OpenAPIGenBaseModel implements IAdiabatic {
    readonly type: string = "Adiabatic";

    constructor(data?: IAdiabatic) {
        super(data);
        if (!data) {
            this.type = "Adiabatic";
        }
        this._discriminator = "Adiabatic";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Adiabatic";
        }
    }

    static override fromJS(data: any): Adiabatic {
        data = typeof data === 'object' ? data : {};
        let result = new Adiabatic();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IAdiabatic extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Surface extends _OpenAPIGenBaseModel implements ISurface {
    /** A list of up to 3 object identifiers that are adjacent to this one. The first object is always the one that is immediately adjacent and is of the same object type (Face, Aperture, Door). When this boundary condition is applied to a Face, the second object in the tuple will be the parent Room of the adjacent object. When the boundary condition is applied to a sub-face (Door or Aperture), the second object will be the parent Face of the adjacent sub-face and the third object will be the parent Room of the adjacent sub-face. */
    boundary_condition_objects!: string[];
    readonly type: string = "Surface";

    constructor(data?: ISurface) {
        super(data);
        if (!data) {
            this.boundary_condition_objects = [];
            this.type = "Surface";
        }
        this._discriminator = "Surface";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["boundary_condition_objects"])) {
                this.boundary_condition_objects = [] as any;
                for (let item of _data["boundary_condition_objects"])
                    this.boundary_condition_objects!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Surface";
        }
    }

    static override fromJS(data: any): Surface {
        data = typeof data === 'object' ? data : {};
        let result = new Surface();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.boundary_condition_objects)) {
            data["boundary_condition_objects"] = [];
            for (let item of this.boundary_condition_objects)
                data["boundary_condition_objects"].push(item);
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface ISurface extends I_OpenAPIGenBaseModel {
    /** A list of up to 3 object identifiers that are adjacent to this one. The first object is always the one that is immediately adjacent and is of the same object type (Face, Aperture, Door). When this boundary condition is applied to a Face, the second object in the tuple will be the parent Room of the adjacent object. When the boundary condition is applied to a sub-face (Door or Aperture), the second object will be the parent Face of the adjacent sub-face and the third object will be the parent Room of the adjacent sub-face. */
    boundary_condition_objects: string[];
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class OtherSideTemperature extends _OpenAPIGenBaseModel implements IOtherSideTemperature {
    readonly type: string = "OtherSideTemperature";
    /** A value in W/m2-K to indicate the combined convective/radiative film coefficient. If equal to 0, then the specified temperature above is equal to the exterior surface temperature. Otherwise, the temperature above is considered the outside air temperature and this coefficient is used to determine the difference between this outside air temperature and the exterior surface temperature. */
    heat_transfer_coefficient?: number;
    /** A temperature value in Celsius to note the temperature on the other side of the object. This input can also be an Autocalculate object to signify that the temperature is equal to the outdoor air temperature. */
    temperature?: Temperature;

    constructor(data?: IOtherSideTemperature) {
        super(data);
        if (!data) {
            this.type = "OtherSideTemperature";
            this.heat_transfer_coefficient = 0;
        }
        this._discriminator = "OtherSideTemperature";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "OtherSideTemperature";
            this.heat_transfer_coefficient = _data["heat_transfer_coefficient"] !== undefined ? _data["heat_transfer_coefficient"] : 0;
            this.temperature = _data["temperature"];
        }
    }

    static override fromJS(data: any): OtherSideTemperature {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSideTemperature();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["heat_transfer_coefficient"] = this.heat_transfer_coefficient;
        data["temperature"] = this.temperature;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IOtherSideTemperature extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A value in W/m2-K to indicate the combined convective/radiative film coefficient. If equal to 0, then the specified temperature above is equal to the exterior surface temperature. Otherwise, the temperature above is considered the outside air temperature and this coefficient is used to determine the difference between this outside air temperature and the exterior surface temperature. */
    heat_transfer_coefficient?: number;
    /** A temperature value in Celsius to note the temperature on the other side of the object. This input can also be an Autocalculate object to signify that the temperature is equal to the outdoor air temperature. */
    temperature?: Temperature;
}

/** An enumeration. */
export enum ModuleType {
    Standard = "Standard",
    Premium = "Premium",
    ThinFilm = "ThinFilm",
}

/** An enumeration. */
export enum MountingType {
    FixedOpenRack = "FixedOpenRack",
    FixedRoofMounted = "FixedRoofMounted",
    OneAxis = "OneAxis",
    OneAxisBacktracking = "OneAxisBacktracking",
    TwoAxis = "TwoAxis",
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export class PVProperties extends EnergyBaseModel implements IPVProperties {
    readonly type: string = "PVProperties";
    /** A number between 0 and 1 for the rated nameplate efficiency of the photovoltaic solar cells under standard test conditions (STC). Standard test conditions are 1,000 Watts per square meter solar irradiance, 25 degrees C cell temperature, and ASTM G173-03 standard spectrum. Nameplate efficiencies reported by manufacturers are typically under STC. Standard poly- or mono-crystalline silicon modules tend to have rated efficiencies in the range of 14-17%. Premium high efficiency mono-crystalline silicon modules with anti-reflective coatings can have efficiencies in the range of 18-20%. Thin film photovoltaic modules typically have efficiencies of 11% or less. (Default: 0.15 for standard silicon solar cells). */
    rated_efficiency?: number;
    /** The fraction of the parent Shade geometry that is covered in active solar cells. This fraction includes the difference between the PV panel (aka. PV module) area and the active cells within the panel as well as any losses for how the (typically rectangular) panels can be arranged on the Shade geometry. When the parent Shade geometry represents just the solar panels, this fraction is typically around 0.9 given that the framing elements of the panel reduce the overall active area. (Default: 0.9, assuming parent Shade geometry represents only the PV panel geometry). */
    active_area_fraction?: number;
    /** Text to indicate the type of solar module. This is used to determine the temperature coefficients used in the simulation of the photovoltaic modules. When the rated_efficiency is between 12-18%, the Standard type is typically most appropriate. When the rated_efficiency is greater than 18%, the Premium type is likely more appropriate. When the rated_efficiency is less than 12%, this likely refers to a case where the ThinFilm module type is most appropriate. */
    module_type?: ModuleType;
    /** Text to indicate the type of mounting and/or tracking used for the photovoltaic array. Note that the OneAxis options have an axis of rotation that is determined by the azimuth of the parent Shade geometry. Also note that, in the case of one or two axis tracking, shadows on the (static) parent Shade geometry still reduce the electrical output, enabling the simulation to account for large context geometry casting shadows on the array. However, the effects of smaller detailed shading may be improperly accounted for and self shading of the dynamic panel geometry is only accounted for via the tracking_ground_coverage_ratio property on this object. FixedOpenRack refers to ground or roof mounting where the air flows freely. FixedRoofMounted refers to mounting flush with the roof with limited air flow. OneAxis refers to a fixed tilt and azimuth, which define an axis of rotation. OneAxisBacktracking is the same as OneAxis but with controls to reduce self-shade at low sun angles. TwoAxis refers to a dynamic tilt and azimuth that track the sun. */
    mounting_type?: MountingType;
    /** A number between 0 and 1 for the fraction of the electricity output lost due to factors other than EPW weather conditions, panel efficiency/type, active area, mounting, and inverter conversion from DC to AC. Factors that should be accounted for in this input include soiling, snow, wiring losses, electrical connection losses, manufacturer defects/tolerances/mismatch in cell characteristics, losses from power grid availability, and losses due to age or light-induced degradation. Losses from these factors tend to be between 10-20% but can vary widely depending on the installation, maintenance and the grid to which the panels are connected.. */
    system_loss_fraction?: number;

    constructor(data?: IPVProperties) {
        super(data);
        if (!data) {
            this.type = "PVProperties";
            this.rated_efficiency = 0.15;
            this.active_area_fraction = 0.9;
            this.module_type = ModuleType.Standard;
            this.mounting_type = MountingType.FixedOpenRack;
            this.system_loss_fraction = 0.14;
        }
        this._discriminator = "PVProperties";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "PVProperties";
            this.rated_efficiency = _data["rated_efficiency"] !== undefined ? _data["rated_efficiency"] : 0.15;
            this.active_area_fraction = _data["active_area_fraction"] !== undefined ? _data["active_area_fraction"] : 0.9;
            this.module_type = _data["module_type"] !== undefined ? _data["module_type"] : ModuleType.Standard;
            this.mounting_type = _data["mounting_type"] !== undefined ? _data["mounting_type"] : MountingType.FixedOpenRack;
            this.system_loss_fraction = _data["system_loss_fraction"] !== undefined ? _data["system_loss_fraction"] : 0.14;
        }
    }

    static override fromJS(data: any): PVProperties {
        data = typeof data === 'object' ? data : {};
        let result = new PVProperties();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["rated_efficiency"] = this.rated_efficiency;
        data["active_area_fraction"] = this.active_area_fraction;
        data["module_type"] = this.module_type;
        data["mounting_type"] = this.mounting_type;
        data["system_loss_fraction"] = this.system_loss_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export interface IPVProperties extends IEnergyBaseModel {
    type?: string;
    /** A number between 0 and 1 for the rated nameplate efficiency of the photovoltaic solar cells under standard test conditions (STC). Standard test conditions are 1,000 Watts per square meter solar irradiance, 25 degrees C cell temperature, and ASTM G173-03 standard spectrum. Nameplate efficiencies reported by manufacturers are typically under STC. Standard poly- or mono-crystalline silicon modules tend to have rated efficiencies in the range of 14-17%. Premium high efficiency mono-crystalline silicon modules with anti-reflective coatings can have efficiencies in the range of 18-20%. Thin film photovoltaic modules typically have efficiencies of 11% or less. (Default: 0.15 for standard silicon solar cells). */
    rated_efficiency?: number;
    /** The fraction of the parent Shade geometry that is covered in active solar cells. This fraction includes the difference between the PV panel (aka. PV module) area and the active cells within the panel as well as any losses for how the (typically rectangular) panels can be arranged on the Shade geometry. When the parent Shade geometry represents just the solar panels, this fraction is typically around 0.9 given that the framing elements of the panel reduce the overall active area. (Default: 0.9, assuming parent Shade geometry represents only the PV panel geometry). */
    active_area_fraction?: number;
    /** Text to indicate the type of solar module. This is used to determine the temperature coefficients used in the simulation of the photovoltaic modules. When the rated_efficiency is between 12-18%, the Standard type is typically most appropriate. When the rated_efficiency is greater than 18%, the Premium type is likely more appropriate. When the rated_efficiency is less than 12%, this likely refers to a case where the ThinFilm module type is most appropriate. */
    module_type?: ModuleType;
    /** Text to indicate the type of mounting and/or tracking used for the photovoltaic array. Note that the OneAxis options have an axis of rotation that is determined by the azimuth of the parent Shade geometry. Also note that, in the case of one or two axis tracking, shadows on the (static) parent Shade geometry still reduce the electrical output, enabling the simulation to account for large context geometry casting shadows on the array. However, the effects of smaller detailed shading may be improperly accounted for and self shading of the dynamic panel geometry is only accounted for via the tracking_ground_coverage_ratio property on this object. FixedOpenRack refers to ground or roof mounting where the air flows freely. FixedRoofMounted refers to mounting flush with the roof with limited air flow. OneAxis refers to a fixed tilt and azimuth, which define an axis of rotation. OneAxisBacktracking is the same as OneAxis but with controls to reduce self-shade at low sun angles. TwoAxis refers to a dynamic tilt and azimuth that track the sun. */
    mounting_type?: MountingType;
    /** A number between 0 and 1 for the fraction of the electricity output lost due to factors other than EPW weather conditions, panel efficiency/type, active area, mounting, and inverter conversion from DC to AC. Factors that should be accounted for in this input include soiling, snow, wiring losses, electrical connection losses, manufacturer defects/tolerances/mismatch in cell characteristics, losses from power grid availability, and losses due to age or light-induced degradation. Losses from these factors tend to be between 10-20% but can vary widely depending on the installation, maintenance and the grid to which the panels are connected.. */
    system_loss_fraction?: number;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ShadeEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IShadeEnergyPropertiesAbridged {
    readonly type: string = "ShadeEnergyPropertiesAbridged";
    /** Identifier of a ShadeConstruction to set the reflectance and specularity of the Shade. If None, the construction is set by theparent Room construction_set, the Model global_construction_set or (in the case fo an orphaned shade) the EnergyPlus default of 0.2 diffuse reflectance. */
    construction?: string;
    /** Identifier of a schedule to set the transmittance of the shade, which can vary throughout the simulation. If None, the shade will be completely opaque. */
    transmittance_schedule?: string;
    /** An optional PVProperties object to specify photovoltaic behavior of the Shade. If None, the Shade will have no Photovoltaic properties. Note that the normal of the Shade is important in determining the performance of the shade as a PV geometry. */
    pv_properties?: PVProperties;

    constructor(data?: IShadeEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ShadeEnergyPropertiesAbridged";
        }
        this._discriminator = "ShadeEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadeEnergyPropertiesAbridged";
            this.construction = _data["construction"];
            this.transmittance_schedule = _data["transmittance_schedule"];
            this.pv_properties = _data["pv_properties"] ? PVProperties.fromJS(_data["pv_properties"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ShadeEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ShadeEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction"] = this.construction;
        data["transmittance_schedule"] = this.transmittance_schedule;
        data["pv_properties"] = this.pv_properties ? this.pv_properties.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IShadeEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of a ShadeConstruction to set the reflectance and specularity of the Shade. If None, the construction is set by theparent Room construction_set, the Model global_construction_set or (in the case fo an orphaned shade) the EnergyPlus default of 0.2 diffuse reflectance. */
    construction?: string;
    /** Identifier of a schedule to set the transmittance of the shade, which can vary throughout the simulation. If None, the shade will be completely opaque. */
    transmittance_schedule?: string;
    /** An optional PVProperties object to specify photovoltaic behavior of the Shade. If None, the Shade will have no Photovoltaic properties. Note that the normal of the Shade is important in determining the performance of the shade as a PV geometry. */
    pv_properties?: PVProperties;
}

/** A single planar geometry that can be assigned to Radiance states. */
export class StateGeometryAbridged extends IDdRadianceBaseModel implements IStateGeometryAbridged {
    /** A ladybug_geometry Face3D. */
    geometry!: Face3D;
    readonly type: string = "StateGeometryAbridged";
    /** A string for a Honeybee Radiance Modifier identifier (default: None). */
    modifier?: string;
    /** A string for Honeybee Radiance Modifier identifiers to be used in direct solar simulations and in isolation studies (assessingthe contribution of individual objects) (default: None). */
    modifier_direct?: string;

    constructor(data?: IStateGeometryAbridged) {
        super(data);
        if (!data) {
            this.geometry = new Face3D();
            this.type = "StateGeometryAbridged";
        }
        this._discriminator = "StateGeometryAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.geometry = _data["geometry"] ? Face3D.fromJS(_data["geometry"]) : new Face3D();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "StateGeometryAbridged";
            this.modifier = _data["modifier"];
            this.modifier_direct = _data["modifier_direct"];
        }
    }

    static override fromJS(data: any): StateGeometryAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new StateGeometryAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["modifier"] = this.modifier;
        data["modifier_direct"] = this.modifier_direct;
        super.toJSON(data);
        return data;
    }
}

/** A single planar geometry that can be assigned to Radiance states. */
export interface IStateGeometryAbridged extends IIDdRadianceBaseModel {
    /** A ladybug_geometry Face3D. */
    geometry: Face3D;
    type?: string;
    /** A string for a Honeybee Radiance Modifier identifier (default: None). */
    modifier?: string;
    /** A string for Honeybee Radiance Modifier identifiers to be used in direct solar simulations and in isolation studies (assessingthe contribution of individual objects) (default: None). */
    modifier_direct?: string;
}

/** RadianceShadeStateAbridged represents a single state for a dynamic Shade. */
export class RadianceShadeStateAbridged extends _OpenAPIGenBaseModel implements IRadianceShadeStateAbridged {
    readonly type: string = "RadianceShadeStateAbridged";
    /** A Radiance Modifier identifier (default: None). */
    modifier?: string;
    /** A Radiance Modifier identifier (default: None). */
    modifier_direct?: string;
    /** A list of StateGeometryAbridged objects (default: None). */
    shades?: StateGeometryAbridged[];

    constructor(data?: IRadianceShadeStateAbridged) {
        super(data);
        if (!data) {
            this.type = "RadianceShadeStateAbridged";
        }
        this._discriminator = "RadianceShadeStateAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RadianceShadeStateAbridged";
            this.modifier = _data["modifier"];
            this.modifier_direct = _data["modifier_direct"];
            if (Array.isArray(_data["shades"])) {
                this.shades = [] as any;
                for (let item of _data["shades"])
                    this.shades!.push(StateGeometryAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): RadianceShadeStateAbridged {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "RadianceSubFaceStateAbridged") {
            let result = new RadianceSubFaceStateAbridged();
            result.init(data);
            return result;
        }
        let result = new RadianceShadeStateAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier"] = this.modifier;
        data["modifier_direct"] = this.modifier_direct;
        if (Array.isArray(this.shades)) {
            data["shades"] = [];
            for (let item of this.shades)
                data["shades"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** RadianceShadeStateAbridged represents a single state for a dynamic Shade. */
export interface IRadianceShadeStateAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A Radiance Modifier identifier (default: None). */
    modifier?: string;
    /** A Radiance Modifier identifier (default: None). */
    modifier_direct?: string;
    /** A list of StateGeometryAbridged objects (default: None). */
    shades?: StateGeometryAbridged[];
}

/** Base class of Abridged Radiance Properties. */
export class _PropertiesBaseAbridged extends _OpenAPIGenBaseModel implements I_PropertiesBaseAbridged {
    /** A string for a Honeybee Radiance Modifier (default: None). */
    modifier?: string;
    /** A string for a Honeybee Radiance Modifier to be used in direct solar simulations and in isolation studies (assessingthe contribution of individual objects) (default: None). */
    modifier_blk?: string;
    readonly type: string = "_PropertiesBaseAbridged";

    constructor(data?: I_PropertiesBaseAbridged) {
        super(data);
        if (!data) {
            this.type = "_PropertiesBaseAbridged";
        }
        this._discriminator = "_PropertiesBaseAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifier = _data["modifier"];
            this.modifier_blk = _data["modifier_blk"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_PropertiesBaseAbridged";
        }
    }

    static override fromJS(data: any): _PropertiesBaseAbridged {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ShadeRadiancePropertiesAbridged") {
            let result = new ShadeRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ApertureRadiancePropertiesAbridged") {
            let result = new ApertureRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorRadiancePropertiesAbridged") {
            let result = new DoorRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FaceRadiancePropertiesAbridged") {
            let result = new FaceRadiancePropertiesAbridged();
            result.init(data);
            return result;
        }
        let result = new _PropertiesBaseAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifier"] = this.modifier;
        data["modifier_blk"] = this.modifier_blk;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class of Abridged Radiance Properties. */
export interface I_PropertiesBaseAbridged extends I_OpenAPIGenBaseModel {
    /** A string for a Honeybee Radiance Modifier (default: None). */
    modifier?: string;
    /** A string for a Honeybee Radiance Modifier to be used in direct solar simulations and in isolation studies (assessingthe contribution of individual objects) (default: None). */
    modifier_blk?: string;
    type?: string;
}

/** Radiance Properties for Honeybee Shade Abridged. */
export class ShadeRadiancePropertiesAbridged extends _PropertiesBaseAbridged implements IShadeRadiancePropertiesAbridged {
    readonly type: string = "ShadeRadiancePropertiesAbridged";
    /** An optional string to note the dynamic group '             'to which the Shade is a part of. Shades sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Shade is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceShadeStateAbridged[];

    constructor(data?: IShadeRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ShadeRadiancePropertiesAbridged";
        }
        this._discriminator = "ShadeRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadeRadiancePropertiesAbridged";
            this.dynamic_group_identifier = _data["dynamic_group_identifier"];
            if (Array.isArray(_data["states"])) {
                this.states = [] as any;
                for (let item of _data["states"])
                    this.states!.push(RadianceShadeStateAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ShadeRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ShadeRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["dynamic_group_identifier"] = this.dynamic_group_identifier;
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Radiance Properties for Honeybee Shade Abridged. */
export interface IShadeRadiancePropertiesAbridged extends I_PropertiesBaseAbridged {
    type?: string;
    /** An optional string to note the dynamic group '             'to which the Shade is a part of. Shades sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Shade is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceShadeStateAbridged[];
}

export class ShadePropertiesAbridged extends _OpenAPIGenBaseModel implements IShadePropertiesAbridged {
    readonly type: string = "ShadePropertiesAbridged";
    energy?: ShadeEnergyPropertiesAbridged;
    radiance?: ShadeRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IShadePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ShadePropertiesAbridged";
        }
        this._discriminator = "ShadePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadePropertiesAbridged";
            this.energy = _data["energy"] ? ShadeEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? ShadeRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ShadePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ShadePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IShadePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: ShadeEnergyPropertiesAbridged;
    radiance?: ShadeRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class IDdBaseModel extends _OpenAPIGenBaseModel implements IIDdBaseModel {
    /** Text string for a unique object ID. This identifier remains constant as the object is mutated, copied, and serialized to different formats (eg. dict, idf, rad). This identifier is also used to reference the object across a Model. It must be < 100 characters and not contain any spaces or special characters. */
    identifier!: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). */
    user_data?: any;
    readonly type: string = "IDdBaseModel";

    constructor(data?: IIDdBaseModel) {
        super(data);
        if (!data) {
            this.type = "IDdBaseModel";
        }
        this._discriminator = "IDdBaseModel";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.identifier = _data["identifier"];
            this.display_name = _data["display_name"];
            this.user_data = _data["user_data"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "IDdBaseModel";
        }
    }

    static override fromJS(data: any): IDdBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Shade") {
            let result = new Shade();
            result.init(data);
            return result;
        }
        if (data["type"] === "Aperture") {
            let result = new Aperture();
            result.init(data);
            return result;
        }
        if (data["type"] === "Door") {
            let result = new Door();
            result.init(data);
            return result;
        }
        if (data["type"] === "Face") {
            let result = new Face();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room") {
            let result = new Room();
            result.init(data);
            return result;
        }
        if (data["type"] === "Room2D") {
            let result = new Room2D();
            result.init(data);
            return result;
        }
        if (data["type"] === "Story") {
            let result = new Story();
            result.init(data);
            return result;
        }
        if (data["type"] === "Building") {
            let result = new Building();
            result.init(data);
            return result;
        }
        if (data["type"] === "ContextShade") {
            let result = new ContextShade();
            result.init(data);
            return result;
        }
        if (data["type"] === "Model") {
            let result = new Model();
            result.init(data);
            return result;
        }
        let result = new IDdBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["display_name"] = this.display_name;
        data["user_data"] = this.user_data;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IIDdBaseModel extends I_OpenAPIGenBaseModel {
    /** Text string for a unique object ID. This identifier remains constant as the object is mutated, copied, and serialized to different formats (eg. dict, idf, rad). This identifier is also used to reference the object across a Model. It must be < 100 characters and not contain any spaces or special characters. */
    identifier: string;
    /** Display name of the object with no character restrictions. */
    display_name?: string;
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). */
    user_data?: any;
    type?: string;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Shade extends IDdBaseModel implements IShade {
    /** Planar Face3D for the geometry. */
    geometry!: Face3D;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: ShadePropertiesAbridged;
    readonly type: string = "Shade";
    /** Boolean to note whether this shade is detached from any of the other geometry in the model. Cases where this should be True include shade representing surrounding buildings or context. Note that this should always be False for shades assigned to parent objects. */
    is_detached?: boolean;

    constructor(data?: IShade) {
        super(data);
        if (!data) {
            this.geometry = new Face3D();
            this.properties = new ShadePropertiesAbridged();
            this.type = "Shade";
            this.is_detached = false;
        }
        this._discriminator = "Shade";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.geometry = _data["geometry"] ? Face3D.fromJS(_data["geometry"]) : new Face3D();
            this.properties = _data["properties"] ? ShadePropertiesAbridged.fromJS(_data["properties"]) : new ShadePropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Shade";
            this.is_detached = _data["is_detached"] !== undefined ? _data["is_detached"] : false;
        }
    }

    static override fromJS(data: any): Shade {
        data = typeof data === 'object' ? data : {};
        let result = new Shade();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["is_detached"] = this.is_detached;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IShade extends IIDdBaseModel {
    /** Planar Face3D for the geometry. */
    geometry: Face3D;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: ShadePropertiesAbridged;
    type?: string;
    /** Boolean to note whether this shade is detached from any of the other geometry in the model. Cases where this should be True include shade representing surrounding buildings or context. Note that this should always be False for shades assigned to parent objects. */
    is_detached?: boolean;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class VentilationOpening extends _OpenAPIGenBaseModel implements IVentilationOpening {
    readonly type: string = "VentilationOpening";
    /** A number for the fraction of the window area that is operable. */
    fraction_area_operable?: number;
    /** A number for the fraction of the distance from the bottom of the window to the top that is operable */
    fraction_height_operable?: number;
    /** A number that will be multiplied by the area of the window in the stack (buoyancy-driven) part of the equation to account for additional friction from window geometry, insect screens, etc. Typical values include 0.45, for unobstructed windows WITH insect screens and 0.65 for unobstructed windows WITHOUT insect screens. This value should be lowered if windows are of an awning or casement type and are not allowed to fully open. */
    discharge_coefficient?: number;
    /** Boolean to indicate if there is an opening of roughly equal area on the opposite side of the Room such that wind-driven cross ventilation will be induced. If False, the assumption is that the operable area is primarily on one side of the Room and there is no wind-driven ventilation. */
    wind_cross_vent?: boolean;
    /** An optional number in kg/s-m, at 1 Pa per meter of crack length, used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage closed external window to be 0.00001, and the flow coefficient for a very poor, high-leakage closed external window to be 0.003. */
    flow_coefficient_closed?: number;
    /** An optional dimensionless number between 0.5 and 1 used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured. */
    flow_exponent_closed?: number;
    /** A number in kg/m3 indicating the minimum density difference above which two-way flow may occur due to stack effect, required to run an AirflowNetwork simulation. This value is required because the air density difference between two zones (which drives two-way air flow) will tend towards division by zero errors as the air density difference approaches zero. The default of 0.0001 is a typical default value used for AirflowNetwork openings. */
    two_way_threshold?: number;

    constructor(data?: IVentilationOpening) {
        super(data);
        if (!data) {
            this.type = "VentilationOpening";
            this.fraction_area_operable = 0.5;
            this.fraction_height_operable = 1;
            this.discharge_coefficient = 0.45;
            this.wind_cross_vent = false;
            this.flow_coefficient_closed = 0;
            this.flow_exponent_closed = 0.65;
            this.two_way_threshold = 0.0001;
        }
        this._discriminator = "VentilationOpening";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VentilationOpening";
            this.fraction_area_operable = _data["fraction_area_operable"] !== undefined ? _data["fraction_area_operable"] : 0.5;
            this.fraction_height_operable = _data["fraction_height_operable"] !== undefined ? _data["fraction_height_operable"] : 1;
            this.discharge_coefficient = _data["discharge_coefficient"] !== undefined ? _data["discharge_coefficient"] : 0.45;
            this.wind_cross_vent = _data["wind_cross_vent"] !== undefined ? _data["wind_cross_vent"] : false;
            this.flow_coefficient_closed = _data["flow_coefficient_closed"] !== undefined ? _data["flow_coefficient_closed"] : 0;
            this.flow_exponent_closed = _data["flow_exponent_closed"] !== undefined ? _data["flow_exponent_closed"] : 0.65;
            this.two_way_threshold = _data["two_way_threshold"] !== undefined ? _data["two_way_threshold"] : 0.0001;
        }
    }

    static override fromJS(data: any): VentilationOpening {
        data = typeof data === 'object' ? data : {};
        let result = new VentilationOpening();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fraction_area_operable"] = this.fraction_area_operable;
        data["fraction_height_operable"] = this.fraction_height_operable;
        data["discharge_coefficient"] = this.discharge_coefficient;
        data["wind_cross_vent"] = this.wind_cross_vent;
        data["flow_coefficient_closed"] = this.flow_coefficient_closed;
        data["flow_exponent_closed"] = this.flow_exponent_closed;
        data["two_way_threshold"] = this.two_way_threshold;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IVentilationOpening extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A number for the fraction of the window area that is operable. */
    fraction_area_operable?: number;
    /** A number for the fraction of the distance from the bottom of the window to the top that is operable */
    fraction_height_operable?: number;
    /** A number that will be multiplied by the area of the window in the stack (buoyancy-driven) part of the equation to account for additional friction from window geometry, insect screens, etc. Typical values include 0.45, for unobstructed windows WITH insect screens and 0.65 for unobstructed windows WITHOUT insect screens. This value should be lowered if windows are of an awning or casement type and are not allowed to fully open. */
    discharge_coefficient?: number;
    /** Boolean to indicate if there is an opening of roughly equal area on the opposite side of the Room such that wind-driven cross ventilation will be induced. If False, the assumption is that the operable area is primarily on one side of the Room and there is no wind-driven ventilation. */
    wind_cross_vent?: boolean;
    /** An optional number in kg/s-m, at 1 Pa per meter of crack length, used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage closed external window to be 0.00001, and the flow coefficient for a very poor, high-leakage closed external window to be 0.003. */
    flow_coefficient_closed?: number;
    /** An optional dimensionless number between 0.5 and 1 used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured. */
    flow_exponent_closed?: number;
    /** A number in kg/m3 indicating the minimum density difference above which two-way flow may occur due to stack effect, required to run an AirflowNetwork simulation. This value is required because the air density difference between two zones (which drives two-way air flow) will tend towards division by zero errors as the air density difference approaches zero. The default of 0.0001 is a typical default value used for AirflowNetwork openings. */
    two_way_threshold?: number;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ApertureEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IApertureEnergyPropertiesAbridged {
    readonly type: string = "ApertureEnergyPropertiesAbridged";
    /** Identifier of a WindowConstruction for the aperture. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional VentilationOpening to specify the operable portion of the Aperture. */
    vent_opening?: VentilationOpening;

    constructor(data?: IApertureEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ApertureEnergyPropertiesAbridged";
        }
        this._discriminator = "ApertureEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureEnergyPropertiesAbridged";
            this.construction = _data["construction"];
            this.vent_opening = _data["vent_opening"] ? VentilationOpening.fromJS(_data["vent_opening"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ApertureEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction"] = this.construction;
        data["vent_opening"] = this.vent_opening ? this.vent_opening.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IApertureEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of a WindowConstruction for the aperture. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional VentilationOpening to specify the operable portion of the Aperture. */
    vent_opening?: VentilationOpening;
}

/** RadianceSubFaceStateAbridged is an abridged state for a dynamic Aperture or Door. */
export class RadianceSubFaceStateAbridged extends RadianceShadeStateAbridged implements IRadianceSubFaceStateAbridged {
    /** A Face3D for the view matrix geometry (default: None). */
    vmtx_geometry?: Face3D;
    /** A Face3D for the daylight matrix geometry (default: None). */
    dmtx_geometry?: Face3D;
    readonly type: string = "RadianceSubFaceStateAbridged";

    constructor(data?: IRadianceSubFaceStateAbridged) {
        super(data);
        if (!data) {
            this.type = "RadianceSubFaceStateAbridged";
        }
        this._discriminator = "RadianceSubFaceStateAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vmtx_geometry = _data["vmtx_geometry"] ? Face3D.fromJS(_data["vmtx_geometry"]) : <any>undefined;
            this.dmtx_geometry = _data["dmtx_geometry"] ? Face3D.fromJS(_data["dmtx_geometry"]) : <any>undefined;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RadianceSubFaceStateAbridged";
        }
    }

    static override fromJS(data: any): RadianceSubFaceStateAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RadianceSubFaceStateAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vmtx_geometry"] = this.vmtx_geometry ? this.vmtx_geometry.toJSON() : <any>undefined;
        data["dmtx_geometry"] = this.dmtx_geometry ? this.dmtx_geometry.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** RadianceSubFaceStateAbridged is an abridged state for a dynamic Aperture or Door. */
export interface IRadianceSubFaceStateAbridged extends IRadianceShadeStateAbridged {
    /** A Face3D for the view matrix geometry (default: None). */
    vmtx_geometry?: Face3D;
    /** A Face3D for the daylight matrix geometry (default: None). */
    dmtx_geometry?: Face3D;
    type?: string;
}

/** Radiance Properties for Honeybee Aperture Abridged. */
export class ApertureRadiancePropertiesAbridged extends _PropertiesBaseAbridged implements IApertureRadiancePropertiesAbridged {
    readonly type: string = "ApertureRadiancePropertiesAbridged";
    /** An optional string to note the dynamic group '             'to which the Aperture is a part of. Apertures sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Aperture is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceSubFaceStateAbridged[];

    constructor(data?: IApertureRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ApertureRadiancePropertiesAbridged";
        }
        this._discriminator = "ApertureRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureRadiancePropertiesAbridged";
            this.dynamic_group_identifier = _data["dynamic_group_identifier"];
            if (Array.isArray(_data["states"])) {
                this.states = [] as any;
                for (let item of _data["states"])
                    this.states!.push(RadianceSubFaceStateAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ApertureRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["dynamic_group_identifier"] = this.dynamic_group_identifier;
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Radiance Properties for Honeybee Aperture Abridged. */
export interface IApertureRadiancePropertiesAbridged extends I_PropertiesBaseAbridged {
    type?: string;
    /** An optional string to note the dynamic group '             'to which the Aperture is a part of. Apertures sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Aperture is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceSubFaceStateAbridged[];
}

export class AperturePropertiesAbridged extends _OpenAPIGenBaseModel implements IAperturePropertiesAbridged {
    readonly type: string = "AperturePropertiesAbridged";
    energy?: ApertureEnergyPropertiesAbridged;
    radiance?: ApertureRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IAperturePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "AperturePropertiesAbridged";
        }
        this._discriminator = "AperturePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "AperturePropertiesAbridged";
            this.energy = _data["energy"] ? ApertureEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? ApertureRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AperturePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new AperturePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAperturePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: ApertureEnergyPropertiesAbridged;
    radiance?: ApertureRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Aperture extends IDdBaseModel implements IAperture {
    /** Planar Face3D for the geometry. */
    geometry!: Face3D;
    boundary_condition!: Boundary_condition;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: AperturePropertiesAbridged;
    readonly type: string = "Aperture";
    /** Boolean to note whether the Aperture can be opened for ventilation. */
    is_operable?: boolean;
    /** Shades assigned to the interior side of this object (eg. window sill, light shelf). */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. mullions, louvers). */
    outdoor_shades?: Shade[];

    constructor(data?: IAperture) {
        super(data);
        if (!data) {
            this.geometry = new Face3D();
            this.properties = new AperturePropertiesAbridged();
            this.type = "Aperture";
            this.is_operable = false;
        }
        this._discriminator = "Aperture";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.geometry = _data["geometry"] ? Face3D.fromJS(_data["geometry"]) : new Face3D();
            this.boundary_condition = _data["boundary_condition"];
            this.properties = _data["properties"] ? AperturePropertiesAbridged.fromJS(_data["properties"]) : new AperturePropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Aperture";
            this.is_operable = _data["is_operable"] !== undefined ? _data["is_operable"] : false;
            if (Array.isArray(_data["indoor_shades"])) {
                this.indoor_shades = [] as any;
                for (let item of _data["indoor_shades"])
                    this.indoor_shades!.push(Shade.fromJS(item));
            }
            if (Array.isArray(_data["outdoor_shades"])) {
                this.outdoor_shades = [] as any;
                for (let item of _data["outdoor_shades"])
                    this.outdoor_shades!.push(Shade.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Aperture {
        data = typeof data === 'object' ? data : {};
        let result = new Aperture();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["boundary_condition"] = this.boundary_condition;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["is_operable"] = this.is_operable;
        if (Array.isArray(this.indoor_shades)) {
            data["indoor_shades"] = [];
            for (let item of this.indoor_shades)
                data["indoor_shades"].push(item.toJSON());
        }
        if (Array.isArray(this.outdoor_shades)) {
            data["outdoor_shades"] = [];
            for (let item of this.outdoor_shades)
                data["outdoor_shades"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IAperture extends IIDdBaseModel {
    /** Planar Face3D for the geometry. */
    geometry: Face3D;
    boundary_condition: Boundary_condition;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: AperturePropertiesAbridged;
    type?: string;
    /** Boolean to note whether the Aperture can be opened for ventilation. */
    is_operable?: boolean;
    /** Shades assigned to the interior side of this object (eg. window sill, light shelf). */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. mullions, louvers). */
    outdoor_shades?: Shade[];
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class DoorEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IDoorEnergyPropertiesAbridged {
    readonly type: string = "DoorEnergyPropertiesAbridged";
    /** Identifier of an OpaqueConstruction or WindowConstruction for the door. Note that the host door must have the is_glass property set to True to assign a WindowConstruction. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional VentilationOpening to specify the operable portion of the Door. */
    vent_opening?: VentilationOpening;

    constructor(data?: IDoorEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "DoorEnergyPropertiesAbridged";
        }
        this._discriminator = "DoorEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorEnergyPropertiesAbridged";
            this.construction = _data["construction"];
            this.vent_opening = _data["vent_opening"] ? VentilationOpening.fromJS(_data["vent_opening"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DoorEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new DoorEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction"] = this.construction;
        data["vent_opening"] = this.vent_opening ? this.vent_opening.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IDoorEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of an OpaqueConstruction or WindowConstruction for the door. Note that the host door must have the is_glass property set to True to assign a WindowConstruction. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional VentilationOpening to specify the operable portion of the Door. */
    vent_opening?: VentilationOpening;
}

/** Radiance Properties for Honeybee Door Abridged. */
export class DoorRadiancePropertiesAbridged extends _PropertiesBaseAbridged implements IDoorRadiancePropertiesAbridged {
    readonly type: string = "DoorRadiancePropertiesAbridged";
    /** An optional string to note the dynamic group '             'to which the Door is a part of. Doors sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Door is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceSubFaceStateAbridged[];

    constructor(data?: IDoorRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "DoorRadiancePropertiesAbridged";
        }
        this._discriminator = "DoorRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorRadiancePropertiesAbridged";
            this.dynamic_group_identifier = _data["dynamic_group_identifier"];
            if (Array.isArray(_data["states"])) {
                this.states = [] as any;
                for (let item of _data["states"])
                    this.states!.push(RadianceSubFaceStateAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DoorRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new DoorRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["dynamic_group_identifier"] = this.dynamic_group_identifier;
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Radiance Properties for Honeybee Door Abridged. */
export interface IDoorRadiancePropertiesAbridged extends I_PropertiesBaseAbridged {
    type?: string;
    /** An optional string to note the dynamic group '             'to which the Door is a part of. Doors sharing the same '             'dynamic_group_identifier will have their states change in unison. '             'If None, the Door is assumed to be static. (default: None). */
    dynamic_group_identifier?: string;
    /** An optional list of abridged states (default: None). */
    states?: RadianceSubFaceStateAbridged[];
}

export class DoorPropertiesAbridged extends _OpenAPIGenBaseModel implements IDoorPropertiesAbridged {
    readonly type: string = "DoorPropertiesAbridged";
    energy?: DoorEnergyPropertiesAbridged;
    radiance?: DoorRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IDoorPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "DoorPropertiesAbridged";
        }
        this._discriminator = "DoorPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorPropertiesAbridged";
            this.energy = _data["energy"] ? DoorEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? DoorRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DoorPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new DoorPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDoorPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: DoorEnergyPropertiesAbridged;
    radiance?: DoorRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Door extends IDdBaseModel implements IDoor {
    /** Planar Face3D for the geometry. */
    geometry!: Face3D;
    boundary_condition!: boundary_condition;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: DoorPropertiesAbridged;
    readonly type: string = "Door";
    /** Boolean to note whether this object is a glass door as opposed to an opaque door. */
    is_glass?: boolean;
    /** Shades assigned to the interior side of this object. */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. entryway awning). */
    outdoor_shades?: Shade[];

    constructor(data?: IDoor) {
        super(data);
        if (!data) {
            this.geometry = new Face3D();
            this.properties = new DoorPropertiesAbridged();
            this.type = "Door";
            this.is_glass = false;
        }
        this._discriminator = "Door";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.geometry = _data["geometry"] ? Face3D.fromJS(_data["geometry"]) : new Face3D();
            this.boundary_condition = _data["boundary_condition"];
            this.properties = _data["properties"] ? DoorPropertiesAbridged.fromJS(_data["properties"]) : new DoorPropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Door";
            this.is_glass = _data["is_glass"] !== undefined ? _data["is_glass"] : false;
            if (Array.isArray(_data["indoor_shades"])) {
                this.indoor_shades = [] as any;
                for (let item of _data["indoor_shades"])
                    this.indoor_shades!.push(Shade.fromJS(item));
            }
            if (Array.isArray(_data["outdoor_shades"])) {
                this.outdoor_shades = [] as any;
                for (let item of _data["outdoor_shades"])
                    this.outdoor_shades!.push(Shade.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Door {
        data = typeof data === 'object' ? data : {};
        let result = new Door();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["boundary_condition"] = this.boundary_condition;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["is_glass"] = this.is_glass;
        if (Array.isArray(this.indoor_shades)) {
            data["indoor_shades"] = [];
            for (let item of this.indoor_shades)
                data["indoor_shades"].push(item.toJSON());
        }
        if (Array.isArray(this.outdoor_shades)) {
            data["outdoor_shades"] = [];
            for (let item of this.outdoor_shades)
                data["outdoor_shades"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IDoor extends IIDdBaseModel {
    /** Planar Face3D for the geometry. */
    geometry: Face3D;
    boundary_condition: boundary_condition;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: DoorPropertiesAbridged;
    type?: string;
    /** Boolean to note whether this object is a glass door as opposed to an opaque door. */
    is_glass?: boolean;
    /** Shades assigned to the interior side of this object. */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. entryway awning). */
    outdoor_shades?: Shade[];
}

/** Properties for airflow through a crack. */
export class AFNCrack extends _OpenAPIGenBaseModel implements IAFNCrack {
    /** A number in kg/s-m at 1 Pa per meter of crack length at the conditions defined in the ReferenceCrack condition; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage wall to be 0.00001 and 0.001 for external and internal constructions, respectively. Flow coefficients for a very poor, high-leakage wall are defined to be 0.0004 and 0.019 for external and internal constructions, respectively. */
    flow_coefficient!: number;
    readonly type: string = "AFNCrack";
    /** An optional dimensionless number between 0.5 and 1 used to calculate the crack mass flow rate; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured. */
    flow_exponent?: number;

    constructor(data?: IAFNCrack) {
        super(data);
        if (!data) {
            this.type = "AFNCrack";
            this.flow_exponent = 0.65;
        }
        this._discriminator = "AFNCrack";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_coefficient = _data["flow_coefficient"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "AFNCrack";
            this.flow_exponent = _data["flow_exponent"] !== undefined ? _data["flow_exponent"] : 0.65;
        }
    }

    static override fromJS(data: any): AFNCrack {
        data = typeof data === 'object' ? data : {};
        let result = new AFNCrack();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_coefficient"] = this.flow_coefficient;
        data["type"] = this.type;
        data["flow_exponent"] = this.flow_exponent;
        super.toJSON(data);
        return data;
    }
}

/** Properties for airflow through a crack. */
export interface IAFNCrack extends I_OpenAPIGenBaseModel {
    /** A number in kg/s-m at 1 Pa per meter of crack length at the conditions defined in the ReferenceCrack condition; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage wall to be 0.00001 and 0.001 for external and internal constructions, respectively. Flow coefficients for a very poor, high-leakage wall are defined to be 0.0004 and 0.019 for external and internal constructions, respectively. */
    flow_coefficient: number;
    type?: string;
    /** An optional dimensionless number between 0.5 and 1 used to calculate the crack mass flow rate; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured. */
    flow_exponent?: number;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class FaceEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IFaceEnergyPropertiesAbridged {
    readonly type: string = "FaceEnergyPropertiesAbridged";
    /** Identifier of an OpaqueConstruction for the Face. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional AFNCrack to specify airflow through a surface crack used by the AirflowNetwork. */
    vent_crack?: AFNCrack;

    constructor(data?: IFaceEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "FaceEnergyPropertiesAbridged";
        }
        this._discriminator = "FaceEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FaceEnergyPropertiesAbridged";
            this.construction = _data["construction"];
            this.vent_crack = _data["vent_crack"] ? AFNCrack.fromJS(_data["vent_crack"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FaceEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FaceEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction"] = this.construction;
        data["vent_crack"] = this.vent_crack ? this.vent_crack.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IFaceEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of an OpaqueConstruction for the Face. If None, the construction is set by the parent Room construction_set or the Model global_construction_set. */
    construction?: string;
    /** An optional AFNCrack to specify airflow through a surface crack used by the AirflowNetwork. */
    vent_crack?: AFNCrack;
}

/** Radiance Properties for Honeybee Face Abridged. */
export class FaceRadiancePropertiesAbridged extends _PropertiesBaseAbridged implements IFaceRadiancePropertiesAbridged {
    readonly type: string = "FaceRadiancePropertiesAbridged";

    constructor(data?: IFaceRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "FaceRadiancePropertiesAbridged";
        }
        this._discriminator = "FaceRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FaceRadiancePropertiesAbridged";
        }
    }

    static override fromJS(data: any): FaceRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FaceRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Radiance Properties for Honeybee Face Abridged. */
export interface IFaceRadiancePropertiesAbridged extends I_PropertiesBaseAbridged {
    type?: string;
}

export class FacePropertiesAbridged extends _OpenAPIGenBaseModel implements IFacePropertiesAbridged {
    readonly type: string = "FacePropertiesAbridged";
    energy?: FaceEnergyPropertiesAbridged;
    radiance?: FaceRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IFacePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "FacePropertiesAbridged";
        }
        this._discriminator = "FacePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FacePropertiesAbridged";
            this.energy = _data["energy"] ? FaceEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? FaceRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FacePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FacePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFacePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: FaceEnergyPropertiesAbridged;
    radiance?: FaceRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Face extends IDdBaseModel implements IFace {
    /** Planar Face3D for the geometry. */
    geometry!: Face3D;
    face_type!: FaceType;
    boundary_condition!: boundary_condition2;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: FacePropertiesAbridged;
    readonly type: string = "Face";
    /** Apertures assigned to this Face. Should be coplanar with this Face and completely within the boundary of the Face to be valid. */
    apertures?: Aperture[];
    /** Doors assigned to this Face. Should be coplanar with this Face and completely within the boundary of the Face to be valid. */
    doors?: Door[];
    /** Shades assigned to the interior side of this object. */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. balcony, overhang). */
    outdoor_shades?: Shade[];

    constructor(data?: IFace) {
        super(data);
        if (!data) {
            this.geometry = new Face3D();
            this.properties = new FacePropertiesAbridged();
            this.type = "Face";
        }
        this._discriminator = "Face";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.geometry = _data["geometry"] ? Face3D.fromJS(_data["geometry"]) : new Face3D();
            this.face_type = _data["face_type"];
            this.boundary_condition = _data["boundary_condition"];
            this.properties = _data["properties"] ? FacePropertiesAbridged.fromJS(_data["properties"]) : new FacePropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Face";
            if (Array.isArray(_data["apertures"])) {
                this.apertures = [] as any;
                for (let item of _data["apertures"])
                    this.apertures!.push(Aperture.fromJS(item));
            }
            if (Array.isArray(_data["doors"])) {
                this.doors = [] as any;
                for (let item of _data["doors"])
                    this.doors!.push(Door.fromJS(item));
            }
            if (Array.isArray(_data["indoor_shades"])) {
                this.indoor_shades = [] as any;
                for (let item of _data["indoor_shades"])
                    this.indoor_shades!.push(Shade.fromJS(item));
            }
            if (Array.isArray(_data["outdoor_shades"])) {
                this.outdoor_shades = [] as any;
                for (let item of _data["outdoor_shades"])
                    this.outdoor_shades!.push(Shade.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Face {
        data = typeof data === 'object' ? data : {};
        let result = new Face();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["face_type"] = this.face_type;
        data["boundary_condition"] = this.boundary_condition;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.apertures)) {
            data["apertures"] = [];
            for (let item of this.apertures)
                data["apertures"].push(item.toJSON());
        }
        if (Array.isArray(this.doors)) {
            data["doors"] = [];
            for (let item of this.doors)
                data["doors"].push(item.toJSON());
        }
        if (Array.isArray(this.indoor_shades)) {
            data["indoor_shades"] = [];
            for (let item of this.indoor_shades)
                data["indoor_shades"].push(item.toJSON());
        }
        if (Array.isArray(this.outdoor_shades)) {
            data["outdoor_shades"] = [];
            for (let item of this.outdoor_shades)
                data["outdoor_shades"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IFace extends IIDdBaseModel {
    /** Planar Face3D for the geometry. */
    geometry: Face3D;
    face_type: FaceType;
    boundary_condition: boundary_condition2;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: FacePropertiesAbridged;
    type?: string;
    /** Apertures assigned to this Face. Should be coplanar with this Face and completely within the boundary of the Face to be valid. */
    apertures?: Aperture[];
    /** Doors assigned to this Face. Should be coplanar with this Face and completely within the boundary of the Face to be valid. */
    doors?: Door[];
    /** Shades assigned to the interior side of this object. */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. balcony, overhang). */
    outdoor_shades?: Shade[];
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class PeopleAbridged extends IDdEnergyBaseModel implements IPeopleAbridged {
    /** People per floor area expressed as [people/m2] */
    people_per_area!: number;
    /** Identifier of a schedule for the occupancy over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the people_per_area to yield a complete occupancy profile. */
    occupancy_schedule!: string;
    readonly type: string = "PeopleAbridged";
    /** Identifier of a schedule for the activity of the occupants over the course of the year. The type of this schedule should be ActivityLevel and the values of the schedule equal to the number of Watts given off by an individual person in the room. If None, a default constant schedule with 120 Watts per person will be used, which is typical of awake, adult humans who are seated. */
    activity_schedule?: string;
    /** The radiant fraction of sensible heat released by people. (Default: 0.3). */
    radiant_fraction?: number;
    /** Number for the latent fraction of heat gain due to people or an Autocalculate object. */
    latent_fraction?: Latent_fraction;

    constructor(data?: IPeopleAbridged) {
        super(data);
        if (!data) {
            this.type = "PeopleAbridged";
            this.radiant_fraction = 0.3;
        }
        this._discriminator = "PeopleAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.people_per_area = _data["people_per_area"];
            this.occupancy_schedule = _data["occupancy_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "PeopleAbridged";
            this.activity_schedule = _data["activity_schedule"];
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0.3;
            this.latent_fraction = _data["latent_fraction"];
        }
    }

    static override fromJS(data: any): PeopleAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new PeopleAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["people_per_area"] = this.people_per_area;
        data["occupancy_schedule"] = this.occupancy_schedule;
        data["type"] = this.type;
        data["activity_schedule"] = this.activity_schedule;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IPeopleAbridged extends IIDdEnergyBaseModel {
    /** People per floor area expressed as [people/m2] */
    people_per_area: number;
    /** Identifier of a schedule for the occupancy over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the people_per_area to yield a complete occupancy profile. */
    occupancy_schedule: string;
    type?: string;
    /** Identifier of a schedule for the activity of the occupants over the course of the year. The type of this schedule should be ActivityLevel and the values of the schedule equal to the number of Watts given off by an individual person in the room. If None, a default constant schedule with 120 Watts per person will be used, which is typical of awake, adult humans who are seated. */
    activity_schedule?: string;
    /** The radiant fraction of sensible heat released by people. (Default: 0.3). */
    radiant_fraction?: number;
    /** Number for the latent fraction of heat gain due to people or an Autocalculate object. */
    latent_fraction?: Latent_fraction;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class LightingAbridged extends IDdEnergyBaseModel implements ILightingAbridged {
    /** Lighting per floor area as [W/m2]. */
    watts_per_area!: number;
    /** Identifier of the schedule for the use of lights over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete lighting profile. */
    schedule!: string;
    readonly type: string = "LightingAbridged";
    /** The fraction of heat from lights that goes into the zone as visible (short-wave) radiation. (Default: 0.25). */
    visible_fraction?: number;
    /** The fraction of heat from lights that is long-wave radiation. (Default: 0.32). */
    radiant_fraction?: number;
    /** The fraction of the heat from lights that goes into the zone return air. (Default: 0). */
    return_air_fraction?: number;
    /** The baseline lighting power density in [W/m2] of floor area. This baseline is useful to track how much better the installed lights are in comparison to a standard like ASHRAE 90.1. If set to None, it will default to 11.84029 W/m2, which is that ASHRAE 90.1-2004 baseline for an office. */
    baseline_watts_per_area?: number;

    constructor(data?: ILightingAbridged) {
        super(data);
        if (!data) {
            this.type = "LightingAbridged";
            this.visible_fraction = 0.25;
            this.radiant_fraction = 0.32;
            this.return_air_fraction = 0;
            this.baseline_watts_per_area = 11.84029;
        }
        this._discriminator = "LightingAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts_per_area = _data["watts_per_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "LightingAbridged";
            this.visible_fraction = _data["visible_fraction"] !== undefined ? _data["visible_fraction"] : 0.25;
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0.32;
            this.return_air_fraction = _data["return_air_fraction"] !== undefined ? _data["return_air_fraction"] : 0;
            this.baseline_watts_per_area = _data["baseline_watts_per_area"] !== undefined ? _data["baseline_watts_per_area"] : 11.84029;
        }
    }

    static override fromJS(data: any): LightingAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new LightingAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts_per_area"] = this.watts_per_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["visible_fraction"] = this.visible_fraction;
        data["radiant_fraction"] = this.radiant_fraction;
        data["return_air_fraction"] = this.return_air_fraction;
        data["baseline_watts_per_area"] = this.baseline_watts_per_area;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface ILightingAbridged extends IIDdEnergyBaseModel {
    /** Lighting per floor area as [W/m2]. */
    watts_per_area: number;
    /** Identifier of the schedule for the use of lights over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete lighting profile. */
    schedule: string;
    type?: string;
    /** The fraction of heat from lights that goes into the zone as visible (short-wave) radiation. (Default: 0.25). */
    visible_fraction?: number;
    /** The fraction of heat from lights that is long-wave radiation. (Default: 0.32). */
    radiant_fraction?: number;
    /** The fraction of the heat from lights that goes into the zone return air. (Default: 0). */
    return_air_fraction?: number;
    /** The baseline lighting power density in [W/m2] of floor area. This baseline is useful to track how much better the installed lights are in comparison to a standard like ASHRAE 90.1. If set to None, it will default to 11.84029 W/m2, which is that ASHRAE 90.1-2004 baseline for an office. */
    baseline_watts_per_area?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class _EquipmentBase extends IDdEnergyBaseModel implements I_EquipmentBase {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area!: number;
    /** Identifier of the schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule!: string;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    readonly type: string = "_EquipmentBase";

    constructor(data?: I_EquipmentBase) {
        super(data);
        if (!data) {
            this.radiant_fraction = 0;
            this.latent_fraction = 0;
            this.lost_fraction = 0;
            this.type = "_EquipmentBase";
        }
        this._discriminator = "_EquipmentBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts_per_area = _data["watts_per_area"];
            this.schedule = _data["schedule"];
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0;
            this.lost_fraction = _data["lost_fraction"] !== undefined ? _data["lost_fraction"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_EquipmentBase";
        }
    }

    static override fromJS(data: any): _EquipmentBase {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ElectricEquipmentAbridged") {
            let result = new ElectricEquipmentAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "GasEquipmentAbridged") {
            let result = new GasEquipmentAbridged();
            result.init(data);
            return result;
        }
        let result = new _EquipmentBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts_per_area"] = this.watts_per_area;
        data["schedule"] = this.schedule;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        data["lost_fraction"] = this.lost_fraction;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface I_EquipmentBase extends IIDdEnergyBaseModel {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area: number;
    /** Identifier of the schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule: string;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ElectricEquipmentAbridged extends _EquipmentBase implements IElectricEquipmentAbridged {
    readonly type: string = "ElectricEquipmentAbridged";

    constructor(data?: IElectricEquipmentAbridged) {
        super(data);
        if (!data) {
            this.type = "ElectricEquipmentAbridged";
        }
        this._discriminator = "ElectricEquipmentAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ElectricEquipmentAbridged";
        }
    }

    static override fromJS(data: any): ElectricEquipmentAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricEquipmentAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IElectricEquipmentAbridged extends I_EquipmentBase {
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class GasEquipmentAbridged extends _EquipmentBase implements IGasEquipmentAbridged {
    readonly type: string = "GasEquipmentAbridged";

    constructor(data?: IGasEquipmentAbridged) {
        super(data);
        if (!data) {
            this.type = "GasEquipmentAbridged";
        }
        this._discriminator = "GasEquipmentAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GasEquipmentAbridged";
        }
    }

    static override fromJS(data: any): GasEquipmentAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new GasEquipmentAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IGasEquipmentAbridged extends I_EquipmentBase {
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ServiceHotWaterAbridged extends IDdEnergyBaseModel implements IServiceHotWaterAbridged {
    /** Number for the total volume flow rate of water per unit area of floor [L/h-m2]. */
    flow_per_area!: number;
    /** Identifier of the schedule for the hot water use over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_area to yield a complete water usage profile. */
    schedule!: string;
    readonly type: string = "ServiceHotWaterAbridged";
    /** Number for the target temperature of water out of the tap (C). This the temperature after hot water has been mixed with cold water from the water mains. The default is 60C, which essentially assumes that the flow_per_area on this object is only for water straight out of the water heater. */
    target_temperature?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load given off as sensible heat in the zone. */
    sensible_fraction?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load that is latent. */
    latent_fraction?: number;

    constructor(data?: IServiceHotWaterAbridged) {
        super(data);
        if (!data) {
            this.type = "ServiceHotWaterAbridged";
            this.target_temperature = 60;
            this.sensible_fraction = 0.2;
            this.latent_fraction = 0.05;
        }
        this._discriminator = "ServiceHotWaterAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_per_area = _data["flow_per_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ServiceHotWaterAbridged";
            this.target_temperature = _data["target_temperature"] !== undefined ? _data["target_temperature"] : 60;
            this.sensible_fraction = _data["sensible_fraction"] !== undefined ? _data["sensible_fraction"] : 0.2;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0.05;
        }
    }

    static override fromJS(data: any): ServiceHotWaterAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceHotWaterAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_per_area"] = this.flow_per_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["target_temperature"] = this.target_temperature;
        data["sensible_fraction"] = this.sensible_fraction;
        data["latent_fraction"] = this.latent_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IServiceHotWaterAbridged extends IIDdEnergyBaseModel {
    /** Number for the total volume flow rate of water per unit area of floor [L/h-m2]. */
    flow_per_area: number;
    /** Identifier of the schedule for the hot water use over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_area to yield a complete water usage profile. */
    schedule: string;
    type?: string;
    /** Number for the target temperature of water out of the tap (C). This the temperature after hot water has been mixed with cold water from the water mains. The default is 60C, which essentially assumes that the flow_per_area on this object is only for water straight out of the water heater. */
    target_temperature?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load given off as sensible heat in the zone. */
    sensible_fraction?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load that is latent. */
    latent_fraction?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class InfiltrationAbridged extends IDdEnergyBaseModel implements IInfiltrationAbridged {
    /** Number for the infiltration per exterior surface area in m3/s-m2. */
    flow_per_exterior_area!: number;
    /** Identifier of the schedule for the infiltration over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_exterior_area to yield a complete infiltration profile. */
    schedule!: string;
    readonly type: string = "InfiltrationAbridged";
    constant_coefficient?: number;
    temperature_coefficient?: number;
    velocity_coefficient?: number;

    constructor(data?: IInfiltrationAbridged) {
        super(data);
        if (!data) {
            this.type = "InfiltrationAbridged";
            this.constant_coefficient = 1;
            this.temperature_coefficient = 0;
            this.velocity_coefficient = 0;
        }
        this._discriminator = "InfiltrationAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_per_exterior_area = _data["flow_per_exterior_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "InfiltrationAbridged";
            this.constant_coefficient = _data["constant_coefficient"] !== undefined ? _data["constant_coefficient"] : 1;
            this.temperature_coefficient = _data["temperature_coefficient"] !== undefined ? _data["temperature_coefficient"] : 0;
            this.velocity_coefficient = _data["velocity_coefficient"] !== undefined ? _data["velocity_coefficient"] : 0;
        }
    }

    static override fromJS(data: any): InfiltrationAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new InfiltrationAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_per_exterior_area"] = this.flow_per_exterior_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["constant_coefficient"] = this.constant_coefficient;
        data["temperature_coefficient"] = this.temperature_coefficient;
        data["velocity_coefficient"] = this.velocity_coefficient;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IInfiltrationAbridged extends IIDdEnergyBaseModel {
    /** Number for the infiltration per exterior surface area in m3/s-m2. */
    flow_per_exterior_area: number;
    /** Identifier of the schedule for the infiltration over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_exterior_area to yield a complete infiltration profile. */
    schedule: string;
    type?: string;
    constant_coefficient?: number;
    temperature_coefficient?: number;
    velocity_coefficient?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class VentilationAbridged extends IDdEnergyBaseModel implements IVentilationAbridged {
    readonly type: string = "VentilationAbridged";
    /** Intensity of ventilation in[] m3/s per person]. Note that setting this value does not mean that ventilation is varied based on real-time occupancy but rather that the design level of ventilation is determined using this value and the People object of the Room. */
    flow_per_person?: number;
    /** Intensity of ventilation in [m3/s per m2 of floor area]. */
    flow_per_area?: number;
    /** Intensity of ventilation in air changes per hour (ACH) for the entire Room. */
    air_changes_per_hour?: number;
    /** Intensity of ventilation in m3/s for the entire Room. */
    flow_per_zone?: number;
    /** Identifier of the schedule for the ventilation over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the total design flow rate (determined from the sum of the other 4 fields) to yield a complete ventilation profile. */
    schedule?: string;

    constructor(data?: IVentilationAbridged) {
        super(data);
        if (!data) {
            this.type = "VentilationAbridged";
            this.flow_per_person = 0;
            this.flow_per_area = 0;
            this.air_changes_per_hour = 0;
            this.flow_per_zone = 0;
        }
        this._discriminator = "VentilationAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VentilationAbridged";
            this.flow_per_person = _data["flow_per_person"] !== undefined ? _data["flow_per_person"] : 0;
            this.flow_per_area = _data["flow_per_area"] !== undefined ? _data["flow_per_area"] : 0;
            this.air_changes_per_hour = _data["air_changes_per_hour"] !== undefined ? _data["air_changes_per_hour"] : 0;
            this.flow_per_zone = _data["flow_per_zone"] !== undefined ? _data["flow_per_zone"] : 0;
            this.schedule = _data["schedule"];
        }
    }

    static override fromJS(data: any): VentilationAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new VentilationAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["flow_per_person"] = this.flow_per_person;
        data["flow_per_area"] = this.flow_per_area;
        data["air_changes_per_hour"] = this.air_changes_per_hour;
        data["flow_per_zone"] = this.flow_per_zone;
        data["schedule"] = this.schedule;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IVentilationAbridged extends IIDdEnergyBaseModel {
    type?: string;
    /** Intensity of ventilation in[] m3/s per person]. Note that setting this value does not mean that ventilation is varied based on real-time occupancy but rather that the design level of ventilation is determined using this value and the People object of the Room. */
    flow_per_person?: number;
    /** Intensity of ventilation in [m3/s per m2 of floor area]. */
    flow_per_area?: number;
    /** Intensity of ventilation in air changes per hour (ACH) for the entire Room. */
    air_changes_per_hour?: number;
    /** Intensity of ventilation in m3/s for the entire Room. */
    flow_per_zone?: number;
    /** Identifier of the schedule for the ventilation over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the total design flow rate (determined from the sum of the other 4 fields) to yield a complete ventilation profile. */
    schedule?: string;
}

/** Used to specify information about the setpoint schedule. */
export class SetpointAbridged extends IDdEnergyBaseModel implements ISetpointAbridged {
    /** Identifier of the schedule for the cooling setpoint. The values in this schedule should be temperature in [C]. */
    cooling_schedule!: string;
    /** Identifier of the schedule for the heating setpoint. The values in this schedule should be temperature in [C]. */
    heating_schedule!: string;
    readonly type: string = "SetpointAbridged";
    /** Identifier of the schedule for the humidification setpoint. The values in this schedule should be in [%]. */
    humidifying_schedule?: string;
    /** Identifier of the schedule for the dehumidification setpoint. The values in this schedule should be in [%]. */
    dehumidifying_schedule?: string;
    /** An optional positive number for the temperature difference between the cutout temperature and the setpoint temperature. Specifying a non-zero number here is useful for modeling the throttling range associated with a given setup of setpoint controls and HVAC equipment. Throttling ranges describe the range where a zone is slightly over-cooled or over-heated beyond the thermostat setpoint. They are used to avoid situations where HVAC systems turn on only to turn off a few minutes later, thereby wearing out the parts of mechanical systems faster. They can have a minor impact on energy consumption and can often have significant impacts on occupant thermal comfort, though using the default value of zero will often yield results that are close enough when trying to estimate the annual heating/cooling energy use. Specifying a value of zero effectively assumes that the system will turn on whenever conditions are outside the setpoint range and will cut out as soon as the setpoint is reached. */
    setpoint_cutout_difference?: number;

    constructor(data?: ISetpointAbridged) {
        super(data);
        if (!data) {
            this.type = "SetpointAbridged";
            this.setpoint_cutout_difference = 0;
        }
        this._discriminator = "SetpointAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cooling_schedule = _data["cooling_schedule"];
            this.heating_schedule = _data["heating_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "SetpointAbridged";
            this.humidifying_schedule = _data["humidifying_schedule"];
            this.dehumidifying_schedule = _data["dehumidifying_schedule"];
            this.setpoint_cutout_difference = _data["setpoint_cutout_difference"] !== undefined ? _data["setpoint_cutout_difference"] : 0;
        }
    }

    static override fromJS(data: any): SetpointAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new SetpointAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cooling_schedule"] = this.cooling_schedule;
        data["heating_schedule"] = this.heating_schedule;
        data["type"] = this.type;
        data["humidifying_schedule"] = this.humidifying_schedule;
        data["dehumidifying_schedule"] = this.dehumidifying_schedule;
        data["setpoint_cutout_difference"] = this.setpoint_cutout_difference;
        super.toJSON(data);
        return data;
    }
}

/** Used to specify information about the setpoint schedule. */
export interface ISetpointAbridged extends IIDdEnergyBaseModel {
    /** Identifier of the schedule for the cooling setpoint. The values in this schedule should be temperature in [C]. */
    cooling_schedule: string;
    /** Identifier of the schedule for the heating setpoint. The values in this schedule should be temperature in [C]. */
    heating_schedule: string;
    type?: string;
    /** Identifier of the schedule for the humidification setpoint. The values in this schedule should be in [%]. */
    humidifying_schedule?: string;
    /** Identifier of the schedule for the dehumidification setpoint. The values in this schedule should be in [%]. */
    dehumidifying_schedule?: string;
    /** An optional positive number for the temperature difference between the cutout temperature and the setpoint temperature. Specifying a non-zero number here is useful for modeling the throttling range associated with a given setup of setpoint controls and HVAC equipment. Throttling ranges describe the range where a zone is slightly over-cooled or over-heated beyond the thermostat setpoint. They are used to avoid situations where HVAC systems turn on only to turn off a few minutes later, thereby wearing out the parts of mechanical systems faster. They can have a minor impact on energy consumption and can often have significant impacts on occupant thermal comfort, though using the default value of zero will often yield results that are close enough when trying to estimate the annual heating/cooling energy use. Specifying a value of zero effectively assumes that the system will turn on whenever conditions are outside the setpoint range and will cut out as soon as the setpoint is reached. */
    setpoint_cutout_difference?: number;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class DaylightingControl extends _OpenAPIGenBaseModel implements IDaylightingControl {
    /** A point as 3 (x, y, z) values for the position of the daylight sensor within the parent Room. This point should lie within the Room volume in order for the results to be meaningful. */
    sensor_position!: number[];
    readonly type: string = "DaylightingControl";
    /** A number for the illuminance setpoint in lux beyond which electric lights are dimmed if there is sufficient daylight. */
    illuminance_setpoint?: number;
    /** A number between 0 and 1 that represents the fraction of the Room lights that are dimmed when the illuminance at the sensor position is at the specified illuminance. 1 indicates that all lights are dim-able while 0 indicates that no lights are dim-able. Deeper rooms should have lower control fractions to account for the face that the lights in the back of the space do not dim in response to suitable daylight at the front of the room. */
    control_fraction?: number;
    /** A number between 0 and 1 for the the lowest power the lighting system can dim down to, expressed as a fraction of maximum input power. */
    min_power_input?: number;
    /** A number between 0 and 1 the lowest lighting output the lighting system can dim down to, expressed as a fraction of maximum light output. */
    min_light_output?: number;
    /** Boolean to note whether lights should switch off completely when they get to the minimum power input. */
    off_at_minimum?: boolean;

    constructor(data?: IDaylightingControl) {
        super(data);
        if (!data) {
            this.sensor_position = [];
            this.type = "DaylightingControl";
            this.illuminance_setpoint = 300;
            this.control_fraction = 1;
            this.min_power_input = 0.3;
            this.min_light_output = 0.2;
            this.off_at_minimum = false;
        }
        this._discriminator = "DaylightingControl";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sensor_position"])) {
                this.sensor_position = [] as any;
                for (let item of _data["sensor_position"])
                    this.sensor_position!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DaylightingControl";
            this.illuminance_setpoint = _data["illuminance_setpoint"] !== undefined ? _data["illuminance_setpoint"] : 300;
            this.control_fraction = _data["control_fraction"] !== undefined ? _data["control_fraction"] : 1;
            this.min_power_input = _data["min_power_input"] !== undefined ? _data["min_power_input"] : 0.3;
            this.min_light_output = _data["min_light_output"] !== undefined ? _data["min_light_output"] : 0.2;
            this.off_at_minimum = _data["off_at_minimum"] !== undefined ? _data["off_at_minimum"] : false;
        }
    }

    static override fromJS(data: any): DaylightingControl {
        data = typeof data === 'object' ? data : {};
        let result = new DaylightingControl();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sensor_position)) {
            data["sensor_position"] = [];
            for (let item of this.sensor_position)
                data["sensor_position"].push(item);
        }
        data["type"] = this.type;
        data["illuminance_setpoint"] = this.illuminance_setpoint;
        data["control_fraction"] = this.control_fraction;
        data["min_power_input"] = this.min_power_input;
        data["min_light_output"] = this.min_light_output;
        data["off_at_minimum"] = this.off_at_minimum;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IDaylightingControl extends I_OpenAPIGenBaseModel {
    /** A point as 3 (x, y, z) values for the position of the daylight sensor within the parent Room. This point should lie within the Room volume in order for the results to be meaningful. */
    sensor_position: number[];
    type?: string;
    /** A number for the illuminance setpoint in lux beyond which electric lights are dimmed if there is sufficient daylight. */
    illuminance_setpoint?: number;
    /** A number between 0 and 1 that represents the fraction of the Room lights that are dimmed when the illuminance at the sensor position is at the specified illuminance. 1 indicates that all lights are dim-able while 0 indicates that no lights are dim-able. Deeper rooms should have lower control fractions to account for the face that the lights in the back of the space do not dim in response to suitable daylight at the front of the room. */
    control_fraction?: number;
    /** A number between 0 and 1 for the the lowest power the lighting system can dim down to, expressed as a fraction of maximum input power. */
    min_power_input?: number;
    /** A number between 0 and 1 the lowest lighting output the lighting system can dim down to, expressed as a fraction of maximum light output. */
    min_light_output?: number;
    /** Boolean to note whether lights should switch off completely when they get to the minimum power input. */
    off_at_minimum?: boolean;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class VentilationControlAbridged extends _OpenAPIGenBaseModel implements IVentilationControlAbridged {
    readonly type: string = "VentilationControlAbridged";
    /** A number for the minimum indoor temperature at which to ventilate in Celsius. Typically, this variable is used to initiate ventilation. */
    min_indoor_temperature?: number;
    /** A number for the maximum indoor temperature at which to ventilate in Celsius. This can be used to set a maximum temperature at which point ventilation is stopped and a cooling system is turned on. */
    max_indoor_temperature?: number;
    /** A number for the minimum outdoor temperature at which to ventilate in Celsius. This can be used to ensure ventilative cooling does not happen during the winter even if the Room is above the min_indoor_temperature. */
    min_outdoor_temperature?: number;
    /** A number for the maximum indoor temperature at which to ventilate in Celsius. This can be used to set a limit for when it is considered too hot outside for ventilative cooling. */
    max_outdoor_temperature?: number;
    /** A number for the temperature differential in Celsius between indoor and outdoor below which ventilation is shut off.  This should usually be a positive number so that ventilation only occurs when the outdoors is cooler than the indoors. Negative numbers indicate how much hotter the outdoors can be than the indoors before ventilation is stopped. */
    delta_temperature?: number;
    /** Identifier of the schedule for the ventilation over the course of the year. Note that this is applied on top of any setpoints. The type of this schedule should be On/Off and values should be either 0 (no possibility of ventilation) or 1 (ventilation possible). */
    schedule?: string;

    constructor(data?: IVentilationControlAbridged) {
        super(data);
        if (!data) {
            this.type = "VentilationControlAbridged";
            this.min_indoor_temperature = -100;
            this.max_indoor_temperature = 100;
            this.min_outdoor_temperature = -100;
            this.max_outdoor_temperature = 100;
            this.delta_temperature = -100;
        }
        this._discriminator = "VentilationControlAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VentilationControlAbridged";
            this.min_indoor_temperature = _data["min_indoor_temperature"] !== undefined ? _data["min_indoor_temperature"] : -100;
            this.max_indoor_temperature = _data["max_indoor_temperature"] !== undefined ? _data["max_indoor_temperature"] : 100;
            this.min_outdoor_temperature = _data["min_outdoor_temperature"] !== undefined ? _data["min_outdoor_temperature"] : -100;
            this.max_outdoor_temperature = _data["max_outdoor_temperature"] !== undefined ? _data["max_outdoor_temperature"] : 100;
            this.delta_temperature = _data["delta_temperature"] !== undefined ? _data["delta_temperature"] : -100;
            this.schedule = _data["schedule"];
        }
    }

    static override fromJS(data: any): VentilationControlAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new VentilationControlAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["min_indoor_temperature"] = this.min_indoor_temperature;
        data["max_indoor_temperature"] = this.max_indoor_temperature;
        data["min_outdoor_temperature"] = this.min_outdoor_temperature;
        data["max_outdoor_temperature"] = this.max_outdoor_temperature;
        data["delta_temperature"] = this.delta_temperature;
        data["schedule"] = this.schedule;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IVentilationControlAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A number for the minimum indoor temperature at which to ventilate in Celsius. Typically, this variable is used to initiate ventilation. */
    min_indoor_temperature?: number;
    /** A number for the maximum indoor temperature at which to ventilate in Celsius. This can be used to set a maximum temperature at which point ventilation is stopped and a cooling system is turned on. */
    max_indoor_temperature?: number;
    /** A number for the minimum outdoor temperature at which to ventilate in Celsius. This can be used to ensure ventilative cooling does not happen during the winter even if the Room is above the min_indoor_temperature. */
    min_outdoor_temperature?: number;
    /** A number for the maximum indoor temperature at which to ventilate in Celsius. This can be used to set a limit for when it is considered too hot outside for ventilative cooling. */
    max_outdoor_temperature?: number;
    /** A number for the temperature differential in Celsius between indoor and outdoor below which ventilation is shut off.  This should usually be a positive number so that ventilation only occurs when the outdoors is cooler than the indoors. Negative numbers indicate how much hotter the outdoors can be than the indoors before ventilation is stopped. */
    delta_temperature?: number;
    /** Identifier of the schedule for the ventilation over the course of the year. Note that this is applied on top of any setpoints. The type of this schedule should be On/Off and values should be either 0 (no possibility of ventilation) or 1 (ventilation possible). */
    schedule?: string;
}

/** An enumeration. */
export enum VentilationType {
    Exhaust = "Exhaust",
    Intake = "Intake",
    Balanced = "Balanced",
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export class VentilationFan extends EnergyBaseModel implements IVentilationFan {
    /** A number for the flow rate of the fan in m3/s. */
    flow_rate!: number;
    /** A number for the the pressure rise across the fan in Pascals (N/m2). This is often a function of the fan speed and the conditions in which the fan is operating since having the fan blow air through filters or narrow ducts will increase the pressure rise that is needed to deliver the input flow rate. The pressure rise plays an important role in determining the amount of energy consumed by the fan. Smaller fans like a 0.05 m3/s desk fan tend to have lower pressure rises around 60 Pa. Larger fans, such as a 6 m3/s fan used for ventilating a large room tend to have higher pressure rises around 400 Pa. The highest pressure rises are typically for large fans blowing air through ducts and filters, which can have pressure rises as high as 1000 Pa. */
    pressure_rise!: number;
    /** A number between 0 and 1 for the overall efficiency of the fan. Specifically, this is the ratio of the power delivered to the fluid to the electrical input power. It is the product of the fan motor efficiency and the fan impeller efficiency. Fans that have a higher blade diameter and operate at lower speeds with smaller pressure rises for their size tend to have higher efficiencies. Because motor efficiencies are typically between 0.8 and 0.9, the best overall fan efficiencies tend to be around 0.7 with most typical fan efficiencies between 0.5 and 0.7. The lowest efficiencies often happen for small fans in situations with high pressure rises for their size, which can result in efficiencies as low as 0.15. */
    efficiency!: number;
    readonly type: string = "VentilationFan";
    /** Text to indicate the type of type of ventilation. Choose from the options below. For either Exhaust or Intake, values for fan pressure and efficiency define the fan electric consumption. For Exhaust ventilation, the conditions of the air entering the space are assumed to be equivalent to outside air conditions. For Intake and Balanced ventilation, an appropriate amount of fan heat is added to the entering air stream. For Balanced ventilation, both an intake fan and an exhaust fan are assumed to co-exist, both having the same flow rate and power consumption (using the entered values for fan pressure rise and fan total efficiency). Thus, the fan electric consumption for Balanced ventilation is twice that for the Exhaust or Intake ventilation types which employ only a single fan. */
    ventilation_type?: VentilationType;
    /** A VentilationControl object that dictates the conditions under which the fan is turned on. If None, a default VentilationControl will be generated, which will keep the fan on all of the time. */
    control?: VentilationControlAbridged;

    constructor(data?: IVentilationFan) {
        super(data);
        if (!data) {
            this.type = "VentilationFan";
            this.ventilation_type = VentilationType.Balanced;
        }
        this._discriminator = "VentilationFan";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_rate = _data["flow_rate"];
            this.pressure_rise = _data["pressure_rise"];
            this.efficiency = _data["efficiency"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VentilationFan";
            this.ventilation_type = _data["ventilation_type"] !== undefined ? _data["ventilation_type"] : VentilationType.Balanced;
            this.control = _data["control"] ? VentilationControlAbridged.fromJS(_data["control"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): VentilationFan {
        data = typeof data === 'object' ? data : {};
        let result = new VentilationFan();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_rate"] = this.flow_rate;
        data["pressure_rise"] = this.pressure_rise;
        data["efficiency"] = this.efficiency;
        data["type"] = this.type;
        data["ventilation_type"] = this.ventilation_type;
        data["control"] = this.control ? this.control.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a valid EnergyPlus identifier. */
export interface IVentilationFan extends IEnergyBaseModel {
    /** A number for the flow rate of the fan in m3/s. */
    flow_rate: number;
    /** A number for the the pressure rise across the fan in Pascals (N/m2). This is often a function of the fan speed and the conditions in which the fan is operating since having the fan blow air through filters or narrow ducts will increase the pressure rise that is needed to deliver the input flow rate. The pressure rise plays an important role in determining the amount of energy consumed by the fan. Smaller fans like a 0.05 m3/s desk fan tend to have lower pressure rises around 60 Pa. Larger fans, such as a 6 m3/s fan used for ventilating a large room tend to have higher pressure rises around 400 Pa. The highest pressure rises are typically for large fans blowing air through ducts and filters, which can have pressure rises as high as 1000 Pa. */
    pressure_rise: number;
    /** A number between 0 and 1 for the overall efficiency of the fan. Specifically, this is the ratio of the power delivered to the fluid to the electrical input power. It is the product of the fan motor efficiency and the fan impeller efficiency. Fans that have a higher blade diameter and operate at lower speeds with smaller pressure rises for their size tend to have higher efficiencies. Because motor efficiencies are typically between 0.8 and 0.9, the best overall fan efficiencies tend to be around 0.7 with most typical fan efficiencies between 0.5 and 0.7. The lowest efficiencies often happen for small fans in situations with high pressure rises for their size, which can result in efficiencies as low as 0.15. */
    efficiency: number;
    type?: string;
    /** Text to indicate the type of type of ventilation. Choose from the options below. For either Exhaust or Intake, values for fan pressure and efficiency define the fan electric consumption. For Exhaust ventilation, the conditions of the air entering the space are assumed to be equivalent to outside air conditions. For Intake and Balanced ventilation, an appropriate amount of fan heat is added to the entering air stream. For Balanced ventilation, both an intake fan and an exhaust fan are assumed to co-exist, both having the same flow rate and power consumption (using the entered values for fan pressure rise and fan total efficiency). Thus, the fan electric consumption for Balanced ventilation is twice that for the Exhaust or Intake ventilation types which employ only a single fan. */
    ventilation_type?: VentilationType;
    /** A VentilationControl object that dictates the conditions under which the fan is turned on. If None, a default VentilationControl will be generated, which will keep the fan on all of the time. */
    control?: VentilationControlAbridged;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class InternalMassAbridged extends IDdEnergyBaseModel implements IInternalMassAbridged {
    /** Identifier for an OpaqueConstruction that represents the material that the internal thermal mass is composed of. */
    construction!: string;
    /** A number representing the surface area of the internal mass that is exposed to the Room air. This value should always be in square meters regardless of what units system the parent model is a part of. */
    area!: number;
    readonly type: string = "InternalMassAbridged";

    constructor(data?: IInternalMassAbridged) {
        super(data);
        if (!data) {
            this.type = "InternalMassAbridged";
        }
        this._discriminator = "InternalMassAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.construction = _data["construction"];
            this.area = _data["area"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "InternalMassAbridged";
        }
    }

    static override fromJS(data: any): InternalMassAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new InternalMassAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["construction"] = this.construction;
        data["area"] = this.area;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IInternalMassAbridged extends IIDdEnergyBaseModel {
    /** Identifier for an OpaqueConstruction that represents the material that the internal thermal mass is composed of. */
    construction: string;
    /** A number representing the surface area of the internal mass that is exposed to the Room air. This value should always be in square meters regardless of what units system the parent model is a part of. */
    area: number;
    type?: string;
}

/** Designates the acceptable fuel types for process loads. */
export enum FuelTypes {
    Electricity = "Electricity",
    NaturalGas = "NaturalGas",
    Propane = "Propane",
    FuelOilNo1 = "FuelOilNo1",
    FuelOilNo2 = "FuelOilNo2",
    Diesel = "Diesel",
    Gasoline = "Gasoline",
    Coal = "Coal",
    Steam = "Steam",
    DistrictHeating = "DistrictHeating",
    DistrictCooling = "DistrictCooling",
    OtherFuel1 = "OtherFuel1",
    OtherFuel2 = "OtherFuel2",
    None = "None",
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ProcessAbridged extends IDdEnergyBaseModel implements IProcessAbridged {
    /** A number for the process load power in Watts. */
    watts!: number;
    /** Identifier of the schedule for the use of the process over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts to yield a complete equipment profile. */
    schedule!: string;
    /** Text to denote the type of fuel consumed by the process. Using the "None" type indicates that no end uses will be associated with the process, only the zone gains. */
    fuel_type!: FuelTypes;
    readonly type: string = "ProcessAbridged";
    /** Text to indicate the end-use subcategory, which will identify the process load in the end use output. For example, “Cooking”, “Clothes Drying”, etc. A new meter for reporting is created for each unique subcategory. */
    end_use_category?: string;
    /** Number for the amount of long-wave radiation heat given off by the process load. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by the process load. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by the process load. The default value is 0. */
    lost_fraction?: number;

    constructor(data?: IProcessAbridged) {
        super(data);
        if (!data) {
            this.type = "ProcessAbridged";
            this.end_use_category = "Process";
            this.radiant_fraction = 0;
            this.latent_fraction = 0;
            this.lost_fraction = 0;
        }
        this._discriminator = "ProcessAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts = _data["watts"];
            this.schedule = _data["schedule"];
            this.fuel_type = _data["fuel_type"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ProcessAbridged";
            this.end_use_category = _data["end_use_category"] !== undefined ? _data["end_use_category"] : "Process";
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0;
            this.lost_fraction = _data["lost_fraction"] !== undefined ? _data["lost_fraction"] : 0;
        }
    }

    static override fromJS(data: any): ProcessAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts"] = this.watts;
        data["schedule"] = this.schedule;
        data["fuel_type"] = this.fuel_type;
        data["type"] = this.type;
        data["end_use_category"] = this.end_use_category;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        data["lost_fraction"] = this.lost_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IProcessAbridged extends IIDdEnergyBaseModel {
    /** A number for the process load power in Watts. */
    watts: number;
    /** Identifier of the schedule for the use of the process over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts to yield a complete equipment profile. */
    schedule: string;
    /** Text to denote the type of fuel consumed by the process. Using the "None" type indicates that no end uses will be associated with the process, only the zone gains. */
    fuel_type: FuelTypes;
    type?: string;
    /** Text to indicate the end-use subcategory, which will identify the process load in the end use output. For example, “Cooking”, “Clothes Drying”, etc. A new meter for reporting is created for each unique subcategory. */
    end_use_category?: string;
    /** Number for the amount of long-wave radiation heat given off by the process load. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by the process load. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by the process load. The default value is 0. */
    lost_fraction?: number;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class RoomEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IRoomEnergyPropertiesAbridged {
    readonly type: string = "RoomEnergyPropertiesAbridged";
    /** Identifier of a ConstructionSet to specify all default constructions for the Faces, Apertures, and Doors of the Room. If None, the Room will use the Model global_construction_set. */
    construction_set?: string;
    /** Identifier of a ProgramType to specify all default schedules and loads for the Room. If None, the Room will have no loads or setpoints. */
    program_type?: string;
    /** An optional identifier of a HVAC system (such as an IdealAirSystem) that specifies how the Room is conditioned. If None, it will be assumed that the Room is not conditioned. */
    hvac?: string;
    /** An optional identifier of a Service Hot Water (SHW) system that specifies how the hot water load of the Room is met. If None, the hot water load will be met with a generic system that only measures thermal loadand does not account for system efficiencies. */
    shw?: string;
    /** People object to describe the occupancy of the Room. */
    people?: PeopleAbridged;
    /** Lighting object to describe the lighting usage of the Room. */
    lighting?: LightingAbridged;
    /** ElectricEquipment object to describe the electric equipment usage. */
    electric_equipment?: ElectricEquipmentAbridged;
    /** GasEquipment object to describe the gas equipment usage. */
    gas_equipment?: GasEquipmentAbridged;
    /** ServiceHotWater object to describe the hot water usage. */
    service_hot_water?: ServiceHotWaterAbridged;
    /** Infiltration object to to describe the outdoor air leakage. */
    infiltration?: InfiltrationAbridged;
    /** Ventilation object for the minimum outdoor air requirement. */
    ventilation?: VentilationAbridged;
    /** Setpoint object for the temperature setpoints of the Room. */
    setpoint?: SetpointAbridged;
    /** An optional DaylightingControl object to dictate the dimming of lights. If None, the lighting will respond only to the schedule and not the daylight conditions within the room. */
    daylighting_control?: DaylightingControl;
    /** An optional VentilationControl object to dictate the opening of windows. If None, the windows will never open. */
    window_vent_control?: VentilationControlAbridged;
    /** An optional list of VentilationFan objects for fans within the room. Note that these fans are not connected to the heating or cooling system and are meant to represent the intentional circulation of unconditioned outdoor air for the purposes of keeping a space cooler, drier or free of indoor pollutants (as in the case of kitchen or bathroom exhaust fans). For the specification of mechanical ventilation of conditioned outdoor air, the Room.ventilation property should be used and the Room should be given a HVAC that can meet this specification. */
    fans?: VentilationFan[];
    /** An optional list of of InternalMass objects for thermal mass exposed to Room air. Note that internal masses assigned this way cannot "see" solar radiation that may potentially hit them and, as such, caution should be taken when using this component with internal mass objects that are not always in shade. Masses are factored into the the thermal calculations of the Room by undergoing heat transfer with the indoor air. */
    internal_masses?: InternalMassAbridged[];
    /** An optional list of of Process objects for process loads within the room. These can represent kilns, manufacturing equipment, and various industrial processes. They can also be used to represent wood burning fireplaces or certain pieces of equipment to be separated from the other end uses. */
    process_loads?: ProcessAbridged[];

    constructor(data?: IRoomEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "RoomEnergyPropertiesAbridged";
        }
        this._discriminator = "RoomEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoomEnergyPropertiesAbridged";
            this.construction_set = _data["construction_set"];
            this.program_type = _data["program_type"];
            this.hvac = _data["hvac"];
            this.shw = _data["shw"];
            this.people = _data["people"] ? PeopleAbridged.fromJS(_data["people"]) : <any>undefined;
            this.lighting = _data["lighting"] ? LightingAbridged.fromJS(_data["lighting"]) : <any>undefined;
            this.electric_equipment = _data["electric_equipment"] ? ElectricEquipmentAbridged.fromJS(_data["electric_equipment"]) : <any>undefined;
            this.gas_equipment = _data["gas_equipment"] ? GasEquipmentAbridged.fromJS(_data["gas_equipment"]) : <any>undefined;
            this.service_hot_water = _data["service_hot_water"] ? ServiceHotWaterAbridged.fromJS(_data["service_hot_water"]) : <any>undefined;
            this.infiltration = _data["infiltration"] ? InfiltrationAbridged.fromJS(_data["infiltration"]) : <any>undefined;
            this.ventilation = _data["ventilation"] ? VentilationAbridged.fromJS(_data["ventilation"]) : <any>undefined;
            this.setpoint = _data["setpoint"] ? SetpointAbridged.fromJS(_data["setpoint"]) : <any>undefined;
            this.daylighting_control = _data["daylighting_control"] ? DaylightingControl.fromJS(_data["daylighting_control"]) : <any>undefined;
            this.window_vent_control = _data["window_vent_control"] ? VentilationControlAbridged.fromJS(_data["window_vent_control"]) : <any>undefined;
            if (Array.isArray(_data["fans"])) {
                this.fans = [] as any;
                for (let item of _data["fans"])
                    this.fans!.push(VentilationFan.fromJS(item));
            }
            if (Array.isArray(_data["internal_masses"])) {
                this.internal_masses = [] as any;
                for (let item of _data["internal_masses"])
                    this.internal_masses!.push(InternalMassAbridged.fromJS(item));
            }
            if (Array.isArray(_data["process_loads"])) {
                this.process_loads = [] as any;
                for (let item of _data["process_loads"])
                    this.process_loads!.push(ProcessAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): RoomEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RoomEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction_set"] = this.construction_set;
        data["program_type"] = this.program_type;
        data["hvac"] = this.hvac;
        data["shw"] = this.shw;
        data["people"] = this.people ? this.people.toJSON() : <any>undefined;
        data["lighting"] = this.lighting ? this.lighting.toJSON() : <any>undefined;
        data["electric_equipment"] = this.electric_equipment ? this.electric_equipment.toJSON() : <any>undefined;
        data["gas_equipment"] = this.gas_equipment ? this.gas_equipment.toJSON() : <any>undefined;
        data["service_hot_water"] = this.service_hot_water ? this.service_hot_water.toJSON() : <any>undefined;
        data["infiltration"] = this.infiltration ? this.infiltration.toJSON() : <any>undefined;
        data["ventilation"] = this.ventilation ? this.ventilation.toJSON() : <any>undefined;
        data["setpoint"] = this.setpoint ? this.setpoint.toJSON() : <any>undefined;
        data["daylighting_control"] = this.daylighting_control ? this.daylighting_control.toJSON() : <any>undefined;
        data["window_vent_control"] = this.window_vent_control ? this.window_vent_control.toJSON() : <any>undefined;
        if (Array.isArray(this.fans)) {
            data["fans"] = [];
            for (let item of this.fans)
                data["fans"].push(item.toJSON());
        }
        if (Array.isArray(this.internal_masses)) {
            data["internal_masses"] = [];
            for (let item of this.internal_masses)
                data["internal_masses"].push(item.toJSON());
        }
        if (Array.isArray(this.process_loads)) {
            data["process_loads"] = [];
            for (let item of this.process_loads)
                data["process_loads"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IRoomEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of a ConstructionSet to specify all default constructions for the Faces, Apertures, and Doors of the Room. If None, the Room will use the Model global_construction_set. */
    construction_set?: string;
    /** Identifier of a ProgramType to specify all default schedules and loads for the Room. If None, the Room will have no loads or setpoints. */
    program_type?: string;
    /** An optional identifier of a HVAC system (such as an IdealAirSystem) that specifies how the Room is conditioned. If None, it will be assumed that the Room is not conditioned. */
    hvac?: string;
    /** An optional identifier of a Service Hot Water (SHW) system that specifies how the hot water load of the Room is met. If None, the hot water load will be met with a generic system that only measures thermal loadand does not account for system efficiencies. */
    shw?: string;
    /** People object to describe the occupancy of the Room. */
    people?: PeopleAbridged;
    /** Lighting object to describe the lighting usage of the Room. */
    lighting?: LightingAbridged;
    /** ElectricEquipment object to describe the electric equipment usage. */
    electric_equipment?: ElectricEquipmentAbridged;
    /** GasEquipment object to describe the gas equipment usage. */
    gas_equipment?: GasEquipmentAbridged;
    /** ServiceHotWater object to describe the hot water usage. */
    service_hot_water?: ServiceHotWaterAbridged;
    /** Infiltration object to to describe the outdoor air leakage. */
    infiltration?: InfiltrationAbridged;
    /** Ventilation object for the minimum outdoor air requirement. */
    ventilation?: VentilationAbridged;
    /** Setpoint object for the temperature setpoints of the Room. */
    setpoint?: SetpointAbridged;
    /** An optional DaylightingControl object to dictate the dimming of lights. If None, the lighting will respond only to the schedule and not the daylight conditions within the room. */
    daylighting_control?: DaylightingControl;
    /** An optional VentilationControl object to dictate the opening of windows. If None, the windows will never open. */
    window_vent_control?: VentilationControlAbridged;
    /** An optional list of VentilationFan objects for fans within the room. Note that these fans are not connected to the heating or cooling system and are meant to represent the intentional circulation of unconditioned outdoor air for the purposes of keeping a space cooler, drier or free of indoor pollutants (as in the case of kitchen or bathroom exhaust fans). For the specification of mechanical ventilation of conditioned outdoor air, the Room.ventilation property should be used and the Room should be given a HVAC that can meet this specification. */
    fans?: VentilationFan[];
    /** An optional list of of InternalMass objects for thermal mass exposed to Room air. Note that internal masses assigned this way cannot "see" solar radiation that may potentially hit them and, as such, caution should be taken when using this component with internal mass objects that are not always in shade. Masses are factored into the the thermal calculations of the Room by undergoing heat transfer with the indoor air. */
    internal_masses?: InternalMassAbridged[];
    /** An optional list of of Process objects for process loads within the room. These can represent kilns, manufacturing equipment, and various industrial processes. They can also be used to represent wood burning fireplaces or certain pieces of equipment to be separated from the other end uses. */
    process_loads?: ProcessAbridged[];
}

/** Abridged Radiance Properties for Honeybee Room. */
export class RoomRadiancePropertiesAbridged extends _OpenAPIGenBaseModel implements IRoomRadiancePropertiesAbridged {
    readonly type: string = "RoomRadiancePropertiesAbridged";
    /** An identifier for a unique Room-Assigned ModifierSet (default: None). */
    modifier_set?: string;

    constructor(data?: IRoomRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "RoomRadiancePropertiesAbridged";
        }
        this._discriminator = "RoomRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoomRadiancePropertiesAbridged";
            this.modifier_set = _data["modifier_set"];
        }
    }

    static override fromJS(data: any): RoomRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RoomRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier_set"] = this.modifier_set;
        super.toJSON(data);
        return data;
    }
}

/** Abridged Radiance Properties for Honeybee Room. */
export interface IRoomRadiancePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** An identifier for a unique Room-Assigned ModifierSet (default: None). */
    modifier_set?: string;
}

export class RoomPropertiesAbridged extends _OpenAPIGenBaseModel implements IRoomPropertiesAbridged {
    readonly type: string = "RoomPropertiesAbridged";
    energy?: RoomEnergyPropertiesAbridged;
    radiance?: RoomRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IRoomPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "RoomPropertiesAbridged";
        }
        this._discriminator = "RoomPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoomPropertiesAbridged";
            this.energy = _data["energy"] ? RoomEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? RoomRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RoomPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RoomPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoomPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: RoomEnergyPropertiesAbridged;
    radiance?: RoomRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Room extends IDdBaseModel implements IRoom {
    /** Faces that together form the closed volume of a room. */
    faces!: Face[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: RoomPropertiesAbridged;
    readonly type: string = "Room";
    /** Shades assigned to the interior side of this object (eg. partitions, tables). */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. trees, landscaping). */
    outdoor_shades?: Shade[];
    /** An integer noting how many times this Room is repeated. Multipliers are used to speed up the calculation when similar Rooms are repeated more than once. Essentially, a given simulation with the Room is run once and then the result is multiplied by the multiplier. */
    multiplier?: number;
    /** A boolean for whether the Room floor area contributes to Models it is a part of. Note that this will not affect the floor_area property of this Room itself but it will ensure the Room floor area is excluded from any calculations when the Room is part of a Model, including EUI calculations. */
    exclude_floor_area?: boolean;
    /** Text string for the story identifier to which this Room belongs. Rooms sharing the same story identifier are considered part of the same story in a Model. Note that this property has no character restrictions. */
    story?: string;

    constructor(data?: IRoom) {
        super(data);
        if (!data) {
            this.faces = [];
            this.properties = new RoomPropertiesAbridged();
            this.type = "Room";
            this.multiplier = 1;
            this.exclude_floor_area = false;
        }
        this._discriminator = "Room";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["faces"])) {
                this.faces = [] as any;
                for (let item of _data["faces"])
                    this.faces!.push(Face.fromJS(item));
            }
            this.properties = _data["properties"] ? RoomPropertiesAbridged.fromJS(_data["properties"]) : new RoomPropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Room";
            if (Array.isArray(_data["indoor_shades"])) {
                this.indoor_shades = [] as any;
                for (let item of _data["indoor_shades"])
                    this.indoor_shades!.push(Shade.fromJS(item));
            }
            if (Array.isArray(_data["outdoor_shades"])) {
                this.outdoor_shades = [] as any;
                for (let item of _data["outdoor_shades"])
                    this.outdoor_shades!.push(Shade.fromJS(item));
            }
            this.multiplier = _data["multiplier"] !== undefined ? _data["multiplier"] : 1;
            this.exclude_floor_area = _data["exclude_floor_area"] !== undefined ? _data["exclude_floor_area"] : false;
            this.story = _data["story"];
        }
    }

    static override fromJS(data: any): Room {
        data = typeof data === 'object' ? data : {};
        let result = new Room();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.faces)) {
            data["faces"] = [];
            for (let item of this.faces)
                data["faces"].push(item.toJSON());
        }
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.indoor_shades)) {
            data["indoor_shades"] = [];
            for (let item of this.indoor_shades)
                data["indoor_shades"].push(item.toJSON());
        }
        if (Array.isArray(this.outdoor_shades)) {
            data["outdoor_shades"] = [];
            for (let item of this.outdoor_shades)
                data["outdoor_shades"].push(item.toJSON());
        }
        data["multiplier"] = this.multiplier;
        data["exclude_floor_area"] = this.exclude_floor_area;
        data["story"] = this.story;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IRoom extends IIDdBaseModel {
    /** Faces that together form the closed volume of a room. */
    faces: Face[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: RoomPropertiesAbridged;
    type?: string;
    /** Shades assigned to the interior side of this object (eg. partitions, tables). */
    indoor_shades?: Shade[];
    /** Shades assigned to the exterior side of this object (eg. trees, landscaping). */
    outdoor_shades?: Shade[];
    /** An integer noting how many times this Room is repeated. Multipliers are used to speed up the calculation when similar Rooms are repeated more than once. Essentially, a given simulation with the Room is run once and then the result is multiplied by the multiplier. */
    multiplier?: number;
    /** A boolean for whether the Room floor area contributes to Models it is a part of. Note that this will not affect the floor_area property of this Room itself but it will ensure the Room floor area is excluded from any calculations when the Room is part of a Model, including EUI calculations. */
    exclude_floor_area?: boolean;
    /** Text string for the story identifier to which this Room belongs. Rooms sharing the same story identifier are considered part of the same story in a Model. Note that this property has no character restrictions. */
    story?: string;
}

/** Describe a single glass pane corresponding to a layer in a window construction. */
export class EnergyWindowMaterialGlazing extends IDdEnergyBaseModel implements IEnergyWindowMaterialGlazing {
    readonly type: string = "EnergyWindowMaterialGlazing";
    /** The surface-to-surface thickness of the glass in meters. Default:  0.003. */
    thickness?: number;
    /** Transmittance of solar radiation through the glass at normal incidence. Default: 0.85 for clear glass. */
    solar_transmittance?: number;
    /** Reflectance of solar radiation off of the front side of the glass at normal incidence, averaged over the solar spectrum. Default: 0.075 for clear glass. */
    solar_reflectance?: number;
    /** Reflectance of solar radiation off of the back side of the glass at normal incidence, averaged over the solar spectrum. */
    solar_reflectance_back?: Solar_reflectance_back;
    /** Transmittance of visible light through the glass at normal incidence. Default: 0.9 for clear glass. */
    visible_transmittance?: number;
    /** Reflectance of visible light off of the front side of the glass at normal incidence. Default: 0.075 for clear glass. */
    visible_reflectance?: number;
    /** Reflectance of visible light off of the back side of the glass at normal incidence averaged over the solar spectrum and weighted by the response of the human eye. */
    visible_reflectance_back?: Visible_reflectance_back;
    /** Long-wave transmittance at normal incidence. */
    infrared_transmittance?: number;
    /** Infrared hemispherical emissivity of the front (outward facing) side of the glass.  Default: 0.84, which is typical for clear glass without a low-e coating. */
    emissivity?: number;
    /** Infrared hemispherical emissivity of the back (inward facing) side of the glass.  Default: 0.84, which is typical for clear glass without a low-e coating. */
    emissivity_back?: number;
    /** Thermal conductivity of the glass in W/(m-K). Default: 0.9, which is  typical for clear glass without a low-e coating. */
    conductivity?: number;
    /** Factor that corrects for the presence of dirt on the glass. A default value of 1 indicates the glass is clean. */
    dirt_correction?: number;
    /** If False (default), the beam solar radiation incident on the glass is transmitted as beam radiation with no diffuse component.If True, the beam  solar radiation incident on the glass is transmitted as hemispherical diffuse radiation with no beam component. */
    solar_diffusing?: boolean;

    constructor(data?: IEnergyWindowMaterialGlazing) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialGlazing";
            this.thickness = 0.003;
            this.solar_transmittance = 0.85;
            this.solar_reflectance = 0.075;
            this.visible_transmittance = 0.9;
            this.visible_reflectance = 0.075;
            this.infrared_transmittance = 0;
            this.emissivity = 0.84;
            this.emissivity_back = 0.84;
            this.conductivity = 0.9;
            this.dirt_correction = 1;
            this.solar_diffusing = false;
        }
        this._discriminator = "EnergyWindowMaterialGlazing";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialGlazing";
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.003;
            this.solar_transmittance = _data["solar_transmittance"] !== undefined ? _data["solar_transmittance"] : 0.85;
            this.solar_reflectance = _data["solar_reflectance"] !== undefined ? _data["solar_reflectance"] : 0.075;
            this.solar_reflectance_back = _data["solar_reflectance_back"];
            this.visible_transmittance = _data["visible_transmittance"] !== undefined ? _data["visible_transmittance"] : 0.9;
            this.visible_reflectance = _data["visible_reflectance"] !== undefined ? _data["visible_reflectance"] : 0.075;
            this.visible_reflectance_back = _data["visible_reflectance_back"];
            this.infrared_transmittance = _data["infrared_transmittance"] !== undefined ? _data["infrared_transmittance"] : 0;
            this.emissivity = _data["emissivity"] !== undefined ? _data["emissivity"] : 0.84;
            this.emissivity_back = _data["emissivity_back"] !== undefined ? _data["emissivity_back"] : 0.84;
            this.conductivity = _data["conductivity"] !== undefined ? _data["conductivity"] : 0.9;
            this.dirt_correction = _data["dirt_correction"] !== undefined ? _data["dirt_correction"] : 1;
            this.solar_diffusing = _data["solar_diffusing"] !== undefined ? _data["solar_diffusing"] : false;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialGlazing {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialGlazing();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["thickness"] = this.thickness;
        data["solar_transmittance"] = this.solar_transmittance;
        data["solar_reflectance"] = this.solar_reflectance;
        data["solar_reflectance_back"] = this.solar_reflectance_back;
        data["visible_transmittance"] = this.visible_transmittance;
        data["visible_reflectance"] = this.visible_reflectance;
        data["visible_reflectance_back"] = this.visible_reflectance_back;
        data["infrared_transmittance"] = this.infrared_transmittance;
        data["emissivity"] = this.emissivity;
        data["emissivity_back"] = this.emissivity_back;
        data["conductivity"] = this.conductivity;
        data["dirt_correction"] = this.dirt_correction;
        data["solar_diffusing"] = this.solar_diffusing;
        super.toJSON(data);
        return data;
    }
}

/** Describe a single glass pane corresponding to a layer in a window construction. */
export interface IEnergyWindowMaterialGlazing extends IIDdEnergyBaseModel {
    type?: string;
    /** The surface-to-surface thickness of the glass in meters. Default:  0.003. */
    thickness?: number;
    /** Transmittance of solar radiation through the glass at normal incidence. Default: 0.85 for clear glass. */
    solar_transmittance?: number;
    /** Reflectance of solar radiation off of the front side of the glass at normal incidence, averaged over the solar spectrum. Default: 0.075 for clear glass. */
    solar_reflectance?: number;
    /** Reflectance of solar radiation off of the back side of the glass at normal incidence, averaged over the solar spectrum. */
    solar_reflectance_back?: Solar_reflectance_back;
    /** Transmittance of visible light through the glass at normal incidence. Default: 0.9 for clear glass. */
    visible_transmittance?: number;
    /** Reflectance of visible light off of the front side of the glass at normal incidence. Default: 0.075 for clear glass. */
    visible_reflectance?: number;
    /** Reflectance of visible light off of the back side of the glass at normal incidence averaged over the solar spectrum and weighted by the response of the human eye. */
    visible_reflectance_back?: Visible_reflectance_back;
    /** Long-wave transmittance at normal incidence. */
    infrared_transmittance?: number;
    /** Infrared hemispherical emissivity of the front (outward facing) side of the glass.  Default: 0.84, which is typical for clear glass without a low-e coating. */
    emissivity?: number;
    /** Infrared hemispherical emissivity of the back (inward facing) side of the glass.  Default: 0.84, which is typical for clear glass without a low-e coating. */
    emissivity_back?: number;
    /** Thermal conductivity of the glass in W/(m-K). Default: 0.9, which is  typical for clear glass without a low-e coating. */
    conductivity?: number;
    /** Factor that corrects for the presence of dirt on the glass. A default value of 1 indicates the glass is clean. */
    dirt_correction?: number;
    /** If False (default), the beam solar radiation incident on the glass is transmitted as beam radiation with no diffuse component.If True, the beam  solar radiation incident on the glass is transmitted as hemispherical diffuse radiation with no beam component. */
    solar_diffusing?: boolean;
}

/** No mass opaque material representing a layer within an opaque construction. Used when only the thermal resistance (R value) of the material is known. */
export class EnergyMaterialNoMass extends IDdEnergyBaseModel implements IEnergyMaterialNoMass {
    /** The thermal resistance (R-value) of the material layer [m2-K/W]. */
    r_value!: number;
    readonly type: string = "EnergyMaterialNoMass";
    roughness?: Roughness;
    /** Fraction of incident long wavelength radiation that is absorbed by the material. Default: 0.9. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the material. Default: 0.7. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    visible_absorptance?: number;

    constructor(data?: IEnergyMaterialNoMass) {
        super(data);
        if (!data) {
            this.type = "EnergyMaterialNoMass";
            this.roughness = Roughness.MediumRough;
            this.thermal_absorptance = 0.9;
            this.solar_absorptance = 0.7;
            this.visible_absorptance = 0.7;
        }
        this._discriminator = "EnergyMaterialNoMass";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.r_value = _data["r_value"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyMaterialNoMass";
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : Roughness.MediumRough;
            this.thermal_absorptance = _data["thermal_absorptance"] !== undefined ? _data["thermal_absorptance"] : 0.9;
            this.solar_absorptance = _data["solar_absorptance"] !== undefined ? _data["solar_absorptance"] : 0.7;
            this.visible_absorptance = _data["visible_absorptance"] !== undefined ? _data["visible_absorptance"] : 0.7;
        }
    }

    static override fromJS(data: any): EnergyMaterialNoMass {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyMaterialNoMass();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["r_value"] = this.r_value;
        data["type"] = this.type;
        data["roughness"] = this.roughness;
        data["thermal_absorptance"] = this.thermal_absorptance;
        data["solar_absorptance"] = this.solar_absorptance;
        data["visible_absorptance"] = this.visible_absorptance;
        super.toJSON(data);
        return data;
    }
}

/** No mass opaque material representing a layer within an opaque construction. Used when only the thermal resistance (R value) of the material is known. */
export interface IEnergyMaterialNoMass extends IIDdEnergyBaseModel {
    /** The thermal resistance (R-value) of the material layer [m2-K/W]. */
    r_value: number;
    type?: string;
    roughness?: Roughness;
    /** Fraction of incident long wavelength radiation that is absorbed by the material. Default: 0.9. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the material. Default: 0.7. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    visible_absorptance?: number;
}

/** Acceptable values for the moisture diffusion model for vegetation. */
export enum MoistureDiffusionModel {
    Simple = "Simple",
    Advanced = "Advanced",
}

/** Material representing vegetation on the exterior of an opaque construction. */
export class EnergyMaterialVegetation extends IDdEnergyBaseModel implements IEnergyMaterialVegetation {
    readonly type: string = "EnergyMaterialVegetation";
    roughness?: Roughness;
    /** Thickness of the soil layer in meters. */
    thickness?: number;
    /** Thermal conductivity of the dry soil in W/m-K. */
    conductivity?: number;
    /** Density of the dry soil in kg/m3. */
    density?: number;
    /** Specific heat of the dry soil in J/kg-K. */
    specific_heat?: number;
    /** Fraction of incident long wavelength radiation that is absorbed by the soil. Default: 0.9. */
    soil_thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the soil. Default: 0.7. */
    soil_solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    soil_visible_absorptance?: number;
    /** The height of plants in the vegetation in meters. */
    plant_height?: number;
    /** The projected leaf area per unit area of soil surface (aka. Leaf Area Index or LAI). Note that the fraction of vegetation cover is calculated directly from LAI using an empirical relation. */
    leaf_area_index?: number;
    /** The fraction of incident solar radiation that is reflected by the leaf surfaces. Solar radiation includes the visible spectrum as well as infrared and ultraviolet wavelengths. Typical values are 0.18 to 0.25. */
    leaf_reflectivity?: number;
    /** The ratio of thermal radiation emitted from leaf surfaces to that emitted by an ideal black body at the same temperature. */
    leaf_emissivity?: number;
    /** The resistance of the plants to moisture transport [s/m]. Plants with low values of stomatal resistance will result in higher evapotranspiration rates than plants with high resistance. */
    min_stomatal_resist?: number;
    /** The saturation moisture content of the soil by volume. */
    sat_vol_moist_cont?: number;
    /** The residual moisture content of the soil by volume. */
    residual_vol_moist_cont?: number;
    /** The initial moisture content of the soil by volume. */
    init_vol_moist_cont?: number;
    moist_diff_model?: MoistureDiffusionModel;

    constructor(data?: IEnergyMaterialVegetation) {
        super(data);
        if (!data) {
            this.type = "EnergyMaterialVegetation";
            this.roughness = Roughness.MediumRough;
            this.thickness = 0.1;
            this.conductivity = 0.35;
            this.density = 1100;
            this.specific_heat = 1200;
            this.soil_thermal_absorptance = 0.9;
            this.soil_solar_absorptance = 0.7;
            this.soil_visible_absorptance = 0.7;
            this.plant_height = 0.2;
            this.leaf_area_index = 1;
            this.leaf_reflectivity = 0.22;
            this.leaf_emissivity = 0.95;
            this.min_stomatal_resist = 180;
            this.sat_vol_moist_cont = 0.3;
            this.residual_vol_moist_cont = 0.01;
            this.init_vol_moist_cont = 0.01;
            this.moist_diff_model = MoistureDiffusionModel.Simple;
        }
        this._discriminator = "EnergyMaterialVegetation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyMaterialVegetation";
            this.roughness = _data["roughness"] !== undefined ? _data["roughness"] : Roughness.MediumRough;
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.1;
            this.conductivity = _data["conductivity"] !== undefined ? _data["conductivity"] : 0.35;
            this.density = _data["density"] !== undefined ? _data["density"] : 1100;
            this.specific_heat = _data["specific_heat"] !== undefined ? _data["specific_heat"] : 1200;
            this.soil_thermal_absorptance = _data["soil_thermal_absorptance"] !== undefined ? _data["soil_thermal_absorptance"] : 0.9;
            this.soil_solar_absorptance = _data["soil_solar_absorptance"] !== undefined ? _data["soil_solar_absorptance"] : 0.7;
            this.soil_visible_absorptance = _data["soil_visible_absorptance"] !== undefined ? _data["soil_visible_absorptance"] : 0.7;
            this.plant_height = _data["plant_height"] !== undefined ? _data["plant_height"] : 0.2;
            this.leaf_area_index = _data["leaf_area_index"] !== undefined ? _data["leaf_area_index"] : 1;
            this.leaf_reflectivity = _data["leaf_reflectivity"] !== undefined ? _data["leaf_reflectivity"] : 0.22;
            this.leaf_emissivity = _data["leaf_emissivity"] !== undefined ? _data["leaf_emissivity"] : 0.95;
            this.min_stomatal_resist = _data["min_stomatal_resist"] !== undefined ? _data["min_stomatal_resist"] : 180;
            this.sat_vol_moist_cont = _data["sat_vol_moist_cont"] !== undefined ? _data["sat_vol_moist_cont"] : 0.3;
            this.residual_vol_moist_cont = _data["residual_vol_moist_cont"] !== undefined ? _data["residual_vol_moist_cont"] : 0.01;
            this.init_vol_moist_cont = _data["init_vol_moist_cont"] !== undefined ? _data["init_vol_moist_cont"] : 0.01;
            this.moist_diff_model = _data["moist_diff_model"] !== undefined ? _data["moist_diff_model"] : MoistureDiffusionModel.Simple;
        }
    }

    static override fromJS(data: any): EnergyMaterialVegetation {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyMaterialVegetation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["roughness"] = this.roughness;
        data["thickness"] = this.thickness;
        data["conductivity"] = this.conductivity;
        data["density"] = this.density;
        data["specific_heat"] = this.specific_heat;
        data["soil_thermal_absorptance"] = this.soil_thermal_absorptance;
        data["soil_solar_absorptance"] = this.soil_solar_absorptance;
        data["soil_visible_absorptance"] = this.soil_visible_absorptance;
        data["plant_height"] = this.plant_height;
        data["leaf_area_index"] = this.leaf_area_index;
        data["leaf_reflectivity"] = this.leaf_reflectivity;
        data["leaf_emissivity"] = this.leaf_emissivity;
        data["min_stomatal_resist"] = this.min_stomatal_resist;
        data["sat_vol_moist_cont"] = this.sat_vol_moist_cont;
        data["residual_vol_moist_cont"] = this.residual_vol_moist_cont;
        data["init_vol_moist_cont"] = this.init_vol_moist_cont;
        data["moist_diff_model"] = this.moist_diff_model;
        super.toJSON(data);
        return data;
    }
}

/** Material representing vegetation on the exterior of an opaque construction. */
export interface IEnergyMaterialVegetation extends IIDdEnergyBaseModel {
    type?: string;
    roughness?: Roughness;
    /** Thickness of the soil layer in meters. */
    thickness?: number;
    /** Thermal conductivity of the dry soil in W/m-K. */
    conductivity?: number;
    /** Density of the dry soil in kg/m3. */
    density?: number;
    /** Specific heat of the dry soil in J/kg-K. */
    specific_heat?: number;
    /** Fraction of incident long wavelength radiation that is absorbed by the soil. Default: 0.9. */
    soil_thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the soil. Default: 0.7. */
    soil_solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the material. Default: 0.7. */
    soil_visible_absorptance?: number;
    /** The height of plants in the vegetation in meters. */
    plant_height?: number;
    /** The projected leaf area per unit area of soil surface (aka. Leaf Area Index or LAI). Note that the fraction of vegetation cover is calculated directly from LAI using an empirical relation. */
    leaf_area_index?: number;
    /** The fraction of incident solar radiation that is reflected by the leaf surfaces. Solar radiation includes the visible spectrum as well as infrared and ultraviolet wavelengths. Typical values are 0.18 to 0.25. */
    leaf_reflectivity?: number;
    /** The ratio of thermal radiation emitted from leaf surfaces to that emitted by an ideal black body at the same temperature. */
    leaf_emissivity?: number;
    /** The resistance of the plants to moisture transport [s/m]. Plants with low values of stomatal resistance will result in higher evapotranspiration rates than plants with high resistance. */
    min_stomatal_resist?: number;
    /** The saturation moisture content of the soil by volume. */
    sat_vol_moist_cont?: number;
    /** The residual moisture content of the soil by volume. */
    residual_vol_moist_cont?: number;
    /** The initial moisture content of the soil by volume. */
    init_vol_moist_cont?: number;
    moist_diff_model?: MoistureDiffusionModel;
}

/** Construction for opaque objects (Face, Shade, Door). */
export class OpaqueConstruction extends IDdEnergyBaseModel implements IOpaqueConstruction {
    /** List of opaque material definitions. The order of the materials is from exterior to interior. */
    materials!: Materials[];
    readonly type: string = "OpaqueConstruction";

    constructor(data?: IOpaqueConstruction) {
        super(data);
        if (!data) {
            this.materials = [];
            this.type = "OpaqueConstruction";
        }
        this._discriminator = "OpaqueConstruction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "OpaqueConstruction";
        }
    }

    static override fromJS(data: any): OpaqueConstruction {
        data = typeof data === 'object' ? data : {};
        let result = new OpaqueConstruction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Construction for opaque objects (Face, Shade, Door). */
export interface IOpaqueConstruction extends IIDdEnergyBaseModel {
    /** List of opaque material definitions. The order of the materials is from exterior to interior. */
    materials: Materials[];
    type?: string;
}

/** A set of constructions for floor assemblies. */
export class FloorConstructionSet extends _OpenAPIGenBaseModel implements IFloorConstructionSet {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    readonly type: string = "FloorConstructionSet";

    constructor(data?: IFloorConstructionSet) {
        super(data);
        if (!data) {
            this.type = "FloorConstructionSet";
        }
        this._discriminator = "FloorConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interior_construction = _data["interior_construction"] ? OpaqueConstruction.fromJS(_data["interior_construction"]) : <any>undefined;
            this.exterior_construction = _data["exterior_construction"] ? OpaqueConstruction.fromJS(_data["exterior_construction"]) : <any>undefined;
            this.ground_construction = _data["ground_construction"] ? OpaqueConstruction.fromJS(_data["ground_construction"]) : <any>undefined;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FloorConstructionSet";
        }
    }

    static override fromJS(data: any): FloorConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new FloorConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interior_construction"] = this.interior_construction ? this.interior_construction.toJSON() : <any>undefined;
        data["exterior_construction"] = this.exterior_construction ? this.exterior_construction.toJSON() : <any>undefined;
        data["ground_construction"] = this.ground_construction ? this.ground_construction.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for floor assemblies. */
export interface IFloorConstructionSet extends I_OpenAPIGenBaseModel {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    type?: string;
}

/** Construction for opaque objects (Face, Shade, Door). */
export class OpaqueConstructionAbridged extends IDdEnergyBaseModel implements IOpaqueConstructionAbridged {
    /** List of strings for opaque material identifiers. The order of the materials is from exterior to interior. */
    materials!: string[];
    readonly type: string = "OpaqueConstructionAbridged";

    constructor(data?: IOpaqueConstructionAbridged) {
        super(data);
        if (!data) {
            this.materials = [];
            this.type = "OpaqueConstructionAbridged";
        }
        this._discriminator = "OpaqueConstructionAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "OpaqueConstructionAbridged";
        }
    }

    static override fromJS(data: any): OpaqueConstructionAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new OpaqueConstructionAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Construction for opaque objects (Face, Shade, Door). */
export interface IOpaqueConstructionAbridged extends IIDdEnergyBaseModel {
    /** List of strings for opaque material identifiers. The order of the materials is from exterior to interior. */
    materials: string[];
    type?: string;
}

/** Construction for window objects (Aperture, Door). */
export class WindowConstructionAbridged extends IDdEnergyBaseModel implements IWindowConstructionAbridged {
    /** List of strings for glazing or gas material identifiers. The order of the materials is from exterior to interior. If a SimpleGlazSys material is used, it must be the only material in the construction. For multi-layered constructions, adjacent glass layers must be separated by one and only one gas layer. */
    materials!: string[];
    readonly type: string = "WindowConstructionAbridged";
    /** An optional identifier for a frame material that surrounds the window construction. */
    frame?: string;

    constructor(data?: IWindowConstructionAbridged) {
        super(data);
        if (!data) {
            this.materials = [];
            this.type = "WindowConstructionAbridged";
        }
        this._discriminator = "WindowConstructionAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowConstructionAbridged";
            this.frame = _data["frame"];
        }
    }

    static override fromJS(data: any): WindowConstructionAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new WindowConstructionAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        data["type"] = this.type;
        data["frame"] = this.frame;
        super.toJSON(data);
        return data;
    }
}

/** Construction for window objects (Aperture, Door). */
export interface IWindowConstructionAbridged extends IIDdEnergyBaseModel {
    /** List of strings for glazing or gas material identifiers. The order of the materials is from exterior to interior. If a SimpleGlazSys material is used, it must be the only material in the construction. For multi-layered constructions, adjacent glass layers must be separated by one and only one gas layer. */
    materials: string[];
    type?: string;
    /** An optional identifier for a frame material that surrounds the window construction. */
    frame?: string;
}

/** Construction for Shade objects. */
export class ShadeConstruction extends IDdEnergyBaseModel implements IShadeConstruction {
    readonly type: string = "ShadeConstruction";
    /** A number for the solar reflectance of the construction. */
    solar_reflectance?: number;
    /** A number for the visible reflectance of the construction. */
    visible_reflectance?: number;
    /** Boolean to note whether the reflection off the shade is diffuse (False) or specular (True). Set to True if the construction is representing a glass facade or a mirror material. */
    is_specular?: boolean;

    constructor(data?: IShadeConstruction) {
        super(data);
        if (!data) {
            this.type = "ShadeConstruction";
            this.solar_reflectance = 0.2;
            this.visible_reflectance = 0.2;
            this.is_specular = false;
        }
        this._discriminator = "ShadeConstruction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadeConstruction";
            this.solar_reflectance = _data["solar_reflectance"] !== undefined ? _data["solar_reflectance"] : 0.2;
            this.visible_reflectance = _data["visible_reflectance"] !== undefined ? _data["visible_reflectance"] : 0.2;
            this.is_specular = _data["is_specular"] !== undefined ? _data["is_specular"] : false;
        }
    }

    static override fromJS(data: any): ShadeConstruction {
        data = typeof data === 'object' ? data : {};
        let result = new ShadeConstruction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["solar_reflectance"] = this.solar_reflectance;
        data["visible_reflectance"] = this.visible_reflectance;
        data["is_specular"] = this.is_specular;
        super.toJSON(data);
        return data;
    }
}

/** Construction for Shade objects. */
export interface IShadeConstruction extends IIDdEnergyBaseModel {
    type?: string;
    /** A number for the solar reflectance of the construction. */
    solar_reflectance?: number;
    /** A number for the visible reflectance of the construction. */
    visible_reflectance?: number;
    /** Boolean to note whether the reflection off the shade is diffuse (False) or specular (True). Set to True if the construction is representing a glass facade or a mirror material. */
    is_specular?: boolean;
}

/** Construction for Air Boundary objects. */
export class AirBoundaryConstructionAbridged extends IDdEnergyBaseModel implements IAirBoundaryConstructionAbridged {
    readonly type: string = "AirBoundaryConstructionAbridged";
    /** A positive number for the amount of air mixing between Rooms across the air boundary surface [m3/s-m2]. Default: 0.1 corresponds to average indoor air speeds of 0.1 m/s (roughly 20 fpm), which is typical of what would be induced by a HVAC system. */
    air_mixing_per_area?: number;
    /** Identifier of a fractional schedule for the air mixing schedule across the construction. If unspecified, an Always On schedule will be assumed. */
    air_mixing_schedule?: string;

    constructor(data?: IAirBoundaryConstructionAbridged) {
        super(data);
        if (!data) {
            this.type = "AirBoundaryConstructionAbridged";
            this.air_mixing_per_area = 0.1;
        }
        this._discriminator = "AirBoundaryConstructionAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "AirBoundaryConstructionAbridged";
            this.air_mixing_per_area = _data["air_mixing_per_area"] !== undefined ? _data["air_mixing_per_area"] : 0.1;
            this.air_mixing_schedule = _data["air_mixing_schedule"];
        }
    }

    static override fromJS(data: any): AirBoundaryConstructionAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new AirBoundaryConstructionAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["air_mixing_per_area"] = this.air_mixing_per_area;
        data["air_mixing_schedule"] = this.air_mixing_schedule;
        super.toJSON(data);
        return data;
    }
}

/** Construction for Air Boundary objects. */
export interface IAirBoundaryConstructionAbridged extends IIDdEnergyBaseModel {
    type?: string;
    /** A positive number for the amount of air mixing between Rooms across the air boundary surface [m3/s-m2]. Default: 0.1 corresponds to average indoor air speeds of 0.1 m/s (roughly 20 fpm), which is typical of what would be induced by a HVAC system. */
    air_mixing_per_area?: number;
    /** Identifier of a fractional schedule for the air mixing schedule across the construction. If unspecified, an Always On schedule will be assumed. */
    air_mixing_schedule?: string;
}

/** A set of constructions for wall, floor, or roof assemblies. */
export class _FaceSubSetAbridged extends _OpenAPIGenBaseModel implements I_FaceSubSetAbridged {
    /** Identifier for an OpaqueConstruction for faces with a Surface or Adiabatic boundary condition. */
    interior_construction?: string;
    /** Identifier for an OpaqueConstruction for faces with an Outdoors boundary condition. */
    exterior_construction?: string;
    /** Identifier for an OpaqueConstruction for faces with a Ground boundary condition. */
    ground_construction?: string;
    readonly type: string = "_FaceSubSetAbridged";

    constructor(data?: I_FaceSubSetAbridged) {
        super(data);
        if (!data) {
            this.type = "_FaceSubSetAbridged";
        }
        this._discriminator = "_FaceSubSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interior_construction = _data["interior_construction"];
            this.exterior_construction = _data["exterior_construction"];
            this.ground_construction = _data["ground_construction"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_FaceSubSetAbridged";
        }
    }

    static override fromJS(data: any): _FaceSubSetAbridged {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "WallConstructionSetAbridged") {
            let result = new WallConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorConstructionSetAbridged") {
            let result = new FloorConstructionSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingConstructionSetAbridged") {
            let result = new RoofCeilingConstructionSetAbridged();
            result.init(data);
            return result;
        }
        let result = new _FaceSubSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interior_construction"] = this.interior_construction;
        data["exterior_construction"] = this.exterior_construction;
        data["ground_construction"] = this.ground_construction;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for wall, floor, or roof assemblies. */
export interface I_FaceSubSetAbridged extends I_OpenAPIGenBaseModel {
    /** Identifier for an OpaqueConstruction for faces with a Surface or Adiabatic boundary condition. */
    interior_construction?: string;
    /** Identifier for an OpaqueConstruction for faces with an Outdoors boundary condition. */
    exterior_construction?: string;
    /** Identifier for an OpaqueConstruction for faces with a Ground boundary condition. */
    ground_construction?: string;
    type?: string;
}

/** A set of constructions for wall assemblies. */
export class WallConstructionSetAbridged extends _FaceSubSetAbridged implements IWallConstructionSetAbridged {
    readonly type: string = "WallConstructionSetAbridged";

    constructor(data?: IWallConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "WallConstructionSetAbridged";
        }
        this._discriminator = "WallConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WallConstructionSetAbridged";
        }
    }

    static override fromJS(data: any): WallConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new WallConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for wall assemblies. */
export interface IWallConstructionSetAbridged extends I_FaceSubSetAbridged {
    type?: string;
}

/** A set of constructions for floor assemblies. */
export class FloorConstructionSetAbridged extends _FaceSubSetAbridged implements IFloorConstructionSetAbridged {
    readonly type: string = "FloorConstructionSetAbridged";

    constructor(data?: IFloorConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "FloorConstructionSetAbridged";
        }
        this._discriminator = "FloorConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FloorConstructionSetAbridged";
        }
    }

    static override fromJS(data: any): FloorConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FloorConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for floor assemblies. */
export interface IFloorConstructionSetAbridged extends I_FaceSubSetAbridged {
    type?: string;
}

/** A set of constructions for roof and ceiling assemblies. */
export class RoofCeilingConstructionSetAbridged extends _FaceSubSetAbridged implements IRoofCeilingConstructionSetAbridged {
    readonly type: string = "RoofCeilingConstructionSetAbridged";

    constructor(data?: IRoofCeilingConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "RoofCeilingConstructionSetAbridged";
        }
        this._discriminator = "RoofCeilingConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoofCeilingConstructionSetAbridged";
        }
    }

    static override fromJS(data: any): RoofCeilingConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RoofCeilingConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for roof and ceiling assemblies. */
export interface IRoofCeilingConstructionSetAbridged extends I_FaceSubSetAbridged {
    type?: string;
}

/** A set of constructions for aperture assemblies. */
export class ApertureConstructionSetAbridged extends _OpenAPIGenBaseModel implements IApertureConstructionSetAbridged {
    readonly type: string = "ApertureConstructionSetAbridged";
    /** Identifier for a WindowConstruction for all apertures with a Surface boundary condition. */
    interior_construction?: string;
    /** Identifier for a WindowConstruction for apertures with an Outdoors boundary condition, False is_operable property, and a Wall face type for their parent face. */
    window_construction?: string;
    /** Identifier for a WindowConstruction for apertures with a Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_construction?: string;
    /** Identifier for a WindowConstruction for all apertures with an Outdoors boundary condition and True is_operable property. */
    operable_construction?: string;

    constructor(data?: IApertureConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "ApertureConstructionSetAbridged";
        }
        this._discriminator = "ApertureConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureConstructionSetAbridged";
            this.interior_construction = _data["interior_construction"];
            this.window_construction = _data["window_construction"];
            this.skylight_construction = _data["skylight_construction"];
            this.operable_construction = _data["operable_construction"];
        }
    }

    static override fromJS(data: any): ApertureConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["interior_construction"] = this.interior_construction;
        data["window_construction"] = this.window_construction;
        data["skylight_construction"] = this.skylight_construction;
        data["operable_construction"] = this.operable_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for aperture assemblies. */
export interface IApertureConstructionSetAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier for a WindowConstruction for all apertures with a Surface boundary condition. */
    interior_construction?: string;
    /** Identifier for a WindowConstruction for apertures with an Outdoors boundary condition, False is_operable property, and a Wall face type for their parent face. */
    window_construction?: string;
    /** Identifier for a WindowConstruction for apertures with a Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_construction?: string;
    /** Identifier for a WindowConstruction for all apertures with an Outdoors boundary condition and True is_operable property. */
    operable_construction?: string;
}

/** A set of constructions for door assemblies. */
export class DoorConstructionSetAbridged extends _OpenAPIGenBaseModel implements IDoorConstructionSetAbridged {
    readonly type: string = "DoorConstructionSetAbridged";
    /** Identifier for an OpaqueConstruction for all opaque doors with a Surface boundary condition. */
    interior_construction?: string;
    /** Identifier for an OpaqueConstruction for opaque doors with an Outdoors boundary condition and a Wall face type for their parent face. */
    exterior_construction?: string;
    /** Identifier for an OpaqueConstruction for opaque doors with an Outdoors boundary condition and a RoofCeiling or Floor type for their parent face. */
    overhead_construction?: string;
    /** Identifier for a WindowConstruction for all glass doors with an Outdoors boundary condition. */
    exterior_glass_construction?: string;
    /** Identifier for a WindowConstruction for all glass doors with a Surface boundary condition. */
    interior_glass_construction?: string;

    constructor(data?: IDoorConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "DoorConstructionSetAbridged";
        }
        this._discriminator = "DoorConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorConstructionSetAbridged";
            this.interior_construction = _data["interior_construction"];
            this.exterior_construction = _data["exterior_construction"];
            this.overhead_construction = _data["overhead_construction"];
            this.exterior_glass_construction = _data["exterior_glass_construction"];
            this.interior_glass_construction = _data["interior_glass_construction"];
        }
    }

    static override fromJS(data: any): DoorConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new DoorConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["interior_construction"] = this.interior_construction;
        data["exterior_construction"] = this.exterior_construction;
        data["overhead_construction"] = this.overhead_construction;
        data["exterior_glass_construction"] = this.exterior_glass_construction;
        data["interior_glass_construction"] = this.interior_glass_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for door assemblies. */
export interface IDoorConstructionSetAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier for an OpaqueConstruction for all opaque doors with a Surface boundary condition. */
    interior_construction?: string;
    /** Identifier for an OpaqueConstruction for opaque doors with an Outdoors boundary condition and a Wall face type for their parent face. */
    exterior_construction?: string;
    /** Identifier for an OpaqueConstruction for opaque doors with an Outdoors boundary condition and a RoofCeiling or Floor type for their parent face. */
    overhead_construction?: string;
    /** Identifier for a WindowConstruction for all glass doors with an Outdoors boundary condition. */
    exterior_glass_construction?: string;
    /** Identifier for a WindowConstruction for all glass doors with a Surface boundary condition. */
    interior_glass_construction?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class GlobalConstructionSet extends _OpenAPIGenBaseModel implements IGlobalConstructionSet {
    readonly type: string = "GlobalConstructionSet";
    /** Global Honeybee Energy materials. */
    readonly materials?: materials[];
    /** Global Honeybee Energy constructions. */
    readonly constructions?: Constructions[];
    /** Global Honeybee WallConstructionSet. */
    readonly wall_set?: WallConstructionSetAbridged;
    /** Global Honeybee FloorConstructionSet. */
    readonly floor_set?: FloorConstructionSetAbridged;
    /** Global Honeybee RoofCeilingConstructionSet. */
    readonly roof_ceiling_set?: RoofCeilingConstructionSetAbridged;
    /** Global Honeybee ApertureConstructionSet. */
    readonly aperture_set?: ApertureConstructionSetAbridged;
    /** Global Honeybee DoorConstructionSet. */
    readonly door_set?: DoorConstructionSetAbridged;
    /** Global Honeybee Construction for building-attached Shades. */
    readonly shade_construction?: string;
    /** Global Honeybee Construction for context Shades. */
    readonly context_construction?: string;
    /** Global Honeybee Construction for AirBoundary Faces. */
    readonly air_boundary_construction?: string;

    constructor(data?: IGlobalConstructionSet) {
        super(data);
        if (!data) {
            this.type = "GlobalConstructionSet";
            this.shade_construction = "Generic Shade";
            this.context_construction = "Generic Context";
            this.air_boundary_construction = "Generic Air Boundary";
        }
        this._discriminator = "GlobalConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GlobalConstructionSet";
            if (Array.isArray(_data["materials"])) {
                (<any>this).materials = [] as any;
                for (let item of _data["materials"])
                    (<any>this).materials!.push(item);
            }
            if (Array.isArray(_data["constructions"])) {
                (<any>this).constructions = [] as any;
                for (let item of _data["constructions"])
                    (<any>this).constructions!.push(item);
            }
            (<any>this).wall_set = _data["wall_set"] ? WallConstructionSetAbridged.fromJS(_data["wall_set"]) : <any>undefined;
            (<any>this).floor_set = _data["floor_set"] ? FloorConstructionSetAbridged.fromJS(_data["floor_set"]) : <any>undefined;
            (<any>this).roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingConstructionSetAbridged.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            (<any>this).aperture_set = _data["aperture_set"] ? ApertureConstructionSetAbridged.fromJS(_data["aperture_set"]) : <any>undefined;
            (<any>this).door_set = _data["door_set"] ? DoorConstructionSetAbridged.fromJS(_data["door_set"]) : <any>undefined;
            (<any>this).shade_construction = _data["shade_construction"] !== undefined ? _data["shade_construction"] : "Generic Shade";
            (<any>this).context_construction = _data["context_construction"] !== undefined ? _data["context_construction"] : "Generic Context";
            (<any>this).air_boundary_construction = _data["air_boundary_construction"] !== undefined ? _data["air_boundary_construction"] : "Generic Air Boundary";
        }
    }

    static override fromJS(data: any): GlobalConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        if (Array.isArray(this.constructions)) {
            data["constructions"] = [];
            for (let item of this.constructions)
                data["constructions"].push(item);
        }
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_construction"] = this.shade_construction;
        data["context_construction"] = this.context_construction;
        data["air_boundary_construction"] = this.air_boundary_construction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IGlobalConstructionSet extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Global Honeybee Energy materials. */
    materials?: materials[];
    /** Global Honeybee Energy constructions. */
    constructions?: Constructions[];
    /** Global Honeybee WallConstructionSet. */
    wall_set?: WallConstructionSetAbridged;
    /** Global Honeybee FloorConstructionSet. */
    floor_set?: FloorConstructionSetAbridged;
    /** Global Honeybee RoofCeilingConstructionSet. */
    roof_ceiling_set?: RoofCeilingConstructionSetAbridged;
    /** Global Honeybee ApertureConstructionSet. */
    aperture_set?: ApertureConstructionSetAbridged;
    /** Global Honeybee DoorConstructionSet. */
    door_set?: DoorConstructionSetAbridged;
    /** Global Honeybee Construction for building-attached Shades. */
    shade_construction?: string;
    /** Global Honeybee Construction for context Shades. */
    context_construction?: string;
    /** Global Honeybee Construction for AirBoundary Faces. */
    air_boundary_construction?: string;
}

/** A set of constructions for different surface types and boundary conditions. */
export class ConstructionSetAbridged extends IDdEnergyBaseModel implements IConstructionSetAbridged {
    readonly type: string = "ConstructionSetAbridged";
    /** A WallConstructionSetAbridged object for this ConstructionSet. */
    wall_set?: WallConstructionSetAbridged;
    /** A FloorConstructionSetAbridged object for this ConstructionSet. */
    floor_set?: FloorConstructionSetAbridged;
    /** A RoofCeilingConstructionSetAbridged object for this ConstructionSet. */
    roof_ceiling_set?: RoofCeilingConstructionSetAbridged;
    /** A ApertureConstructionSetAbridged object for this ConstructionSet. */
    aperture_set?: ApertureConstructionSetAbridged;
    /** A DoorConstructionSetAbridged object for this ConstructionSet. */
    door_set?: DoorConstructionSetAbridged;
    /** The identifier of a ShadeConstruction to set the reflectance properties of all outdoor shades of all objects to which this ConstructionSet is assigned. */
    shade_construction?: string;
    /** The identifier of an AirBoundaryConstruction or OpaqueConstruction to set the properties of Faces with an AirBoundary type. */
    air_boundary_construction?: string;

    constructor(data?: IConstructionSetAbridged) {
        super(data);
        if (!data) {
            this.type = "ConstructionSetAbridged";
        }
        this._discriminator = "ConstructionSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ConstructionSetAbridged";
            this.wall_set = _data["wall_set"] ? WallConstructionSetAbridged.fromJS(_data["wall_set"]) : <any>undefined;
            this.floor_set = _data["floor_set"] ? FloorConstructionSetAbridged.fromJS(_data["floor_set"]) : <any>undefined;
            this.roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingConstructionSetAbridged.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            this.aperture_set = _data["aperture_set"] ? ApertureConstructionSetAbridged.fromJS(_data["aperture_set"]) : <any>undefined;
            this.door_set = _data["door_set"] ? DoorConstructionSetAbridged.fromJS(_data["door_set"]) : <any>undefined;
            this.shade_construction = _data["shade_construction"];
            this.air_boundary_construction = _data["air_boundary_construction"];
        }
    }

    static override fromJS(data: any): ConstructionSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructionSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_construction"] = this.shade_construction;
        data["air_boundary_construction"] = this.air_boundary_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for different surface types and boundary conditions. */
export interface IConstructionSetAbridged extends IIDdEnergyBaseModel {
    type?: string;
    /** A WallConstructionSetAbridged object for this ConstructionSet. */
    wall_set?: WallConstructionSetAbridged;
    /** A FloorConstructionSetAbridged object for this ConstructionSet. */
    floor_set?: FloorConstructionSetAbridged;
    /** A RoofCeilingConstructionSetAbridged object for this ConstructionSet. */
    roof_ceiling_set?: RoofCeilingConstructionSetAbridged;
    /** A ApertureConstructionSetAbridged object for this ConstructionSet. */
    aperture_set?: ApertureConstructionSetAbridged;
    /** A DoorConstructionSetAbridged object for this ConstructionSet. */
    door_set?: DoorConstructionSetAbridged;
    /** The identifier of a ShadeConstruction to set the reflectance properties of all outdoor shades of all objects to which this ConstructionSet is assigned. */
    shade_construction?: string;
    /** The identifier of an AirBoundaryConstruction or OpaqueConstruction to set the properties of Faces with an AirBoundary type. */
    air_boundary_construction?: string;
}

/** A set of constructions for wall assemblies. */
export class WallConstructionSet extends _OpenAPIGenBaseModel implements IWallConstructionSet {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    readonly type: string = "WallConstructionSet";

    constructor(data?: IWallConstructionSet) {
        super(data);
        if (!data) {
            this.type = "WallConstructionSet";
        }
        this._discriminator = "WallConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interior_construction = _data["interior_construction"] ? OpaqueConstruction.fromJS(_data["interior_construction"]) : <any>undefined;
            this.exterior_construction = _data["exterior_construction"] ? OpaqueConstruction.fromJS(_data["exterior_construction"]) : <any>undefined;
            this.ground_construction = _data["ground_construction"] ? OpaqueConstruction.fromJS(_data["ground_construction"]) : <any>undefined;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WallConstructionSet";
        }
    }

    static override fromJS(data: any): WallConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new WallConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interior_construction"] = this.interior_construction ? this.interior_construction.toJSON() : <any>undefined;
        data["exterior_construction"] = this.exterior_construction ? this.exterior_construction.toJSON() : <any>undefined;
        data["ground_construction"] = this.ground_construction ? this.ground_construction.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for wall assemblies. */
export interface IWallConstructionSet extends I_OpenAPIGenBaseModel {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    type?: string;
}

/** A set of constructions for roof and ceiling assemblies. */
export class RoofCeilingConstructionSet extends _OpenAPIGenBaseModel implements IRoofCeilingConstructionSet {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    readonly type: string = "RoofCeilingConstructionSet";

    constructor(data?: IRoofCeilingConstructionSet) {
        super(data);
        if (!data) {
            this.type = "RoofCeilingConstructionSet";
        }
        this._discriminator = "RoofCeilingConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interior_construction = _data["interior_construction"] ? OpaqueConstruction.fromJS(_data["interior_construction"]) : <any>undefined;
            this.exterior_construction = _data["exterior_construction"] ? OpaqueConstruction.fromJS(_data["exterior_construction"]) : <any>undefined;
            this.ground_construction = _data["ground_construction"] ? OpaqueConstruction.fromJS(_data["ground_construction"]) : <any>undefined;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoofCeilingConstructionSet";
        }
    }

    static override fromJS(data: any): RoofCeilingConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new RoofCeilingConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interior_construction"] = this.interior_construction ? this.interior_construction.toJSON() : <any>undefined;
        data["exterior_construction"] = this.exterior_construction ? this.exterior_construction.toJSON() : <any>undefined;
        data["ground_construction"] = this.ground_construction ? this.ground_construction.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for roof and ceiling assemblies. */
export interface IRoofCeilingConstructionSet extends I_OpenAPIGenBaseModel {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    type?: string;
}

/** Describe an entire glazing system rather than individual layers. Used when only very limited information is available on the glazing layers or when specific performance levels are being targeted. */
export class EnergyWindowMaterialSimpleGlazSys extends IDdEnergyBaseModel implements IEnergyWindowMaterialSimpleGlazSys {
    /** The overall heat transfer coefficient for window system in W/m2-K. Note that constructions with U-values above 5.8 should not be assigned to skylights as this implies the resistance of the window is negative when air films are subtracted. */
    u_factor!: number;
    /** Unit-less quantity for the Solar Heat Gain Coefficient (solar transmittance + conduction) at normal incidence and vertical orientation. */
    shgc!: number;
    readonly type: string = "EnergyWindowMaterialSimpleGlazSys";
    /** The fraction of visible light falling on the window that makes it through the glass at normal incidence. */
    vt?: number;

    constructor(data?: IEnergyWindowMaterialSimpleGlazSys) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialSimpleGlazSys";
            this.vt = 0.54;
        }
        this._discriminator = "EnergyWindowMaterialSimpleGlazSys";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.u_factor = _data["u_factor"];
            this.shgc = _data["shgc"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialSimpleGlazSys";
            this.vt = _data["vt"] !== undefined ? _data["vt"] : 0.54;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialSimpleGlazSys {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialSimpleGlazSys();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["u_factor"] = this.u_factor;
        data["shgc"] = this.shgc;
        data["type"] = this.type;
        data["vt"] = this.vt;
        super.toJSON(data);
        return data;
    }
}

/** Describe an entire glazing system rather than individual layers. Used when only very limited information is available on the glazing layers or when specific performance levels are being targeted. */
export interface IEnergyWindowMaterialSimpleGlazSys extends IIDdEnergyBaseModel {
    /** The overall heat transfer coefficient for window system in W/m2-K. Note that constructions with U-values above 5.8 should not be assigned to skylights as this implies the resistance of the window is negative when air films are subtracted. */
    u_factor: number;
    /** Unit-less quantity for the Solar Heat Gain Coefficient (solar transmittance + conduction) at normal incidence and vertical orientation. */
    shgc: number;
    type?: string;
    /** The fraction of visible light falling on the window that makes it through the glass at normal incidence. */
    vt?: number;
}

/** Create single layer of custom gas. */
export class EnergyWindowMaterialGasCustom extends IDdEnergyBaseModel implements IEnergyWindowMaterialGasCustom {
    /** The A coefficient for gas conductivity in W/(m-K). */
    conductivity_coeff_a!: number;
    /** The A coefficient for gas viscosity in kg/(m-s). */
    viscosity_coeff_a!: number;
    /** The A coefficient for gas specific heat in J/(kg-K). */
    specific_heat_coeff_a!: number;
    /** The specific heat ratio for gas. */
    specific_heat_ratio!: number;
    /** The molecular weight for gas in g/mol. */
    molecular_weight!: number;
    readonly type: string = "EnergyWindowMaterialGasCustom";
    /** Thickness of the gas layer in meters. Default: 0.0125. */
    thickness?: number;
    /** The B coefficient for gas conductivity in W/(m-K2). */
    conductivity_coeff_b?: number;
    /** The C coefficient for gas conductivity in W/(m-K3). */
    conductivity_coeff_c?: number;
    /** The B coefficient for gas viscosity in kg/(m-s-K). */
    viscosity_coeff_b?: number;
    /** The C coefficient for gas viscosity in kg/(m-s-K2). */
    viscosity_coeff_c?: number;
    /** The B coefficient for gas specific heat in J/(kg-K2). */
    specific_heat_coeff_b?: number;
    /** The C coefficient for gas specific heat in J/(kg-K3). */
    specific_heat_coeff_c?: number;

    constructor(data?: IEnergyWindowMaterialGasCustom) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialGasCustom";
            this.thickness = 0.0125;
            this.conductivity_coeff_b = 0;
            this.conductivity_coeff_c = 0;
            this.viscosity_coeff_b = 0;
            this.viscosity_coeff_c = 0;
            this.specific_heat_coeff_b = 0;
            this.specific_heat_coeff_c = 0;
        }
        this._discriminator = "EnergyWindowMaterialGasCustom";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.conductivity_coeff_a = _data["conductivity_coeff_a"];
            this.viscosity_coeff_a = _data["viscosity_coeff_a"];
            this.specific_heat_coeff_a = _data["specific_heat_coeff_a"];
            this.specific_heat_ratio = _data["specific_heat_ratio"];
            this.molecular_weight = _data["molecular_weight"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialGasCustom";
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.0125;
            this.conductivity_coeff_b = _data["conductivity_coeff_b"] !== undefined ? _data["conductivity_coeff_b"] : 0;
            this.conductivity_coeff_c = _data["conductivity_coeff_c"] !== undefined ? _data["conductivity_coeff_c"] : 0;
            this.viscosity_coeff_b = _data["viscosity_coeff_b"] !== undefined ? _data["viscosity_coeff_b"] : 0;
            this.viscosity_coeff_c = _data["viscosity_coeff_c"] !== undefined ? _data["viscosity_coeff_c"] : 0;
            this.specific_heat_coeff_b = _data["specific_heat_coeff_b"] !== undefined ? _data["specific_heat_coeff_b"] : 0;
            this.specific_heat_coeff_c = _data["specific_heat_coeff_c"] !== undefined ? _data["specific_heat_coeff_c"] : 0;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialGasCustom {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialGasCustom();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conductivity_coeff_a"] = this.conductivity_coeff_a;
        data["viscosity_coeff_a"] = this.viscosity_coeff_a;
        data["specific_heat_coeff_a"] = this.specific_heat_coeff_a;
        data["specific_heat_ratio"] = this.specific_heat_ratio;
        data["molecular_weight"] = this.molecular_weight;
        data["type"] = this.type;
        data["thickness"] = this.thickness;
        data["conductivity_coeff_b"] = this.conductivity_coeff_b;
        data["conductivity_coeff_c"] = this.conductivity_coeff_c;
        data["viscosity_coeff_b"] = this.viscosity_coeff_b;
        data["viscosity_coeff_c"] = this.viscosity_coeff_c;
        data["specific_heat_coeff_b"] = this.specific_heat_coeff_b;
        data["specific_heat_coeff_c"] = this.specific_heat_coeff_c;
        super.toJSON(data);
        return data;
    }
}

/** Create single layer of custom gas. */
export interface IEnergyWindowMaterialGasCustom extends IIDdEnergyBaseModel {
    /** The A coefficient for gas conductivity in W/(m-K). */
    conductivity_coeff_a: number;
    /** The A coefficient for gas viscosity in kg/(m-s). */
    viscosity_coeff_a: number;
    /** The A coefficient for gas specific heat in J/(kg-K). */
    specific_heat_coeff_a: number;
    /** The specific heat ratio for gas. */
    specific_heat_ratio: number;
    /** The molecular weight for gas in g/mol. */
    molecular_weight: number;
    type?: string;
    /** Thickness of the gas layer in meters. Default: 0.0125. */
    thickness?: number;
    /** The B coefficient for gas conductivity in W/(m-K2). */
    conductivity_coeff_b?: number;
    /** The C coefficient for gas conductivity in W/(m-K3). */
    conductivity_coeff_c?: number;
    /** The B coefficient for gas viscosity in kg/(m-s-K). */
    viscosity_coeff_b?: number;
    /** The C coefficient for gas viscosity in kg/(m-s-K2). */
    viscosity_coeff_c?: number;
    /** The B coefficient for gas specific heat in J/(kg-K2). */
    specific_heat_coeff_b?: number;
    /** The C coefficient for gas specific heat in J/(kg-K3). */
    specific_heat_coeff_c?: number;
}

/** Create a mixture of two to four different gases to fill the panes of multiple pane windows. */
export class EnergyWindowMaterialGasMixture extends IDdEnergyBaseModel implements IEnergyWindowMaterialGasMixture {
    /** List of gases in the gas mixture. */
    gas_types!: GasType[];
    /** A list of fractional numbers describing the volumetric fractions of gas types in the mixture. This list must align with the gas_types list and must sum to 1. */
    gas_fractions!: number[];
    readonly type: string = "EnergyWindowMaterialGasMixture";
    /** The thickness of the gas mixture layer in meters. */
    thickness?: number;

    constructor(data?: IEnergyWindowMaterialGasMixture) {
        super(data);
        if (!data) {
            this.gas_types = [];
            this.gas_fractions = [];
            this.type = "EnergyWindowMaterialGasMixture";
            this.thickness = 0.0125;
        }
        this._discriminator = "EnergyWindowMaterialGasMixture";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["gas_types"])) {
                this.gas_types = [] as any;
                for (let item of _data["gas_types"])
                    this.gas_types!.push(item);
            }
            if (Array.isArray(_data["gas_fractions"])) {
                this.gas_fractions = [] as any;
                for (let item of _data["gas_fractions"])
                    this.gas_fractions!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialGasMixture";
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.0125;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialGasMixture {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialGasMixture();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gas_types)) {
            data["gas_types"] = [];
            for (let item of this.gas_types)
                data["gas_types"].push(item);
        }
        if (Array.isArray(this.gas_fractions)) {
            data["gas_fractions"] = [];
            for (let item of this.gas_fractions)
                data["gas_fractions"].push(item);
        }
        data["type"] = this.type;
        data["thickness"] = this.thickness;
        super.toJSON(data);
        return data;
    }
}

/** Create a mixture of two to four different gases to fill the panes of multiple pane windows. */
export interface IEnergyWindowMaterialGasMixture extends IIDdEnergyBaseModel {
    /** List of gases in the gas mixture. */
    gas_types: GasType[];
    /** A list of fractional numbers describing the volumetric fractions of gas types in the mixture. This list must align with the gas_types list and must sum to 1. */
    gas_fractions: number[];
    type?: string;
    /** The thickness of the gas mixture layer in meters. */
    thickness?: number;
}

/** Opaque material representing a layer within an opaque construction. */
export class EnergyWindowFrame extends IDdEnergyBaseModel implements IEnergyWindowFrame {
    /** Number for the width of frame in plane of window [m]. The frame width is assumed to be the same on all sides of window.. */
    width!: number;
    /** Number for the thermal conductance of the frame material measured from inside to outside of the frame surface (no air films) and taking 2D conduction effects into account [W/m2-K]. */
    conductance!: number;
    readonly type: string = "EnergyWindowFrame";
    /** Number between 0 and 4 for the ratio of the glass conductance near the frame (excluding air films) divided by the glass conductance at the center of the glazing (excluding air films). This is used only for multi-pane glazing constructions. This ratio should usually be greater than 1.0 since the spacer material that separates the glass panes is usually more conductive than the gap between panes. A value of 1 effectively indicates no spacer. Values should usually be obtained from the LBNL WINDOW program so that the unique characteristics of the window construction can be accounted for. */
    edge_to_center_ratio?: number;
    /** Number for the distance that the frame projects outward from the outside face of the glazing [m]. This is used to calculate shadowing of frame onto glass, solar absorbed by the frame, IR emitted and absorbed by the frame, and convection from frame. */
    outside_projection?: number;
    /** Number for the distance that the frame projects inward from the inside face of the glazing [m]. This is used to calculate solar absorbed by the frame, IR emitted and absorbed by the frame, and convection from frame. */
    inside_projection?: number;
    /** Fraction of incident long wavelength radiation that is absorbed by the frame material. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the frame material. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the frame material. */
    visible_absorptance?: number;

    constructor(data?: IEnergyWindowFrame) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowFrame";
            this.edge_to_center_ratio = 1;
            this.outside_projection = 0;
            this.inside_projection = 0;
            this.thermal_absorptance = 0.9;
            this.solar_absorptance = 0.7;
            this.visible_absorptance = 0.7;
        }
        this._discriminator = "EnergyWindowFrame";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.conductance = _data["conductance"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowFrame";
            this.edge_to_center_ratio = _data["edge_to_center_ratio"] !== undefined ? _data["edge_to_center_ratio"] : 1;
            this.outside_projection = _data["outside_projection"] !== undefined ? _data["outside_projection"] : 0;
            this.inside_projection = _data["inside_projection"] !== undefined ? _data["inside_projection"] : 0;
            this.thermal_absorptance = _data["thermal_absorptance"] !== undefined ? _data["thermal_absorptance"] : 0.9;
            this.solar_absorptance = _data["solar_absorptance"] !== undefined ? _data["solar_absorptance"] : 0.7;
            this.visible_absorptance = _data["visible_absorptance"] !== undefined ? _data["visible_absorptance"] : 0.7;
        }
    }

    static override fromJS(data: any): EnergyWindowFrame {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowFrame();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["conductance"] = this.conductance;
        data["type"] = this.type;
        data["edge_to_center_ratio"] = this.edge_to_center_ratio;
        data["outside_projection"] = this.outside_projection;
        data["inside_projection"] = this.inside_projection;
        data["thermal_absorptance"] = this.thermal_absorptance;
        data["solar_absorptance"] = this.solar_absorptance;
        data["visible_absorptance"] = this.visible_absorptance;
        super.toJSON(data);
        return data;
    }
}

/** Opaque material representing a layer within an opaque construction. */
export interface IEnergyWindowFrame extends IIDdEnergyBaseModel {
    /** Number for the width of frame in plane of window [m]. The frame width is assumed to be the same on all sides of window.. */
    width: number;
    /** Number for the thermal conductance of the frame material measured from inside to outside of the frame surface (no air films) and taking 2D conduction effects into account [W/m2-K]. */
    conductance: number;
    type?: string;
    /** Number between 0 and 4 for the ratio of the glass conductance near the frame (excluding air films) divided by the glass conductance at the center of the glazing (excluding air films). This is used only for multi-pane glazing constructions. This ratio should usually be greater than 1.0 since the spacer material that separates the glass panes is usually more conductive than the gap between panes. A value of 1 effectively indicates no spacer. Values should usually be obtained from the LBNL WINDOW program so that the unique characteristics of the window construction can be accounted for. */
    edge_to_center_ratio?: number;
    /** Number for the distance that the frame projects outward from the outside face of the glazing [m]. This is used to calculate shadowing of frame onto glass, solar absorbed by the frame, IR emitted and absorbed by the frame, and convection from frame. */
    outside_projection?: number;
    /** Number for the distance that the frame projects inward from the inside face of the glazing [m]. This is used to calculate solar absorbed by the frame, IR emitted and absorbed by the frame, and convection from frame. */
    inside_projection?: number;
    /** Fraction of incident long wavelength radiation that is absorbed by the frame material. */
    thermal_absorptance?: number;
    /** Fraction of incident solar radiation absorbed by the frame material. */
    solar_absorptance?: number;
    /** Fraction of incident visible wavelength radiation absorbed by the frame material. */
    visible_absorptance?: number;
}

/** Construction for window objects (Aperture, Door). */
export class WindowConstruction extends IDdEnergyBaseModel implements IWindowConstruction {
    /** List of glazing and gas material definitions. The order of the materials is from exterior to interior. If a SimpleGlazSys material is used, it must be the only material in the construction. For multi-layered constructions, adjacent glass layers must be separated by one and only one gas layer. */
    materials!: materials2[];
    readonly type: string = "WindowConstruction";
    /** An optional window frame material for the frame that surrounds the window construction. */
    frame?: EnergyWindowFrame;

    constructor(data?: IWindowConstruction) {
        super(data);
        if (!data) {
            this.materials = [];
            this.type = "WindowConstruction";
        }
        this._discriminator = "WindowConstruction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowConstruction";
            this.frame = _data["frame"] ? EnergyWindowFrame.fromJS(_data["frame"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): WindowConstruction {
        data = typeof data === 'object' ? data : {};
        let result = new WindowConstruction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        data["type"] = this.type;
        data["frame"] = this.frame ? this.frame.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Construction for window objects (Aperture, Door). */
export interface IWindowConstruction extends IIDdEnergyBaseModel {
    /** List of glazing and gas material definitions. The order of the materials is from exterior to interior. If a SimpleGlazSys material is used, it must be the only material in the construction. For multi-layered constructions, adjacent glass layers must be separated by one and only one gas layer. */
    materials: materials2[];
    type?: string;
    /** An optional window frame material for the frame that surrounds the window construction. */
    frame?: EnergyWindowFrame;
}

/** This object specifies the properties of window shade materials. */
export class EnergyWindowMaterialShade extends IDdEnergyBaseModel implements IEnergyWindowMaterialShade {
    readonly type: string = "EnergyWindowMaterialShade";
    /** The transmittance averaged over the solar spectrum. It is assumed independent of incidence angle. Default: 0.4. */
    solar_transmittance?: number;
    /** The reflectance averaged over the solar spectrum. It us assumed same on both sides of shade and independent of incidence angle. Default value is 0.5 */
    solar_reflectance?: number;
    /** The transmittance averaged over the solar spectrum and weighted by the response of the human eye. It is assumed independent of incidence angle. Default: 0.4. */
    visible_transmittance?: number;
    /** The transmittance averaged over the solar spectrum and weighted by the response of the human eye. It is assumed independent of incidence angle. Default: 0.4 */
    visible_reflectance?: number;
    /** The effective long-wave infrared hemispherical emissivity. It is assumed same on both sides of shade. Default: 0.9. */
    emissivity?: number;
    /** The effective long-wave transmittance. It is assumed independent of incidence angle. Default: 0. */
    infrared_transmittance?: number;
    /** The thickness of the shade material in meters. Default: 0.005. */
    thickness?: number;
    /** The conductivity of the shade material in W/(m-K). Default value is 0.1. */
    conductivity?: number;
    /** The distance from shade to adjacent glass in meters. Default value is 0.05 */
    distance_to_glass?: number;
    /** The effective area for air flow at the top of the shade, divided by the horizontal area between glass and shade. Default: 0.5. */
    top_opening_multiplier?: number;
    /** The effective area for air flow at the bottom of the shade, divided by the horizontal area between glass and shade. Default: 0.5. */
    bottom_opening_multiplier?: number;
    /** The effective area for air flow at the left side of the shade, divided by the vertical area between glass and shade. Default: 0.5. */
    left_opening_multiplier?: number;
    /** The effective area for air flow at the right side of the shade, divided by the vertical area between glass and shade. Default: 0.5. */
    right_opening_multiplier?: number;
    /** The fraction of the shade surface that is open to air flow. If air cannot pass through the shade material, airflow_permeability = 0. Default: 0. */
    airflow_permeability?: number;

    constructor(data?: IEnergyWindowMaterialShade) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialShade";
            this.solar_transmittance = 0.4;
            this.solar_reflectance = 0.5;
            this.visible_transmittance = 0.4;
            this.visible_reflectance = 0.4;
            this.emissivity = 0.9;
            this.infrared_transmittance = 0;
            this.thickness = 0.005;
            this.conductivity = 0.1;
            this.distance_to_glass = 0.05;
            this.top_opening_multiplier = 0.5;
            this.bottom_opening_multiplier = 0.5;
            this.left_opening_multiplier = 0.5;
            this.right_opening_multiplier = 0.5;
            this.airflow_permeability = 0;
        }
        this._discriminator = "EnergyWindowMaterialShade";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialShade";
            this.solar_transmittance = _data["solar_transmittance"] !== undefined ? _data["solar_transmittance"] : 0.4;
            this.solar_reflectance = _data["solar_reflectance"] !== undefined ? _data["solar_reflectance"] : 0.5;
            this.visible_transmittance = _data["visible_transmittance"] !== undefined ? _data["visible_transmittance"] : 0.4;
            this.visible_reflectance = _data["visible_reflectance"] !== undefined ? _data["visible_reflectance"] : 0.4;
            this.emissivity = _data["emissivity"] !== undefined ? _data["emissivity"] : 0.9;
            this.infrared_transmittance = _data["infrared_transmittance"] !== undefined ? _data["infrared_transmittance"] : 0;
            this.thickness = _data["thickness"] !== undefined ? _data["thickness"] : 0.005;
            this.conductivity = _data["conductivity"] !== undefined ? _data["conductivity"] : 0.1;
            this.distance_to_glass = _data["distance_to_glass"] !== undefined ? _data["distance_to_glass"] : 0.05;
            this.top_opening_multiplier = _data["top_opening_multiplier"] !== undefined ? _data["top_opening_multiplier"] : 0.5;
            this.bottom_opening_multiplier = _data["bottom_opening_multiplier"] !== undefined ? _data["bottom_opening_multiplier"] : 0.5;
            this.left_opening_multiplier = _data["left_opening_multiplier"] !== undefined ? _data["left_opening_multiplier"] : 0.5;
            this.right_opening_multiplier = _data["right_opening_multiplier"] !== undefined ? _data["right_opening_multiplier"] : 0.5;
            this.airflow_permeability = _data["airflow_permeability"] !== undefined ? _data["airflow_permeability"] : 0;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialShade {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialShade();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["solar_transmittance"] = this.solar_transmittance;
        data["solar_reflectance"] = this.solar_reflectance;
        data["visible_transmittance"] = this.visible_transmittance;
        data["visible_reflectance"] = this.visible_reflectance;
        data["emissivity"] = this.emissivity;
        data["infrared_transmittance"] = this.infrared_transmittance;
        data["thickness"] = this.thickness;
        data["conductivity"] = this.conductivity;
        data["distance_to_glass"] = this.distance_to_glass;
        data["top_opening_multiplier"] = this.top_opening_multiplier;
        data["bottom_opening_multiplier"] = this.bottom_opening_multiplier;
        data["left_opening_multiplier"] = this.left_opening_multiplier;
        data["right_opening_multiplier"] = this.right_opening_multiplier;
        data["airflow_permeability"] = this.airflow_permeability;
        super.toJSON(data);
        return data;
    }
}

/** This object specifies the properties of window shade materials. */
export interface IEnergyWindowMaterialShade extends IIDdEnergyBaseModel {
    type?: string;
    /** The transmittance averaged over the solar spectrum. It is assumed independent of incidence angle. Default: 0.4. */
    solar_transmittance?: number;
    /** The reflectance averaged over the solar spectrum. It us assumed same on both sides of shade and independent of incidence angle. Default value is 0.5 */
    solar_reflectance?: number;
    /** The transmittance averaged over the solar spectrum and weighted by the response of the human eye. It is assumed independent of incidence angle. Default: 0.4. */
    visible_transmittance?: number;
    /** The transmittance averaged over the solar spectrum and weighted by the response of the human eye. It is assumed independent of incidence angle. Default: 0.4 */
    visible_reflectance?: number;
    /** The effective long-wave infrared hemispherical emissivity. It is assumed same on both sides of shade. Default: 0.9. */
    emissivity?: number;
    /** The effective long-wave transmittance. It is assumed independent of incidence angle. Default: 0. */
    infrared_transmittance?: number;
    /** The thickness of the shade material in meters. Default: 0.005. */
    thickness?: number;
    /** The conductivity of the shade material in W/(m-K). Default value is 0.1. */
    conductivity?: number;
    /** The distance from shade to adjacent glass in meters. Default value is 0.05 */
    distance_to_glass?: number;
    /** The effective area for air flow at the top of the shade, divided by the horizontal area between glass and shade. Default: 0.5. */
    top_opening_multiplier?: number;
    /** The effective area for air flow at the bottom of the shade, divided by the horizontal area between glass and shade. Default: 0.5. */
    bottom_opening_multiplier?: number;
    /** The effective area for air flow at the left side of the shade, divided by the vertical area between glass and shade. Default: 0.5. */
    left_opening_multiplier?: number;
    /** The effective area for air flow at the right side of the shade, divided by the vertical area between glass and shade. Default: 0.5. */
    right_opening_multiplier?: number;
    /** The fraction of the shade surface that is open to air flow. If air cannot pass through the shade material, airflow_permeability = 0. Default: 0. */
    airflow_permeability?: number;
}

/** An enumeration. */
export enum SlatOrientation {
    Horizontal = "Horizontal",
    Vertical = "Vertical",
}

/** Window blind material consisting of flat, equally-spaced slats. */
export class EnergyWindowMaterialBlind extends IDdEnergyBaseModel implements IEnergyWindowMaterialBlind {
    readonly type: string = "EnergyWindowMaterialBlind";
    slat_orientation?: SlatOrientation;
    /** The width of slat measured from edge to edge in meters. */
    slat_width?: number;
    /** The distance between the front of a slat and the back of the adjacent slat in meters. */
    slat_separation?: number;
    /** The distance between the faces of a slat in meters. The default value is 0.001. */
    slat_thickness?: number;
    /** The angle (degrees) between the glazing outward normal and the slat outward normal where the outward normal points away from the front face of the slat (degrees). The default value is 45. */
    slat_angle?: number;
    /** The thermal conductivity of the slat in W/(m-K). Default: 221. */
    slat_conductivity?: number;
    /** The beam solar transmittance of the slat, assumed to be independent of angle of incidence on the slat. Any transmitted beam radiation is assumed to be 100% diffuse (i.e., slats are translucent). The default value is 0. */
    beam_solar_transmittance?: number;
    /** The beam solar reflectance of the front side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_solar_reflectance?: number;
    /** The beam solar reflectance of the back side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_solar_reflectance_back?: number;
    /** The slat transmittance for hemispherically diffuse solar radiation. Default: 0. */
    diffuse_solar_transmittance?: number;
    /** The front-side slat reflectance for hemispherically diffuse solar radiation. Default: 0.5. */
    diffuse_solar_reflectance?: number;
    /** The back-side slat reflectance for hemispherically diffuse solar radiation. Default: 0.5. */
    diffuse_solar_reflectance_back?: number;
    /** The beam visible transmittance of the slat, it is assumed to be independent of the angle of incidence. Default: 0. */
    beam_visible_transmittance?: number;
    /** The beam visible reflectance on the front side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_visible_reflectance?: number;
    /** The beam visible reflectance on the back side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_visible_reflectance_back?: number;
    /** The slat transmittance for hemispherically diffuse visible radiation. This value should equal “Slat Beam Visible Transmittance.” */
    diffuse_visible_transmittance?: number;
    /** The front-side slat reflectance for hemispherically diffuse visible radiation. This value should equal “Front Side Slat Beam Visible Reflectance.” Default: 0.5. */
    diffuse_visible_reflectance?: number;
    /** The back-side slat reflectance for hemispherically diffuse visible radiation. This value should equal “Back Side Slat Beam Visible Reflectance. Default: 0.5.” */
    diffuse_visible_reflectance_back?: number;
    /** The slat infrared hemispherical transmittance. It is zero for solid metallic, wooden or glass slats, but may be non-zero in some cases such as for thin plastic slats. The default value is 0. */
    infrared_transmittance?: number;
    /** Front side hemispherical emissivity of the slat. Default is 0.9 for most materials. The default value is 0.9. */
    emissivity?: number;
    /** Back side hemispherical emissivity of the slat. Default is 0.9 for most materials. The default value is 0.9. */
    emissivity_back?: number;
    /** The distance from the mid-plane of the blind to the adjacent glass in meters. The default value is 0.05. */
    distance_to_glass?: number;
    /** The effective area for air flow at the top of the shade, divided by the horizontal area between glass and shade. */
    top_opening_multiplier?: number;
    /** The effective area for air flow at the bottom of the shade, divided by the horizontal area between glass and shade. */
    bottom_opening_multiplier?: number;
    /** The effective area for air flow at the left side of the shade, divided by the vertical area between glass and shade. */
    left_opening_multiplier?: number;
    /** The effective area for air flow at the right side of the shade, divided by the vertical area between glass and shade. */
    right_opening_multiplier?: number;

    constructor(data?: IEnergyWindowMaterialBlind) {
        super(data);
        if (!data) {
            this.type = "EnergyWindowMaterialBlind";
            this.slat_orientation = SlatOrientation.Horizontal;
            this.slat_width = 0.025;
            this.slat_separation = 0.01875;
            this.slat_thickness = 0.001;
            this.slat_angle = 45;
            this.slat_conductivity = 221;
            this.beam_solar_transmittance = 0;
            this.beam_solar_reflectance = 0.5;
            this.beam_solar_reflectance_back = 0.5;
            this.diffuse_solar_transmittance = 0;
            this.diffuse_solar_reflectance = 0.5;
            this.diffuse_solar_reflectance_back = 0.5;
            this.beam_visible_transmittance = 0;
            this.beam_visible_reflectance = 0.5;
            this.beam_visible_reflectance_back = 0.5;
            this.diffuse_visible_transmittance = 0;
            this.diffuse_visible_reflectance = 0.5;
            this.diffuse_visible_reflectance_back = 0.5;
            this.infrared_transmittance = 0;
            this.emissivity = 0.9;
            this.emissivity_back = 0.9;
            this.distance_to_glass = 0.05;
            this.top_opening_multiplier = 0.5;
            this.bottom_opening_multiplier = 0.5;
            this.left_opening_multiplier = 0.5;
            this.right_opening_multiplier = 0.5;
        }
        this._discriminator = "EnergyWindowMaterialBlind";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EnergyWindowMaterialBlind";
            this.slat_orientation = _data["slat_orientation"] !== undefined ? _data["slat_orientation"] : SlatOrientation.Horizontal;
            this.slat_width = _data["slat_width"] !== undefined ? _data["slat_width"] : 0.025;
            this.slat_separation = _data["slat_separation"] !== undefined ? _data["slat_separation"] : 0.01875;
            this.slat_thickness = _data["slat_thickness"] !== undefined ? _data["slat_thickness"] : 0.001;
            this.slat_angle = _data["slat_angle"] !== undefined ? _data["slat_angle"] : 45;
            this.slat_conductivity = _data["slat_conductivity"] !== undefined ? _data["slat_conductivity"] : 221;
            this.beam_solar_transmittance = _data["beam_solar_transmittance"] !== undefined ? _data["beam_solar_transmittance"] : 0;
            this.beam_solar_reflectance = _data["beam_solar_reflectance"] !== undefined ? _data["beam_solar_reflectance"] : 0.5;
            this.beam_solar_reflectance_back = _data["beam_solar_reflectance_back"] !== undefined ? _data["beam_solar_reflectance_back"] : 0.5;
            this.diffuse_solar_transmittance = _data["diffuse_solar_transmittance"] !== undefined ? _data["diffuse_solar_transmittance"] : 0;
            this.diffuse_solar_reflectance = _data["diffuse_solar_reflectance"] !== undefined ? _data["diffuse_solar_reflectance"] : 0.5;
            this.diffuse_solar_reflectance_back = _data["diffuse_solar_reflectance_back"] !== undefined ? _data["diffuse_solar_reflectance_back"] : 0.5;
            this.beam_visible_transmittance = _data["beam_visible_transmittance"] !== undefined ? _data["beam_visible_transmittance"] : 0;
            this.beam_visible_reflectance = _data["beam_visible_reflectance"] !== undefined ? _data["beam_visible_reflectance"] : 0.5;
            this.beam_visible_reflectance_back = _data["beam_visible_reflectance_back"] !== undefined ? _data["beam_visible_reflectance_back"] : 0.5;
            this.diffuse_visible_transmittance = _data["diffuse_visible_transmittance"] !== undefined ? _data["diffuse_visible_transmittance"] : 0;
            this.diffuse_visible_reflectance = _data["diffuse_visible_reflectance"] !== undefined ? _data["diffuse_visible_reflectance"] : 0.5;
            this.diffuse_visible_reflectance_back = _data["diffuse_visible_reflectance_back"] !== undefined ? _data["diffuse_visible_reflectance_back"] : 0.5;
            this.infrared_transmittance = _data["infrared_transmittance"] !== undefined ? _data["infrared_transmittance"] : 0;
            this.emissivity = _data["emissivity"] !== undefined ? _data["emissivity"] : 0.9;
            this.emissivity_back = _data["emissivity_back"] !== undefined ? _data["emissivity_back"] : 0.9;
            this.distance_to_glass = _data["distance_to_glass"] !== undefined ? _data["distance_to_glass"] : 0.05;
            this.top_opening_multiplier = _data["top_opening_multiplier"] !== undefined ? _data["top_opening_multiplier"] : 0.5;
            this.bottom_opening_multiplier = _data["bottom_opening_multiplier"] !== undefined ? _data["bottom_opening_multiplier"] : 0.5;
            this.left_opening_multiplier = _data["left_opening_multiplier"] !== undefined ? _data["left_opening_multiplier"] : 0.5;
            this.right_opening_multiplier = _data["right_opening_multiplier"] !== undefined ? _data["right_opening_multiplier"] : 0.5;
        }
    }

    static override fromJS(data: any): EnergyWindowMaterialBlind {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyWindowMaterialBlind();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["slat_orientation"] = this.slat_orientation;
        data["slat_width"] = this.slat_width;
        data["slat_separation"] = this.slat_separation;
        data["slat_thickness"] = this.slat_thickness;
        data["slat_angle"] = this.slat_angle;
        data["slat_conductivity"] = this.slat_conductivity;
        data["beam_solar_transmittance"] = this.beam_solar_transmittance;
        data["beam_solar_reflectance"] = this.beam_solar_reflectance;
        data["beam_solar_reflectance_back"] = this.beam_solar_reflectance_back;
        data["diffuse_solar_transmittance"] = this.diffuse_solar_transmittance;
        data["diffuse_solar_reflectance"] = this.diffuse_solar_reflectance;
        data["diffuse_solar_reflectance_back"] = this.diffuse_solar_reflectance_back;
        data["beam_visible_transmittance"] = this.beam_visible_transmittance;
        data["beam_visible_reflectance"] = this.beam_visible_reflectance;
        data["beam_visible_reflectance_back"] = this.beam_visible_reflectance_back;
        data["diffuse_visible_transmittance"] = this.diffuse_visible_transmittance;
        data["diffuse_visible_reflectance"] = this.diffuse_visible_reflectance;
        data["diffuse_visible_reflectance_back"] = this.diffuse_visible_reflectance_back;
        data["infrared_transmittance"] = this.infrared_transmittance;
        data["emissivity"] = this.emissivity;
        data["emissivity_back"] = this.emissivity_back;
        data["distance_to_glass"] = this.distance_to_glass;
        data["top_opening_multiplier"] = this.top_opening_multiplier;
        data["bottom_opening_multiplier"] = this.bottom_opening_multiplier;
        data["left_opening_multiplier"] = this.left_opening_multiplier;
        data["right_opening_multiplier"] = this.right_opening_multiplier;
        super.toJSON(data);
        return data;
    }
}

/** Window blind material consisting of flat, equally-spaced slats. */
export interface IEnergyWindowMaterialBlind extends IIDdEnergyBaseModel {
    type?: string;
    slat_orientation?: SlatOrientation;
    /** The width of slat measured from edge to edge in meters. */
    slat_width?: number;
    /** The distance between the front of a slat and the back of the adjacent slat in meters. */
    slat_separation?: number;
    /** The distance between the faces of a slat in meters. The default value is 0.001. */
    slat_thickness?: number;
    /** The angle (degrees) between the glazing outward normal and the slat outward normal where the outward normal points away from the front face of the slat (degrees). The default value is 45. */
    slat_angle?: number;
    /** The thermal conductivity of the slat in W/(m-K). Default: 221. */
    slat_conductivity?: number;
    /** The beam solar transmittance of the slat, assumed to be independent of angle of incidence on the slat. Any transmitted beam radiation is assumed to be 100% diffuse (i.e., slats are translucent). The default value is 0. */
    beam_solar_transmittance?: number;
    /** The beam solar reflectance of the front side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_solar_reflectance?: number;
    /** The beam solar reflectance of the back side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_solar_reflectance_back?: number;
    /** The slat transmittance for hemispherically diffuse solar radiation. Default: 0. */
    diffuse_solar_transmittance?: number;
    /** The front-side slat reflectance for hemispherically diffuse solar radiation. Default: 0.5. */
    diffuse_solar_reflectance?: number;
    /** The back-side slat reflectance for hemispherically diffuse solar radiation. Default: 0.5. */
    diffuse_solar_reflectance_back?: number;
    /** The beam visible transmittance of the slat, it is assumed to be independent of the angle of incidence. Default: 0. */
    beam_visible_transmittance?: number;
    /** The beam visible reflectance on the front side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_visible_reflectance?: number;
    /** The beam visible reflectance on the back side of the slat, it is assumed to be independent of the angle of incidence. Default: 0.5. */
    beam_visible_reflectance_back?: number;
    /** The slat transmittance for hemispherically diffuse visible radiation. This value should equal “Slat Beam Visible Transmittance.” */
    diffuse_visible_transmittance?: number;
    /** The front-side slat reflectance for hemispherically diffuse visible radiation. This value should equal “Front Side Slat Beam Visible Reflectance.” Default: 0.5. */
    diffuse_visible_reflectance?: number;
    /** The back-side slat reflectance for hemispherically diffuse visible radiation. This value should equal “Back Side Slat Beam Visible Reflectance. Default: 0.5.” */
    diffuse_visible_reflectance_back?: number;
    /** The slat infrared hemispherical transmittance. It is zero for solid metallic, wooden or glass slats, but may be non-zero in some cases such as for thin plastic slats. The default value is 0. */
    infrared_transmittance?: number;
    /** Front side hemispherical emissivity of the slat. Default is 0.9 for most materials. The default value is 0.9. */
    emissivity?: number;
    /** Back side hemispherical emissivity of the slat. Default is 0.9 for most materials. The default value is 0.9. */
    emissivity_back?: number;
    /** The distance from the mid-plane of the blind to the adjacent glass in meters. The default value is 0.05. */
    distance_to_glass?: number;
    /** The effective area for air flow at the top of the shade, divided by the horizontal area between glass and shade. */
    top_opening_multiplier?: number;
    /** The effective area for air flow at the bottom of the shade, divided by the horizontal area between glass and shade. */
    bottom_opening_multiplier?: number;
    /** The effective area for air flow at the left side of the shade, divided by the vertical area between glass and shade. */
    left_opening_multiplier?: number;
    /** The effective area for air flow at the right side of the shade, divided by the vertical area between glass and shade. */
    right_opening_multiplier?: number;
}

/** Choices for where a shade material is located in a window assembly. */
export enum ShadeLocation {
    Interior = "Interior",
    Between = "Between",
    Exterior = "Exterior",
}

/** Choices for how the shading device is controlled. */
export enum ControlType {
    AlwaysOn = "AlwaysOn",
    OnIfHighSolarOnWindow = "OnIfHighSolarOnWindow",
    OnIfHighHorizontalSolar = "OnIfHighHorizontalSolar",
    OnIfHighOutdoorAirTemperature = "OnIfHighOutdoorAirTemperature",
    OnIfHighZoneAirTemperature = "OnIfHighZoneAirTemperature",
    OnIfHighZoneCooling = "OnIfHighZoneCooling",
    OnNightIfLowOutdoorTempAndOffDay = "OnNightIfLowOutdoorTempAndOffDay",
    OnNightIfLowInsideTempAndOffDay = "OnNightIfLowInsideTempAndOffDay",
    OnNightIfHeatingAndOffDay = "OnNightIfHeatingAndOffDay",
}

/** Used to describe the daily schedule for a single simulation day. */
export class ScheduleDay extends EnergyBaseModel implements IScheduleDay {
    /** A list of floats or integers for the values of the schedule. The length of this list must match the length of the times list. */
    values!: number[];
    readonly type: string = "ScheduleDay";
    /** A list of lists with each sub-list possesing 2 values for [hour, minute]. The length of the master list must match the length of the values list. Each time in the master list represents the time of day that the corresponding value begins to take effect. For example [(0,0), (9,0), (17,0)] in combination with the values [0, 1, 0] denotes a schedule value of 0 from 0:00 to 9:00, a value of 1 from 9:00 to 17:00 and 0 from 17:00 to the end of the day. Note that this representation of times as the "time of beginning" is a different convention than EnergyPlus, which uses "time until". */
    times?: number[][];
    /** Boolean to note whether values in between times should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;

    constructor(data?: IScheduleDay) {
        super(data);
        if (!data) {
            this.values = [];
            this.type = "ScheduleDay";
            this.interpolate = false;
        }
        this._discriminator = "ScheduleDay";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleDay";
            if (Array.isArray(_data["times"])) {
                this.times = [] as any;
                for (let item of _data["times"])
                    this.times!.push(item);
            }
            this.interpolate = _data["interpolate"] !== undefined ? _data["interpolate"] : false;
        }
    }

    static override fromJS(data: any): ScheduleDay {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDay();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.times)) {
            data["times"] = [];
            for (let item of this.times)
                data["times"].push(item);
        }
        data["interpolate"] = this.interpolate;
        super.toJSON(data);
        return data;
    }
}

/** Used to describe the daily schedule for a single simulation day. */
export interface IScheduleDay extends IEnergyBaseModel {
    /** A list of floats or integers for the values of the schedule. The length of this list must match the length of the times list. */
    values: number[];
    type?: string;
    /** A list of lists with each sub-list possesing 2 values for [hour, minute]. The length of the master list must match the length of the values list. Each time in the master list represents the time of day that the corresponding value begins to take effect. For example [(0,0), (9,0), (17,0)] in combination with the values [0, 1, 0] denotes a schedule value of 0 from 0:00 to 9:00, a value of 1 from 9:00 to 17:00 and 0 from 17:00 to the end of the day. Note that this representation of times as the "time of beginning" is a different convention than EnergyPlus, which uses "time until". */
    times?: number[][];
    /** Boolean to note whether values in between times should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;
}

/** Base class for all objects needing to check for a valid Date. */
export class DatedBaseModel extends _OpenAPIGenBaseModel implements IDatedBaseModel {
    readonly type: string = "DatedBaseModel";

    constructor(data?: IDatedBaseModel) {
        super(data);
        if (!data) {
            this.type = "DatedBaseModel";
        }
        this._discriminator = "DatedBaseModel";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DatedBaseModel";
        }
    }

    static override fromJS(data: any): DatedBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ScheduleRuleAbridged") {
            let result = new ScheduleRuleAbridged();
            result.init(data);
            return result;
        }
        let result = new DatedBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects needing to check for a valid Date. */
export interface IDatedBaseModel extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Schedule rule including a ScheduleDay and when it should be applied.. */
export class ScheduleRuleAbridged extends DatedBaseModel implements IScheduleRuleAbridged {
    /** The identifier of a ScheduleDay object associated with this rule. */
    schedule_day!: string;
    readonly type: string = "ScheduleRuleAbridged";
    /** Boolean noting whether to apply schedule_day on Sundays. */
    apply_sunday?: boolean;
    /** Boolean noting whether to apply schedule_day on Mondays. */
    apply_monday?: boolean;
    /** Boolean noting whether to apply schedule_day on Tuesdays. */
    apply_tuesday?: boolean;
    /** Boolean noting whether to apply schedule_day on Wednesdays. */
    apply_wednesday?: boolean;
    /** Boolean noting whether to apply schedule_day on Thursdays. */
    apply_thursday?: boolean;
    /** Boolean noting whether to apply schedule_day on Fridays. */
    apply_friday?: boolean;
    /** Boolean noting whether to apply schedule_day on Saturdays. */
    apply_saturday?: boolean;
    /** A list of two integers for [month, day], representing the start date of the period over which the schedule_day will be applied.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /** A list of two integers for [month, day], representing the end date of the period over which the schedule_day will be applied.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    end_date?: number[];

    constructor(data?: IScheduleRuleAbridged) {
        super(data);
        if (!data) {
            this.type = "ScheduleRuleAbridged";
            this.apply_sunday = false;
            this.apply_monday = false;
            this.apply_tuesday = false;
            this.apply_wednesday = false;
            this.apply_thursday = false;
            this.apply_friday = false;
            this.apply_saturday = false;
        }
        this._discriminator = "ScheduleRuleAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schedule_day = _data["schedule_day"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleRuleAbridged";
            this.apply_sunday = _data["apply_sunday"] !== undefined ? _data["apply_sunday"] : false;
            this.apply_monday = _data["apply_monday"] !== undefined ? _data["apply_monday"] : false;
            this.apply_tuesday = _data["apply_tuesday"] !== undefined ? _data["apply_tuesday"] : false;
            this.apply_wednesday = _data["apply_wednesday"] !== undefined ? _data["apply_wednesday"] : false;
            this.apply_thursday = _data["apply_thursday"] !== undefined ? _data["apply_thursday"] : false;
            this.apply_friday = _data["apply_friday"] !== undefined ? _data["apply_friday"] : false;
            this.apply_saturday = _data["apply_saturday"] !== undefined ? _data["apply_saturday"] : false;
            if (Array.isArray(_data["start_date"])) {
                this.start_date = [] as any;
                for (let item of _data["start_date"])
                    this.start_date!.push(item);
            }
            if (Array.isArray(_data["end_date"])) {
                this.end_date = [] as any;
                for (let item of _data["end_date"])
                    this.end_date!.push(item);
            }
        }
    }

    static override fromJS(data: any): ScheduleRuleAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleRuleAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule_day"] = this.schedule_day;
        data["type"] = this.type;
        data["apply_sunday"] = this.apply_sunday;
        data["apply_monday"] = this.apply_monday;
        data["apply_tuesday"] = this.apply_tuesday;
        data["apply_wednesday"] = this.apply_wednesday;
        data["apply_thursday"] = this.apply_thursday;
        data["apply_friday"] = this.apply_friday;
        data["apply_saturday"] = this.apply_saturday;
        if (Array.isArray(this.start_date)) {
            data["start_date"] = [];
            for (let item of this.start_date)
                data["start_date"].push(item);
        }
        if (Array.isArray(this.end_date)) {
            data["end_date"] = [];
            for (let item of this.end_date)
                data["end_date"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Schedule rule including a ScheduleDay and when it should be applied.. */
export interface IScheduleRuleAbridged extends IDatedBaseModel {
    /** The identifier of a ScheduleDay object associated with this rule. */
    schedule_day: string;
    type?: string;
    /** Boolean noting whether to apply schedule_day on Sundays. */
    apply_sunday?: boolean;
    /** Boolean noting whether to apply schedule_day on Mondays. */
    apply_monday?: boolean;
    /** Boolean noting whether to apply schedule_day on Tuesdays. */
    apply_tuesday?: boolean;
    /** Boolean noting whether to apply schedule_day on Wednesdays. */
    apply_wednesday?: boolean;
    /** Boolean noting whether to apply schedule_day on Thursdays. */
    apply_thursday?: boolean;
    /** Boolean noting whether to apply schedule_day on Fridays. */
    apply_friday?: boolean;
    /** Boolean noting whether to apply schedule_day on Saturdays. */
    apply_saturday?: boolean;
    /** A list of two integers for [month, day], representing the start date of the period over which the schedule_day will be applied.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /** A list of two integers for [month, day], representing the end date of the period over which the schedule_day will be applied.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    end_date?: number[];
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class NoLimit extends _OpenAPIGenBaseModel implements INoLimit {
    readonly type: string = "NoLimit";

    constructor(data?: INoLimit) {
        super(data);
        if (!data) {
            this.type = "NoLimit";
        }
        this._discriminator = "NoLimit";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "NoLimit";
        }
    }

    static override fromJS(data: any): NoLimit {
        data = typeof data === 'object' ? data : {};
        let result = new NoLimit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface INoLimit extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Designates how the range values are validated. */
export enum ScheduleNumericType {
    Continuous = "Continuous",
    Discrete = "Discrete",
}

/** An enumeration. */
export enum ScheduleUnitType {
    Dimensionless = "Dimensionless",
    Temperature = "Temperature",
    DeltaTemperature = "DeltaTemperature",
    PrecipitationRate = "PrecipitationRate",
    Angle = "Angle",
    ConvectionCoefficient = "ConvectionCoefficient",
    ActivityLevel = "ActivityLevel",
    Velocity = "Velocity",
    Capacity = "Capacity",
    Power = "Power",
    Availability = "Availability",
    Percent = "Percent",
    Control = "Control",
    Mode = "Mode",
}

/** Specifies the data types and limits for values contained in schedules. */
export class ScheduleTypeLimit extends EnergyBaseModel implements IScheduleTypeLimit {
    readonly type: string = "ScheduleTypeLimit";
    /** Lower limit for the schedule type or NoLimit. */
    lower_limit?: Lower_limit;
    /** Upper limit for the schedule type or NoLimit. */
    upper_limit?: Upper_limit;
    numeric_type?: ScheduleNumericType;
    unit_type?: ScheduleUnitType;

    constructor(data?: IScheduleTypeLimit) {
        super(data);
        if (!data) {
            this.type = "ScheduleTypeLimit";
            this.numeric_type = ScheduleNumericType.Continuous;
            this.unit_type = ScheduleUnitType.Dimensionless;
        }
        this._discriminator = "ScheduleTypeLimit";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleTypeLimit";
            this.lower_limit = _data["lower_limit"];
            this.upper_limit = _data["upper_limit"];
            this.numeric_type = _data["numeric_type"] !== undefined ? _data["numeric_type"] : ScheduleNumericType.Continuous;
            this.unit_type = _data["unit_type"] !== undefined ? _data["unit_type"] : ScheduleUnitType.Dimensionless;
        }
    }

    static override fromJS(data: any): ScheduleTypeLimit {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTypeLimit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["lower_limit"] = this.lower_limit;
        data["upper_limit"] = this.upper_limit;
        data["numeric_type"] = this.numeric_type;
        data["unit_type"] = this.unit_type;
        super.toJSON(data);
        return data;
    }
}

/** Specifies the data types and limits for values contained in schedules. */
export interface IScheduleTypeLimit extends IEnergyBaseModel {
    type?: string;
    /** Lower limit for the schedule type or NoLimit. */
    lower_limit?: Lower_limit;
    /** Upper limit for the schedule type or NoLimit. */
    upper_limit?: Upper_limit;
    numeric_type?: ScheduleNumericType;
    unit_type?: ScheduleUnitType;
}

/** Used to define a schedule for a default day, further described by ScheduleRule. */
export class ScheduleRuleset extends IDdEnergyBaseModel implements IScheduleRuleset {
    /** A list of ScheduleDays that are referenced in the other keys of this ScheduleRulesetAbridged. */
    day_schedules!: ScheduleDay[];
    /** An identifier for the ScheduleDay that will be used for all days when no ScheduleRule is applied. This ScheduleDay must be in the day_schedules. */
    default_day_schedule!: string;
    readonly type: string = "ScheduleRuleset";
    /** A list of ScheduleRuleAbridged that note exceptions to the default_day_schedule. These rules should be ordered from highest to lowest priority. */
    schedule_rules?: ScheduleRuleAbridged[];
    /** An identifier for the ScheduleDay that will be used for holidays. This ScheduleDay must be in the day_schedules. */
    holiday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the summer design day. This ScheduleDay must be in the day_schedules. */
    summer_designday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the winter design day. This ScheduleDay must be in the day_schedules. */
    winter_designday_schedule?: string;
    /** ScheduleTypeLimit object that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: ScheduleTypeLimit;

    constructor(data?: IScheduleRuleset) {
        super(data);
        if (!data) {
            this.day_schedules = [];
            this.type = "ScheduleRuleset";
        }
        this._discriminator = "ScheduleRuleset";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["day_schedules"])) {
                this.day_schedules = [] as any;
                for (let item of _data["day_schedules"])
                    this.day_schedules!.push(ScheduleDay.fromJS(item));
            }
            this.default_day_schedule = _data["default_day_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleRuleset";
            if (Array.isArray(_data["schedule_rules"])) {
                this.schedule_rules = [] as any;
                for (let item of _data["schedule_rules"])
                    this.schedule_rules!.push(ScheduleRuleAbridged.fromJS(item));
            }
            this.holiday_schedule = _data["holiday_schedule"];
            this.summer_designday_schedule = _data["summer_designday_schedule"];
            this.winter_designday_schedule = _data["winter_designday_schedule"];
            this.schedule_type_limit = _data["schedule_type_limit"] ? ScheduleTypeLimit.fromJS(_data["schedule_type_limit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ScheduleRuleset {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleRuleset();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.day_schedules)) {
            data["day_schedules"] = [];
            for (let item of this.day_schedules)
                data["day_schedules"].push(item.toJSON());
        }
        data["default_day_schedule"] = this.default_day_schedule;
        data["type"] = this.type;
        if (Array.isArray(this.schedule_rules)) {
            data["schedule_rules"] = [];
            for (let item of this.schedule_rules)
                data["schedule_rules"].push(item.toJSON());
        }
        data["holiday_schedule"] = this.holiday_schedule;
        data["summer_designday_schedule"] = this.summer_designday_schedule;
        data["winter_designday_schedule"] = this.winter_designday_schedule;
        data["schedule_type_limit"] = this.schedule_type_limit ? this.schedule_type_limit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Used to define a schedule for a default day, further described by ScheduleRule. */
export interface IScheduleRuleset extends IIDdEnergyBaseModel {
    /** A list of ScheduleDays that are referenced in the other keys of this ScheduleRulesetAbridged. */
    day_schedules: ScheduleDay[];
    /** An identifier for the ScheduleDay that will be used for all days when no ScheduleRule is applied. This ScheduleDay must be in the day_schedules. */
    default_day_schedule: string;
    type?: string;
    /** A list of ScheduleRuleAbridged that note exceptions to the default_day_schedule. These rules should be ordered from highest to lowest priority. */
    schedule_rules?: ScheduleRuleAbridged[];
    /** An identifier for the ScheduleDay that will be used for holidays. This ScheduleDay must be in the day_schedules. */
    holiday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the summer design day. This ScheduleDay must be in the day_schedules. */
    summer_designday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the winter design day. This ScheduleDay must be in the day_schedules. */
    winter_designday_schedule?: string;
    /** ScheduleTypeLimit object that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: ScheduleTypeLimit;
}

/** Used to specify a start date and a list of values for a period of analysis. */
export class ScheduleFixedInterval extends IDdEnergyBaseModel implements IScheduleFixedInterval {
    /** A list of timeseries values occuring at each timestep over the course of the simulation. */
    values!: number[];
    readonly type: string = "ScheduleFixedInterval";
    /** ScheduleTypeLimit object that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: ScheduleTypeLimit;
    /** An integer for the number of steps per hour that the input values correspond to.  For example, if each value represents 30 minutes, the timestep is 2. For 15 minutes, it is 4. */
    timestep?: number;
    /** A list of two integers for [month, day], representing the start date when the schedule values begin to take effect.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /**  A value that will be used for all times not covered by the input values. Typically, your simulation should not need to use this value if the input values completely cover the simulation period. */
    placeholder_value?: number;
    /** Boolean to note whether values in between intervals should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;

    constructor(data?: IScheduleFixedInterval) {
        super(data);
        if (!data) {
            this.values = [];
            this.type = "ScheduleFixedInterval";
            this.timestep = 1;
            this.placeholder_value = 0;
            this.interpolate = false;
        }
        this._discriminator = "ScheduleFixedInterval";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleFixedInterval";
            this.schedule_type_limit = _data["schedule_type_limit"] ? ScheduleTypeLimit.fromJS(_data["schedule_type_limit"]) : <any>undefined;
            this.timestep = _data["timestep"] !== undefined ? _data["timestep"] : 1;
            if (Array.isArray(_data["start_date"])) {
                this.start_date = [] as any;
                for (let item of _data["start_date"])
                    this.start_date!.push(item);
            }
            this.placeholder_value = _data["placeholder_value"] !== undefined ? _data["placeholder_value"] : 0;
            this.interpolate = _data["interpolate"] !== undefined ? _data["interpolate"] : false;
        }
    }

    static override fromJS(data: any): ScheduleFixedInterval {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleFixedInterval();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["type"] = this.type;
        data["schedule_type_limit"] = this.schedule_type_limit ? this.schedule_type_limit.toJSON() : <any>undefined;
        data["timestep"] = this.timestep;
        if (Array.isArray(this.start_date)) {
            data["start_date"] = [];
            for (let item of this.start_date)
                data["start_date"].push(item);
        }
        data["placeholder_value"] = this.placeholder_value;
        data["interpolate"] = this.interpolate;
        super.toJSON(data);
        return data;
    }
}

/** Used to specify a start date and a list of values for a period of analysis. */
export interface IScheduleFixedInterval extends IIDdEnergyBaseModel {
    /** A list of timeseries values occuring at each timestep over the course of the simulation. */
    values: number[];
    type?: string;
    /** ScheduleTypeLimit object that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: ScheduleTypeLimit;
    /** An integer for the number of steps per hour that the input values correspond to.  For example, if each value represents 30 minutes, the timestep is 2. For 15 minutes, it is 4. */
    timestep?: number;
    /** A list of two integers for [month, day], representing the start date when the schedule values begin to take effect.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /**  A value that will be used for all times not covered by the input values. Typically, your simulation should not need to use this value if the input values completely cover the simulation period. */
    placeholder_value?: number;
    /** Boolean to note whether values in between intervals should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;
}

/** Construction for window objects (Aperture, Door). */
export class WindowConstructionShade extends IDdEnergyBaseModel implements IWindowConstructionShade {
    /** A WindowConstruction object that serves as the "switched off" version of the construction (aka. the "bare construction"). The shade_material and shade_location will be used to modify this starting construction. */
    window_construction!: WindowConstruction;
    /** Identifier of a An EnergyWindowMaterialShade or an EnergyWindowMaterialBlind that serves as the shading layer for this construction. This can also be an EnergyWindowMaterialGlazing, which will indicate that the WindowConstruction has a dynamically-controlled glass pane like an electrochromic window assembly. */
    shade_material!: Shade_material;
    readonly type: string = "WindowConstructionShade";
    /** Text to indicate where in the window assembly the shade_material is located.  Note that the WindowConstruction must have at least one gas gap to use the "Between" option. Also note that, for a WindowConstruction with more than one gas gap, the "Between" option defaults to using the inner gap as this is the only option that EnergyPlus supports. */
    shade_location?: ShadeLocation;
    /** Text to indicate how the shading device is controlled, which determines when the shading is “on” or “off.” */
    control_type?: ControlType;
    /** A number that corresponds to the specified control_type. This can be a value in (W/m2), (C) or (W) depending upon the control type.Note that this value cannot be None for any control type except "AlwaysOn." */
    setpoint?: number;
    /** An optional ScheduleRuleset or ScheduleFixedInterval to be applied on top of the control_type. If None, the control_type will govern all behavior of the construction. */
    schedule?: Schedule;

    constructor(data?: IWindowConstructionShade) {
        super(data);
        if (!data) {
            this.window_construction = new WindowConstruction();
            this.type = "WindowConstructionShade";
            this.shade_location = ShadeLocation.Interior;
            this.control_type = ControlType.AlwaysOn;
        }
        this._discriminator = "WindowConstructionShade";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.window_construction = _data["window_construction"] ? WindowConstruction.fromJS(_data["window_construction"]) : new WindowConstruction();
            this.shade_material = _data["shade_material"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowConstructionShade";
            this.shade_location = _data["shade_location"] !== undefined ? _data["shade_location"] : ShadeLocation.Interior;
            this.control_type = _data["control_type"] !== undefined ? _data["control_type"] : ControlType.AlwaysOn;
            this.setpoint = _data["setpoint"];
            this.schedule = _data["schedule"];
        }
    }

    static override fromJS(data: any): WindowConstructionShade {
        data = typeof data === 'object' ? data : {};
        let result = new WindowConstructionShade();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["window_construction"] = this.window_construction ? this.window_construction.toJSON() : <any>undefined;
        data["shade_material"] = this.shade_material;
        data["type"] = this.type;
        data["shade_location"] = this.shade_location;
        data["control_type"] = this.control_type;
        data["setpoint"] = this.setpoint;
        data["schedule"] = this.schedule;
        super.toJSON(data);
        return data;
    }
}

/** Construction for window objects (Aperture, Door). */
export interface IWindowConstructionShade extends IIDdEnergyBaseModel {
    /** A WindowConstruction object that serves as the "switched off" version of the construction (aka. the "bare construction"). The shade_material and shade_location will be used to modify this starting construction. */
    window_construction: WindowConstruction;
    /** Identifier of a An EnergyWindowMaterialShade or an EnergyWindowMaterialBlind that serves as the shading layer for this construction. This can also be an EnergyWindowMaterialGlazing, which will indicate that the WindowConstruction has a dynamically-controlled glass pane like an electrochromic window assembly. */
    shade_material: Shade_material;
    type?: string;
    /** Text to indicate where in the window assembly the shade_material is located.  Note that the WindowConstruction must have at least one gas gap to use the "Between" option. Also note that, for a WindowConstruction with more than one gas gap, the "Between" option defaults to using the inner gap as this is the only option that EnergyPlus supports. */
    shade_location?: ShadeLocation;
    /** Text to indicate how the shading device is controlled, which determines when the shading is “on” or “off.” */
    control_type?: ControlType;
    /** A number that corresponds to the specified control_type. This can be a value in (W/m2), (C) or (W) depending upon the control type.Note that this value cannot be None for any control type except "AlwaysOn." */
    setpoint?: number;
    /** An optional ScheduleRuleset or ScheduleFixedInterval to be applied on top of the control_type. If None, the control_type will govern all behavior of the construction. */
    schedule?: Schedule;
}

/** Construction for window objects with an included shade layer. */
export class WindowConstructionDynamic extends IDdEnergyBaseModel implements IWindowConstructionDynamic {
    /** A list of WindowConstruction objects that define the various states that the dynamic window can assume. */
    constructions!: WindowConstruction[];
    /** A control schedule that dictates which constructions are active at given times throughout the simulation. The values of the schedule should be integers and range from 0 to one less then the number of constructions. Zero indicates that the first construction is active, one indicates that the second on is active, etc. The schedule type limits of this schedule should be "Control Level." If building custom schedule type limits that describe a particular range of states, the type limits should be "Discrete" and the unit type should be "Mode," "Control," or some other fractional unit. */
    schedule!: schedule;
    readonly type: string = "WindowConstructionDynamic";

    constructor(data?: IWindowConstructionDynamic) {
        super(data);
        if (!data) {
            this.constructions = [];
            this.type = "WindowConstructionDynamic";
        }
        this._discriminator = "WindowConstructionDynamic";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["constructions"])) {
                this.constructions = [] as any;
                for (let item of _data["constructions"])
                    this.constructions!.push(WindowConstruction.fromJS(item));
            }
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowConstructionDynamic";
        }
    }

    static override fromJS(data: any): WindowConstructionDynamic {
        data = typeof data === 'object' ? data : {};
        let result = new WindowConstructionDynamic();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.constructions)) {
            data["constructions"] = [];
            for (let item of this.constructions)
                data["constructions"].push(item.toJSON());
        }
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Construction for window objects with an included shade layer. */
export interface IWindowConstructionDynamic extends IIDdEnergyBaseModel {
    /** A list of WindowConstruction objects that define the various states that the dynamic window can assume. */
    constructions: WindowConstruction[];
    /** A control schedule that dictates which constructions are active at given times throughout the simulation. The values of the schedule should be integers and range from 0 to one less then the number of constructions. Zero indicates that the first construction is active, one indicates that the second on is active, etc. The schedule type limits of this schedule should be "Control Level." If building custom schedule type limits that describe a particular range of states, the type limits should be "Discrete" and the unit type should be "Mode," "Control," or some other fractional unit. */
    schedule: schedule;
    type?: string;
}

/** A set of constructions for aperture assemblies. */
export class ApertureConstructionSet extends _OpenAPIGenBaseModel implements IApertureConstructionSet {
    readonly type: string = "ApertureConstructionSet";
    /** A WindowConstruction for all apertures with a Surface boundary condition. */
    interior_construction?: Interior_construction;
    /** A WindowConstruction for apertures with an Outdoors boundary condition, False is_operable property, and a Wall face type for their parent face. */
    window_construction?: Window_construction;
    /** A WindowConstruction for apertures with a Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_construction?: Skylight_construction;
    /** A WindowConstruction for all apertures with an Outdoors boundary condition and True is_operable property. */
    operable_construction?: Operable_construction;

    constructor(data?: IApertureConstructionSet) {
        super(data);
        if (!data) {
            this.type = "ApertureConstructionSet";
        }
        this._discriminator = "ApertureConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureConstructionSet";
            this.interior_construction = _data["interior_construction"];
            this.window_construction = _data["window_construction"];
            this.skylight_construction = _data["skylight_construction"];
            this.operable_construction = _data["operable_construction"];
        }
    }

    static override fromJS(data: any): ApertureConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["interior_construction"] = this.interior_construction;
        data["window_construction"] = this.window_construction;
        data["skylight_construction"] = this.skylight_construction;
        data["operable_construction"] = this.operable_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for aperture assemblies. */
export interface IApertureConstructionSet extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A WindowConstruction for all apertures with a Surface boundary condition. */
    interior_construction?: Interior_construction;
    /** A WindowConstruction for apertures with an Outdoors boundary condition, False is_operable property, and a Wall face type for their parent face. */
    window_construction?: Window_construction;
    /** A WindowConstruction for apertures with a Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_construction?: Skylight_construction;
    /** A WindowConstruction for all apertures with an Outdoors boundary condition and True is_operable property. */
    operable_construction?: Operable_construction;
}

/** A set of constructions for door assemblies. */
export class DoorConstructionSet extends _OpenAPIGenBaseModel implements IDoorConstructionSet {
    readonly type: string = "DoorConstructionSet";
    /** An OpaqueConstruction for all opaque doors with a Surface boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for opaque doors with an Outdoors boundary condition and a Wall face type for their parent face. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for opaque doors with an Outdoors boundary condition and a RoofCeiling or Floor type for their parent face. */
    overhead_construction?: OpaqueConstruction;
    /** A WindowConstruction for all glass doors with an Outdoors boundary condition. */
    exterior_glass_construction?: Exterior_glass_construction;
    /** A WindowConstruction for all glass doors with a Surface boundary condition. */
    interior_glass_construction?: Interior_glass_construction;

    constructor(data?: IDoorConstructionSet) {
        super(data);
        if (!data) {
            this.type = "DoorConstructionSet";
        }
        this._discriminator = "DoorConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorConstructionSet";
            this.interior_construction = _data["interior_construction"] ? OpaqueConstruction.fromJS(_data["interior_construction"]) : <any>undefined;
            this.exterior_construction = _data["exterior_construction"] ? OpaqueConstruction.fromJS(_data["exterior_construction"]) : <any>undefined;
            this.overhead_construction = _data["overhead_construction"] ? OpaqueConstruction.fromJS(_data["overhead_construction"]) : <any>undefined;
            this.exterior_glass_construction = _data["exterior_glass_construction"];
            this.interior_glass_construction = _data["interior_glass_construction"];
        }
    }

    static override fromJS(data: any): DoorConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new DoorConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["interior_construction"] = this.interior_construction ? this.interior_construction.toJSON() : <any>undefined;
        data["exterior_construction"] = this.exterior_construction ? this.exterior_construction.toJSON() : <any>undefined;
        data["overhead_construction"] = this.overhead_construction ? this.overhead_construction.toJSON() : <any>undefined;
        data["exterior_glass_construction"] = this.exterior_glass_construction;
        data["interior_glass_construction"] = this.interior_glass_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for door assemblies. */
export interface IDoorConstructionSet extends I_OpenAPIGenBaseModel {
    type?: string;
    /** An OpaqueConstruction for all opaque doors with a Surface boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for opaque doors with an Outdoors boundary condition and a Wall face type for their parent face. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for opaque doors with an Outdoors boundary condition and a RoofCeiling or Floor type for their parent face. */
    overhead_construction?: OpaqueConstruction;
    /** A WindowConstruction for all glass doors with an Outdoors boundary condition. */
    exterior_glass_construction?: Exterior_glass_construction;
    /** A WindowConstruction for all glass doors with a Surface boundary condition. */
    interior_glass_construction?: Interior_glass_construction;
}

/** Construction for Air Boundary objects. */
export class AirBoundaryConstruction extends IDdEnergyBaseModel implements IAirBoundaryConstruction {
    readonly type: string = "AirBoundaryConstruction";
    /** A positive number for the amount of air mixing between Rooms across the air boundary surface [m3/s-m2]. Default: 0.1 corresponds to average indoor air speeds of 0.1 m/s (roughly 20 fpm), which is typical of what would be induced by a HVAC system. */
    air_mixing_per_area?: number;
    /** A fractional schedule as a ScheduleRuleset or ScheduleFixedInterval for the air mixing schedule across the construction. If unspecified, an Always On schedule will be assumed. */
    air_mixing_schedule?: Air_mixing_schedule;

    constructor(data?: IAirBoundaryConstruction) {
        super(data);
        if (!data) {
            this.type = "AirBoundaryConstruction";
            this.air_mixing_per_area = 0.1;
        }
        this._discriminator = "AirBoundaryConstruction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "AirBoundaryConstruction";
            this.air_mixing_per_area = _data["air_mixing_per_area"] !== undefined ? _data["air_mixing_per_area"] : 0.1;
            this.air_mixing_schedule = _data["air_mixing_schedule"];
        }
    }

    static override fromJS(data: any): AirBoundaryConstruction {
        data = typeof data === 'object' ? data : {};
        let result = new AirBoundaryConstruction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["air_mixing_per_area"] = this.air_mixing_per_area;
        data["air_mixing_schedule"] = this.air_mixing_schedule;
        super.toJSON(data);
        return data;
    }
}

/** Construction for Air Boundary objects. */
export interface IAirBoundaryConstruction extends IIDdEnergyBaseModel {
    type?: string;
    /** A positive number for the amount of air mixing between Rooms across the air boundary surface [m3/s-m2]. Default: 0.1 corresponds to average indoor air speeds of 0.1 m/s (roughly 20 fpm), which is typical of what would be induced by a HVAC system. */
    air_mixing_per_area?: number;
    /** A fractional schedule as a ScheduleRuleset or ScheduleFixedInterval for the air mixing schedule across the construction. If unspecified, an Always On schedule will be assumed. */
    air_mixing_schedule?: Air_mixing_schedule;
}

/** A set of constructions for different surface types and boundary conditions. */
export class ConstructionSet extends IDdEnergyBaseModel implements IConstructionSet {
    readonly type: string = "ConstructionSet";
    /** A WallConstructionSet object for this ConstructionSet. */
    wall_set?: WallConstructionSet;
    /** A FloorConstructionSet object for this ConstructionSet. */
    floor_set?: FloorConstructionSet;
    /** A RoofCeilingConstructionSet object for this ConstructionSet. */
    roof_ceiling_set?: RoofCeilingConstructionSet;
    /** A ApertureConstructionSet object for this ConstructionSet. */
    aperture_set?: ApertureConstructionSet;
    /** A DoorConstructionSet object for this ConstructionSet. */
    door_set?: DoorConstructionSet;
    /** A ShadeConstruction to set the reflectance properties of all outdoor shades of all objects to which this ConstructionSet is assigned. */
    shade_construction?: ShadeConstruction;
    /** An AirBoundaryConstruction or OpaqueConstruction to set the properties of Faces with an AirBoundary type. */
    air_boundary_construction?: Air_boundary_construction;

    constructor(data?: IConstructionSet) {
        super(data);
        if (!data) {
            this.type = "ConstructionSet";
        }
        this._discriminator = "ConstructionSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ConstructionSet";
            this.wall_set = _data["wall_set"] ? WallConstructionSet.fromJS(_data["wall_set"]) : <any>undefined;
            this.floor_set = _data["floor_set"] ? FloorConstructionSet.fromJS(_data["floor_set"]) : <any>undefined;
            this.roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingConstructionSet.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            this.aperture_set = _data["aperture_set"] ? ApertureConstructionSet.fromJS(_data["aperture_set"]) : <any>undefined;
            this.door_set = _data["door_set"] ? DoorConstructionSet.fromJS(_data["door_set"]) : <any>undefined;
            this.shade_construction = _data["shade_construction"] ? ShadeConstruction.fromJS(_data["shade_construction"]) : <any>undefined;
            this.air_boundary_construction = _data["air_boundary_construction"];
        }
    }

    static override fromJS(data: any): ConstructionSet {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_construction"] = this.shade_construction ? this.shade_construction.toJSON() : <any>undefined;
        data["air_boundary_construction"] = this.air_boundary_construction;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for different surface types and boundary conditions. */
export interface IConstructionSet extends IIDdEnergyBaseModel {
    type?: string;
    /** A WallConstructionSet object for this ConstructionSet. */
    wall_set?: WallConstructionSet;
    /** A FloorConstructionSet object for this ConstructionSet. */
    floor_set?: FloorConstructionSet;
    /** A RoofCeilingConstructionSet object for this ConstructionSet. */
    roof_ceiling_set?: RoofCeilingConstructionSet;
    /** A ApertureConstructionSet object for this ConstructionSet. */
    aperture_set?: ApertureConstructionSet;
    /** A DoorConstructionSet object for this ConstructionSet. */
    door_set?: DoorConstructionSet;
    /** A ShadeConstruction to set the reflectance properties of all outdoor shades of all objects to which this ConstructionSet is assigned. */
    shade_construction?: ShadeConstruction;
    /** An AirBoundaryConstruction or OpaqueConstruction to set the properties of Faces with an AirBoundary type. */
    air_boundary_construction?: Air_boundary_construction;
}

/** An enumeration. */
export enum EconomizerType {
    NoEconomizer = "NoEconomizer",
    DifferentialDryBulb = "DifferentialDryBulb",
    DifferentialEnthalpy = "DifferentialEnthalpy",
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Autosize extends _OpenAPIGenBaseModel implements IAutosize {
    readonly type: string = "Autosize";

    constructor(data?: IAutosize) {
        super(data);
        if (!data) {
            this.type = "Autosize";
        }
        this._discriminator = "Autosize";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Autosize";
        }
    }

    static override fromJS(data: any): Autosize {
        data = typeof data === 'object' ? data : {};
        let result = new Autosize();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IAutosize extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** Provides a model for an ideal HVAC system. */
export class IdealAirSystemAbridged extends IDdEnergyBaseModel implements IIdealAirSystemAbridged {
    readonly type: string = "IdealAirSystemAbridged";
    /** Text to indicate the type of air-side economizer used on the ideal air system. Economizers will mix in a greater amount of outdoor air to cool the zone (rather than running the cooling system) when the zone needs cooling and the outdoor air is cooler than the zone. */
    economizer_type?: EconomizerType;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the zone. */
    demand_controlled_ventilation?: boolean;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** A number for the maximum heating supply air temperature [C]. */
    heating_air_temperature?: number;
    /** A number for the minimum cooling supply air temperature [C]. */
    cooling_air_temperature?: number;
    /** A number for the maximum heating capacity in Watts. This can also be an Autosize object to indicate that the capacity should be determined during the EnergyPlus sizing calculation. This can also be a NoLimit object to indicate no upper limit to the heating capacity. */
    heating_limit?: Heating_limit;
    /** A number for the maximum cooling capacity in Watts. This can also be an Autosize object to indicate that the capacity should be determined during the EnergyPlus sizing calculation. This can also be a NoLimit object to indicate no upper limit to the cooling capacity. */
    cooling_limit?: Cooling_limit;
    /** An optional identifier of a schedule to set the availability of heating over the course of the simulation. */
    heating_availability?: string;
    /** An optional identifier of a schedule to set the availability of cooling over the course of the simulation. */
    cooling_availability?: string;

    constructor(data?: IIdealAirSystemAbridged) {
        super(data);
        if (!data) {
            this.type = "IdealAirSystemAbridged";
            this.economizer_type = EconomizerType.DifferentialDryBulb;
            this.demand_controlled_ventilation = false;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.heating_air_temperature = 50;
            this.cooling_air_temperature = 13;
        }
        this._discriminator = "IdealAirSystemAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "IdealAirSystemAbridged";
            this.economizer_type = _data["economizer_type"] !== undefined ? _data["economizer_type"] : EconomizerType.DifferentialDryBulb;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.heating_air_temperature = _data["heating_air_temperature"] !== undefined ? _data["heating_air_temperature"] : 50;
            this.cooling_air_temperature = _data["cooling_air_temperature"] !== undefined ? _data["cooling_air_temperature"] : 13;
            this.heating_limit = _data["heating_limit"];
            this.cooling_limit = _data["cooling_limit"];
            this.heating_availability = _data["heating_availability"];
            this.cooling_availability = _data["cooling_availability"];
        }
    }

    static override fromJS(data: any): IdealAirSystemAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new IdealAirSystemAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["economizer_type"] = this.economizer_type;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["heating_air_temperature"] = this.heating_air_temperature;
        data["cooling_air_temperature"] = this.cooling_air_temperature;
        data["heating_limit"] = this.heating_limit;
        data["cooling_limit"] = this.cooling_limit;
        data["heating_availability"] = this.heating_availability;
        data["cooling_availability"] = this.cooling_availability;
        super.toJSON(data);
        return data;
    }
}

/** Provides a model for an ideal HVAC system. */
export interface IIdealAirSystemAbridged extends IIDdEnergyBaseModel {
    type?: string;
    /** Text to indicate the type of air-side economizer used on the ideal air system. Economizers will mix in a greater amount of outdoor air to cool the zone (rather than running the cooling system) when the zone needs cooling and the outdoor air is cooler than the zone. */
    economizer_type?: EconomizerType;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the zone. */
    demand_controlled_ventilation?: boolean;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** A number for the maximum heating supply air temperature [C]. */
    heating_air_temperature?: number;
    /** A number for the minimum cooling supply air temperature [C]. */
    cooling_air_temperature?: number;
    /** A number for the maximum heating capacity in Watts. This can also be an Autosize object to indicate that the capacity should be determined during the EnergyPlus sizing calculation. This can also be a NoLimit object to indicate no upper limit to the heating capacity. */
    heating_limit?: Heating_limit;
    /** A number for the maximum cooling capacity in Watts. This can also be an Autosize object to indicate that the capacity should be determined during the EnergyPlus sizing calculation. This can also be a NoLimit object to indicate no upper limit to the cooling capacity. */
    cooling_limit?: Cooling_limit;
    /** An optional identifier of a schedule to set the availability of heating over the course of the simulation. */
    heating_availability?: string;
    /** An optional identifier of a schedule to set the availability of cooling over the course of the simulation. */
    cooling_availability?: string;
}

/** An enumeration. */
export enum Vintages {
    ASHRAE_2019 = "ASHRAE_2019",
    ASHRAE_2016 = "ASHRAE_2016",
    ASHRAE_2013 = "ASHRAE_2013",
    ASHRAE_2010 = "ASHRAE_2010",
    ASHRAE_2007 = "ASHRAE_2007",
    ASHRAE_2004 = "ASHRAE_2004",
    DOE_Ref_1980_2004 = "DOE_Ref_1980_2004",
    DOE_Ref_Pre_1980 = "DOE_Ref_Pre_1980",
}

/** An enumeration. */
export enum AllAirEconomizerType {
    NoEconomizer = "NoEconomizer",
    DifferentialDryBulb = "DifferentialDryBulb",
    DifferentialEnthalpy = "DifferentialEnthalpy",
    DifferentialDryBulbAndEnthalpy = "DifferentialDryBulbAndEnthalpy",
    FixedDryBulb = "FixedDryBulb",
    FixedEnthalpy = "FixedEnthalpy",
    ElectronicEnthalpy = "ElectronicEnthalpy",
}

/** An enumeration. */
export enum VAVEquipmentType {
    VAV_Chiller_Boiler = "VAV_Chiller_Boiler",
    VAV_Chiller_ASHP = "VAV_Chiller_ASHP",
    VAV_Chiller_DHW = "VAV_Chiller_DHW",
    VAV_Chiller_PFP = "VAV_Chiller_PFP",
    VAV_Chiller_GasCoil = "VAV_Chiller_GasCoil",
    VAV_ACChiller_Boiler = "VAV_ACChiller_Boiler",
    VAV_ACChiller_ASHP = "VAV_ACChiller_ASHP",
    VAV_ACChiller_DHW = "VAV_ACChiller_DHW",
    VAV_ACChiller_PFP = "VAV_ACChiller_PFP",
    VAV_ACChiller_GasCoil = "VAV_ACChiller_GasCoil",
    VAV_DCW_Boiler = "VAV_DCW_Boiler",
    VAV_DCW_ASHP = "VAV_DCW_ASHP",
    VAV_DCW_DHW = "VAV_DCW_DHW",
    VAV_DCW_PFP = "VAV_DCW_PFP",
    VAV_DCW_GasCoil = "VAV_DCW_GasCoil",
}

/** Variable Air Volume (VAV) HVAC system (aka. System 7 or 8). All rooms/zones are connected to a central air loop that is kept at a constant central temperature of 12.8C (55F). The central temperature is maintained by a cooling coil, which runs whenever the combination of return air and fresh outdoor air is greater than 12.8C, as well as a heating coil, which runs whenever the combination of return air and fresh outdoor air is less than 12.8C. Each air terminal for the connected rooms/zones contains its own reheat coil, which runs whenever the room is not in need of the cooling supplied by the 12.8C central air. The central cooling coil is always a chilled water coil, which is connected to a chilled water loop operating at 6.7C (44F). All heating coils are hot water coils except when Gas Coil equipment_type is used (in which case coils are gas) or when Parallel Fan-Powered (PFP) boxes equipment_type is used (in which case coils are electric resistance). Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. VAV systems are the traditional baseline system for commercial buildings taller than 5 stories or larger than 14,000 m2 (150,000 ft2) of floor area. */
export class VAV extends IDdEnergyBaseModel implements IVAV {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    readonly type: string = "VAV";
    /** Text for the specific type of system equipment from the VAVEquipmentType enumeration. */
    equipment_type?: VAVEquipmentType;

    constructor(data?: IVAV) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.economizer_type = AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "VAV";
            this.equipment_type = VAVEquipmentType.VAV_Chiller_Boiler;
        }
        this._discriminator = "VAV";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.economizer_type = _data["economizer_type"] !== undefined ? _data["economizer_type"] : AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VAV";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : VAVEquipmentType.VAV_Chiller_Boiler;
        }
    }

    static override fromJS(data: any): VAV {
        data = typeof data === 'object' ? data : {};
        let result = new VAV();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["economizer_type"] = this.economizer_type;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Variable Air Volume (VAV) HVAC system (aka. System 7 or 8). All rooms/zones are connected to a central air loop that is kept at a constant central temperature of 12.8C (55F). The central temperature is maintained by a cooling coil, which runs whenever the combination of return air and fresh outdoor air is greater than 12.8C, as well as a heating coil, which runs whenever the combination of return air and fresh outdoor air is less than 12.8C. Each air terminal for the connected rooms/zones contains its own reheat coil, which runs whenever the room is not in need of the cooling supplied by the 12.8C central air. The central cooling coil is always a chilled water coil, which is connected to a chilled water loop operating at 6.7C (44F). All heating coils are hot water coils except when Gas Coil equipment_type is used (in which case coils are gas) or when Parallel Fan-Powered (PFP) boxes equipment_type is used (in which case coils are electric resistance). Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. VAV systems are the traditional baseline system for commercial buildings taller than 5 stories or larger than 14,000 m2 (150,000 ft2) of floor area. */
export interface IVAV extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    type?: string;
    /** Text for the specific type of system equipment from the VAVEquipmentType enumeration. */
    equipment_type?: VAVEquipmentType;
}

/** An enumeration. */
export enum PVAVEquipmentType {
    PVAV_Boiler = "PVAV_Boiler",
    PVAV_ASHP = "PVAV_ASHP",
    PVAV_DHW = "PVAV_DHW",
    PVAV_PFP = "PVAV_PFP",
    PVAV_BoilerElectricReheat = "PVAV_BoilerElectricReheat",
}

/** Packaged Variable Air Volume (PVAV) HVAC system (aka. System 5 or 6). All rooms/zones are connected to a central air loop that is kept at a constant central temperature of 12.8C (55F). The central temperature is maintained by a cooling coil, which runs whenever the combination of return air and fresh outdoor air is greater than 12.8C, as well as a heating coil, which runs whenever the combination of return air and fresh outdoor air is less than 12.8C. Each air terminal for the connected rooms/zones contains its own reheat coil, which runs whenever the room is not in need of the cooling supplied by the 12.8C central air. The central cooling coil is always a two-speed direct expansion (DX) coil. All heating coils are hot water coils except when Gas Coil equipment_type is used (in which case the central coil is gas and all reheat is electric) or when Parallel Fan-Powered (PFP) boxes equipment_type is used (in which case coils are electric resistance). Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. PVAV systems are the traditional baseline system for commercial buildings with than 4-5 stories or between 2,300 m2 and 14,000 m2 (25,000 ft2 and 150,000 ft2) of floor area. */
export class PVAV extends IDdEnergyBaseModel implements IPVAV {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    readonly type: string = "PVAV";
    /** Text for the specific type of system equipment from the VAVEquipmentType enumeration. */
    equipment_type?: PVAVEquipmentType;

    constructor(data?: IPVAV) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.economizer_type = AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "PVAV";
            this.equipment_type = PVAVEquipmentType.PVAV_Boiler;
        }
        this._discriminator = "PVAV";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.economizer_type = _data["economizer_type"] !== undefined ? _data["economizer_type"] : AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "PVAV";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : PVAVEquipmentType.PVAV_Boiler;
        }
    }

    static override fromJS(data: any): PVAV {
        data = typeof data === 'object' ? data : {};
        let result = new PVAV();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["economizer_type"] = this.economizer_type;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Packaged Variable Air Volume (PVAV) HVAC system (aka. System 5 or 6). All rooms/zones are connected to a central air loop that is kept at a constant central temperature of 12.8C (55F). The central temperature is maintained by a cooling coil, which runs whenever the combination of return air and fresh outdoor air is greater than 12.8C, as well as a heating coil, which runs whenever the combination of return air and fresh outdoor air is less than 12.8C. Each air terminal for the connected rooms/zones contains its own reheat coil, which runs whenever the room is not in need of the cooling supplied by the 12.8C central air. The central cooling coil is always a two-speed direct expansion (DX) coil. All heating coils are hot water coils except when Gas Coil equipment_type is used (in which case the central coil is gas and all reheat is electric) or when Parallel Fan-Powered (PFP) boxes equipment_type is used (in which case coils are electric resistance). Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. PVAV systems are the traditional baseline system for commercial buildings with than 4-5 stories or between 2,300 m2 and 14,000 m2 (25,000 ft2 and 150,000 ft2) of floor area. */
export interface IPVAV extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    type?: string;
    /** Text for the specific type of system equipment from the VAVEquipmentType enumeration. */
    equipment_type?: PVAVEquipmentType;
}

/** An enumeration. */
export enum PSZEquipmentType {
    PSZAC_ElectricBaseboard = "PSZAC_ElectricBaseboard",
    PSZAC_BoilerBaseboard = "PSZAC_BoilerBaseboard",
    PSZAC_DHWBaseboard = "PSZAC_DHWBaseboard",
    PSZAC_GasHeaters = "PSZAC_GasHeaters",
    PSZAC_ElectricCoil = "PSZAC_ElectricCoil",
    PSZAC_GasCoil = "PSZAC_GasCoil",
    PSZAC_Boiler = "PSZAC_Boiler",
    PSZAC_ASHP = "PSZAC_ASHP",
    PSZAC_DHW = "PSZAC_DHW",
    PSZAC = "PSZAC",
    PSZAC_DCW_ElectricBaseboard = "PSZAC_DCW_ElectricBaseboard",
    PSZAC_DCW_BoilerBaseboard = "PSZAC_DCW_BoilerBaseboard",
    PSZAC_DCW_GasHeaters = "PSZAC_DCW_GasHeaters",
    PSZAC_DCW_ElectricCoil = "PSZAC_DCW_ElectricCoil",
    PSZAC_DCW_GasCoil = "PSZAC_DCW_GasCoil",
    PSZAC_DCW_Boiler = "PSZAC_DCW_Boiler",
    PSZAC_DCW_ASHP = "PSZAC_DCW_ASHP",
    PSZAC_DCW_DHW = "PSZAC_DCW_DHW",
    PSZAC_DCW = "PSZAC_DCW",
    PSZHP = "PSZHP",
}

/** Packaged Single-Zone (PSZ) HVAC system (aka. System 3 or 4). Each room/zone receives its own air loop with its own single-speed direct expansion (DX) cooling coil, which will condition the supply air to a value in between 12.8C (55F) and 50C (122F) depending on the heating/cooling needs of the room/zone. As long as a Baseboard equipment_type is NOT selected, heating will be supplied by a heating coil in the air loop. Otherwise, heating is accomplished with baseboards and the air loop only supplies cooling and ventilation air. Fans are constant volume. PSZ systems are the traditional baseline system for commercial buildings with less than 4 stories or less than 2,300 m2 (25,000 ft2) of floor area. They are also the default for all retail with less than 3 stories and all public assembly spaces. */
export class PSZ extends IDdEnergyBaseModel implements IPSZ {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    readonly type: string = "PSZ";
    /** Text for the specific type of system equipment from the PVAVEquipmentType enumeration. */
    equipment_type?: PSZEquipmentType;

    constructor(data?: IPSZ) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.economizer_type = AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "PSZ";
            this.equipment_type = PSZEquipmentType.PSZAC_ElectricBaseboard;
        }
        this._discriminator = "PSZ";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.economizer_type = _data["economizer_type"] !== undefined ? _data["economizer_type"] : AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "PSZ";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : PSZEquipmentType.PSZAC_ElectricBaseboard;
        }
    }

    static override fromJS(data: any): PSZ {
        data = typeof data === 'object' ? data : {};
        let result = new PSZ();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["economizer_type"] = this.economizer_type;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Packaged Single-Zone (PSZ) HVAC system (aka. System 3 or 4). Each room/zone receives its own air loop with its own single-speed direct expansion (DX) cooling coil, which will condition the supply air to a value in between 12.8C (55F) and 50C (122F) depending on the heating/cooling needs of the room/zone. As long as a Baseboard equipment_type is NOT selected, heating will be supplied by a heating coil in the air loop. Otherwise, heating is accomplished with baseboards and the air loop only supplies cooling and ventilation air. Fans are constant volume. PSZ systems are the traditional baseline system for commercial buildings with less than 4 stories or less than 2,300 m2 (25,000 ft2) of floor area. They are also the default for all retail with less than 3 stories and all public assembly spaces. */
export interface IPSZ extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    type?: string;
    /** Text for the specific type of system equipment from the PVAVEquipmentType enumeration. */
    equipment_type?: PSZEquipmentType;
}

/** An enumeration. */
export enum PTACEquipmentType {
    PTAC_ElectricBaseboard = "PTAC_ElectricBaseboard",
    PTAC_BoilerBaseboard = "PTAC_BoilerBaseboard",
    PTAC_DHWBaseboard = "PTAC_DHWBaseboard",
    PTAC_GasHeaters = "PTAC_GasHeaters",
    PTAC_ElectricCoil = "PTAC_ElectricCoil",
    PTAC_GasCoil = "PTAC_GasCoil",
    PTAC_Boiler = "PTAC_Boiler",
    PTAC_ASHP = "PTAC_ASHP",
    PTAC_DHW = "PTAC_DHW",
    PTAC = "PTAC",
    PTHP = "PTHP",
}

/** Packaged Terminal Air Conditioning (PTAC/HP) HVAC system. (aka. System 1 or 2). Each room/zone receives its own packaged unit that supplies heating, cooling and ventilation. Cooling is always done via a single-speed direct expansion (DX) cooling coil. Heating can be done via a heating coil in the unit or via an external baseboard. Fans are constant volume. PTAC/HP systems are the traditional baseline system for residential buildings. */
export class PTAC extends IDdEnergyBaseModel implements IPTAC {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "PTAC";
    /** Text for the specific type of system equipment from the PTACEquipmentType enumeration. */
    equipment_type?: PTACEquipmentType;

    constructor(data?: IPTAC) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "PTAC";
            this.equipment_type = PTACEquipmentType.PTAC_ElectricBaseboard;
        }
        this._discriminator = "PTAC";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "PTAC";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : PTACEquipmentType.PTAC_ElectricBaseboard;
        }
    }

    static override fromJS(data: any): PTAC {
        data = typeof data === 'object' ? data : {};
        let result = new PTAC();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Packaged Terminal Air Conditioning (PTAC/HP) HVAC system. (aka. System 1 or 2). Each room/zone receives its own packaged unit that supplies heating, cooling and ventilation. Cooling is always done via a single-speed direct expansion (DX) cooling coil. Heating can be done via a heating coil in the unit or via an external baseboard. Fans are constant volume. PTAC/HP systems are the traditional baseline system for residential buildings. */
export interface IPTAC extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the PTACEquipmentType enumeration. */
    equipment_type?: PTACEquipmentType;
}

/** An enumeration. */
export enum FurnaceEquipmentType {
    Furnace = "Furnace",
    Furnace_Electric = "Furnace_Electric",
}

/** Forced Air Furnace HVAC system (aka. System 9 or 10). Forced air furnaces are intended only for spaces only requiring heating and ventilation. Each room/zone receives its own air loop with its own gas heating coil, which will supply air at a temperature up to 50C (122F) to meet the heating needs of the room/zone. Fans are constant volume. ForcedAirFurnace systems are the traditional baseline system for storage spaces that only require heating. */
export class ForcedAirFurnace extends IDdEnergyBaseModel implements IForcedAirFurnace {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "ForcedAirFurnace";
    /** Text for the specific type of system equipment from the FurnaceEquipmentType enumeration. */
    equipment_type?: FurnaceEquipmentType;

    constructor(data?: IForcedAirFurnace) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "ForcedAirFurnace";
            this.equipment_type = FurnaceEquipmentType.Furnace;
        }
        this._discriminator = "ForcedAirFurnace";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ForcedAirFurnace";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : FurnaceEquipmentType.Furnace;
        }
    }

    static override fromJS(data: any): ForcedAirFurnace {
        data = typeof data === 'object' ? data : {};
        let result = new ForcedAirFurnace();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Forced Air Furnace HVAC system (aka. System 9 or 10). Forced air furnaces are intended only for spaces only requiring heating and ventilation. Each room/zone receives its own air loop with its own gas heating coil, which will supply air at a temperature up to 50C (122F) to meet the heating needs of the room/zone. Fans are constant volume. ForcedAirFurnace systems are the traditional baseline system for storage spaces that only require heating. */
export interface IForcedAirFurnace extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the FurnaceEquipmentType enumeration. */
    equipment_type?: FurnaceEquipmentType;
}

/** An enumeration. */
export enum FCUwithDOASEquipmentType {
    DOAS_FCU_Chiller_Boiler = "DOAS_FCU_Chiller_Boiler",
    DOAS_FCU_Chiller_ASHP = "DOAS_FCU_Chiller_ASHP",
    DOAS_FCU_Chiller_DHW = "DOAS_FCU_Chiller_DHW",
    DOAS_FCU_Chiller_ElectricBaseboard = "DOAS_FCU_Chiller_ElectricBaseboard",
    DOAS_FCU_Chiller_GasHeaters = "DOAS_FCU_Chiller_GasHeaters",
    DOAS_FCU_Chiller = "DOAS_FCU_Chiller",
    DOAS_FCU_ACChiller_Boiler = "DOAS_FCU_ACChiller_Boiler",
    DOAS_FCU_ACChiller_ASHP = "DOAS_FCU_ACChiller_ASHP",
    DOAS_FCU_ACChiller_DHW = "DOAS_FCU_ACChiller_DHW",
    DOAS_FCU_ACChiller_ElectricBaseboard = "DOAS_FCU_ACChiller_ElectricBaseboard",
    DOAS_FCU_ACChiller_GasHeaters = "DOAS_FCU_ACChiller_GasHeaters",
    DOAS_FCU_ACChiller = "DOAS_FCU_ACChiller",
    DOAS_FCU_DCW_Boiler = "DOAS_FCU_DCW_Boiler",
    DOAS_FCU_DCW_ASHP = "DOAS_FCU_DCW_ASHP",
    DOAS_FCU_DCW_DHW = "DOAS_FCU_DCW_DHW",
    DOAS_FCU_DCW_ElectricBaseboard = "DOAS_FCU_DCW_ElectricBaseboard",
    DOAS_FCU_DCW_GasHeaters = "DOAS_FCU_DCW_GasHeaters",
    DOAS_FCU_DCW = "DOAS_FCU_DCW",
}

/** Fan Coil Unit (FCU) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a chilled water cooling coil and a heating coil. The heating coil is a hot water coil except when electric baseboards or gas heaters are specified, in which case the heating coil is a single-speed direct expansion (DX) heat pump with a backup electrical resistance coil. Each room/zone also receives its own Fan Coil Unit (FCU), which meets the heating and cooling loads of the space. The cooling coil in the FCU is always chilled water cooling coil, which is connected to a chilled water loop operating at 6.7C (44F). The heating coil is a hot water coil except when when electric baseboards or gas heaters are specified. Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. The FCU with DOAS template is relatively close in performance to active chilled beams (ACBs). When using this template to represent ACBs, care must be taken to ensure that the DOAS ventilation air requirement is sufficient to extract the heating cooling from the ACB. If so, then this FCUwithDOAS template can be used but with the energy use of the FCU fans ignored. */
export class FCUwithDOASAbridged extends IDdEnergyBaseModel implements IFCUwithDOASAbridged {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    readonly type: string = "FCUwithDOASAbridged";
    /** Text for the specific type of system equipment from the FCUwithDOASEquipmentType enumeration. */
    equipment_type?: FCUwithDOASEquipmentType;

    constructor(data?: IFCUwithDOASAbridged) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "FCUwithDOASAbridged";
            this.equipment_type = FCUwithDOASEquipmentType.DOAS_FCU_Chiller_Boiler;
        }
        this._discriminator = "FCUwithDOASAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.doas_availability_schedule = _data["doas_availability_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FCUwithDOASAbridged";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : FCUwithDOASEquipmentType.DOAS_FCU_Chiller_Boiler;
        }
    }

    static override fromJS(data: any): FCUwithDOASAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FCUwithDOASAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["doas_availability_schedule"] = this.doas_availability_schedule;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Fan Coil Unit (FCU) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a chilled water cooling coil and a heating coil. The heating coil is a hot water coil except when electric baseboards or gas heaters are specified, in which case the heating coil is a single-speed direct expansion (DX) heat pump with a backup electrical resistance coil. Each room/zone also receives its own Fan Coil Unit (FCU), which meets the heating and cooling loads of the space. The cooling coil in the FCU is always chilled water cooling coil, which is connected to a chilled water loop operating at 6.7C (44F). The heating coil is a hot water coil except when when electric baseboards or gas heaters are specified. Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. The FCU with DOAS template is relatively close in performance to active chilled beams (ACBs). When using this template to represent ACBs, care must be taken to ensure that the DOAS ventilation air requirement is sufficient to extract the heating cooling from the ACB. If so, then this FCUwithDOAS template can be used but with the energy use of the FCU fans ignored. */
export interface IFCUwithDOASAbridged extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    type?: string;
    /** Text for the specific type of system equipment from the FCUwithDOASEquipmentType enumeration. */
    equipment_type?: FCUwithDOASEquipmentType;
}

/** An enumeration. */
export enum WSHPwithDOASEquipmentType {
    DOAS_WSHP_FluidCooler_Boiler = "DOAS_WSHP_FluidCooler_Boiler",
    DOAS_WSHP_CoolingTower_Boiler = "DOAS_WSHP_CoolingTower_Boiler",
    DOAS_WSHP_GSHP = "DOAS_WSHP_GSHP",
    DOAS_WSHP_DCW_DHW = "DOAS_WSHP_DCW_DHW",
}

/** Water Source Heat Pump (WSHP) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a chilled water cooling coil and a hot water heating coil except when the ground source heat pump (GSHP) option is selected. In this case, the ventilation air temperature is maintained by a two-speed direct expansion (DX) cooling coil and a single-speed DX heating coil with backup electrical resistance heat. Each room/zone also receives its own Water Source Heat Pump (WSHP), which meets the heating and cooling loads of the space. All WSHPs are connected to the same water condenser loop, which has its temperature maintained by the equipment_type (eg. Boiler with Cooling Tower). */
export class WSHPwithDOASAbridged extends IDdEnergyBaseModel implements IWSHPwithDOASAbridged {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    readonly type: string = "WSHPwithDOASAbridged";
    /** Text for the specific type of system equipment from the WSHPwithDOASEquipmentType enumeration. */
    equipment_type?: WSHPwithDOASEquipmentType;

    constructor(data?: IWSHPwithDOASAbridged) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "WSHPwithDOASAbridged";
            this.equipment_type = WSHPwithDOASEquipmentType.DOAS_WSHP_FluidCooler_Boiler;
        }
        this._discriminator = "WSHPwithDOASAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.doas_availability_schedule = _data["doas_availability_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WSHPwithDOASAbridged";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : WSHPwithDOASEquipmentType.DOAS_WSHP_FluidCooler_Boiler;
        }
    }

    static override fromJS(data: any): WSHPwithDOASAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new WSHPwithDOASAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["doas_availability_schedule"] = this.doas_availability_schedule;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Water Source Heat Pump (WSHP) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a chilled water cooling coil and a hot water heating coil except when the ground source heat pump (GSHP) option is selected. In this case, the ventilation air temperature is maintained by a two-speed direct expansion (DX) cooling coil and a single-speed DX heating coil with backup electrical resistance heat. Each room/zone also receives its own Water Source Heat Pump (WSHP), which meets the heating and cooling loads of the space. All WSHPs are connected to the same water condenser loop, which has its temperature maintained by the equipment_type (eg. Boiler with Cooling Tower). */
export interface IWSHPwithDOASAbridged extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    type?: string;
    /** Text for the specific type of system equipment from the WSHPwithDOASEquipmentType enumeration. */
    equipment_type?: WSHPwithDOASEquipmentType;
}

/** An enumeration. */
export enum VRFwithDOASEquipmentType {
    DOAS_VRF = "DOAS_VRF",
}

/** Variable Refrigerant Flow (VRF) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a single speed direct expansion (DX) cooling coil along with a single-speed direct expansion (DX) heat pump with a backup electrical resistance coil. Each room/zone also receives its own Variable Refrigerant Flow (VRF) terminal, which meets the heating and cooling loads of the space. All room/zone terminals are connected to the same outdoor unit, meaning that either all rooms must be in cooling or heating mode together. */
export class VRFwithDOASAbridged extends IDdEnergyBaseModel implements IVRFwithDOASAbridged {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    readonly type: string = "VRFwithDOASAbridged";
    /** Text for the specific type of system equipment from the VRFwithDOASEquipmentType enumeration. */
    equipment_type?: VRFwithDOASEquipmentType;

    constructor(data?: IVRFwithDOASAbridged) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "VRFwithDOASAbridged";
            this.equipment_type = VRFwithDOASEquipmentType.DOAS_VRF;
        }
        this._discriminator = "VRFwithDOASAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.doas_availability_schedule = _data["doas_availability_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VRFwithDOASAbridged";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : VRFwithDOASEquipmentType.DOAS_VRF;
        }
    }

    static override fromJS(data: any): VRFwithDOASAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new VRFwithDOASAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["doas_availability_schedule"] = this.doas_availability_schedule;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Variable Refrigerant Flow (VRF) with DOAS HVAC system. All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a single speed direct expansion (DX) cooling coil along with a single-speed direct expansion (DX) heat pump with a backup electrical resistance coil. Each room/zone also receives its own Variable Refrigerant Flow (VRF) terminal, which meets the heating and cooling loads of the space. All room/zone terminals are connected to the same outdoor unit, meaning that either all rooms must be in cooling or heating mode together. */
export interface IVRFwithDOASAbridged extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    type?: string;
    /** Text for the specific type of system equipment from the VRFwithDOASEquipmentType enumeration. */
    equipment_type?: VRFwithDOASEquipmentType;
}

/** An enumeration. */
export enum RadiantwithDOASEquipmentType {
    DOAS_Radiant_Chiller_Boiler = "DOAS_Radiant_Chiller_Boiler",
    DOAS_Radiant_Chiller_ASHP = "DOAS_Radiant_Chiller_ASHP",
    DOAS_Radiant_Chiller_DHW = "DOAS_Radiant_Chiller_DHW",
    DOAS_Radiant_ACChiller_Boiler = "DOAS_Radiant_ACChiller_Boiler",
    DOAS_Radiant_ACChiller_ASHP = "DOAS_Radiant_ACChiller_ASHP",
    DOAS_Radiant_ACChiller_DHW = "DOAS_Radiant_ACChiller_DHW",
    DOAS_Radiant_DCW_Boiler = "DOAS_Radiant_DCW_Boiler",
    DOAS_Radiant_DCW_ASHP = "DOAS_Radiant_DCW_ASHP",
    DOAS_Radiant_DCW_DHW = "DOAS_Radiant_DCW_DHW",
}

/** An enumeration. */
export enum RadiantFaceTypes {
    Floor = "Floor",
    Ceiling = "Ceiling",
    FloorWithCarpet = "FloorWithCarpet",
    CeilingMetalPanel = "CeilingMetalPanel",
    FloorWithHardwood = "FloorWithHardwood",
}

/** Low Temperature Radiant with DOAS HVAC system. This HVAC template will change the floor and/or ceiling constructions of the Rooms that it is applied to, replacing them with a construction that aligns with the radiant_type property (eg. CeilingMetalPanel). All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a two-speed direct expansion (DX) cooling coil and a single-speed DX heating coil with backup electrical resistance heat. The heating and cooling needs of the space are met with the radiant constructions, which use chilled water at 12.8C (55F) and a hot water temperature somewhere between 32.2C (90F) and 49C (120F) (warmer temperatures are used in colder climate zones). Note that radiant systems are particularly limited in cooling capacity and using them may result in many unmet hours. To reduce unmet hours, one can remove carpets, reduce internal loads, reduce solar and envelope gains during peak times, add thermal mass, and use an expanded comfort range. */
export class RadiantwithDOASAbridged extends IDdEnergyBaseModel implements IRadiantwithDOASAbridged {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    readonly type: string = "RadiantwithDOASAbridged";
    /** Text for the specific type of system equipment from the RadiantwithDOASEquipmentType enumeration. */
    equipment_type?: RadiantwithDOASEquipmentType;
    /** Text to indicate which faces are thermally active by default. Note that this property has no effect when the rooms to which the HVAC system is assigned have constructions with internal source materials. In this case, those constructions will dictate the thermally active surfaces. */
    radiant_face_type?: RadiantFaceTypes;
    /** A number for the minimum number of hours of operation for the radiant system before it shuts off. */
    minimum_operation_time?: number;
    /** A number for the minimum number of hours for when the system can switch between heating and cooling. */
    switch_over_time?: number;

    constructor(data?: IRadiantwithDOASAbridged) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "RadiantwithDOASAbridged";
            this.equipment_type = RadiantwithDOASEquipmentType.DOAS_Radiant_Chiller_Boiler;
            this.radiant_face_type = RadiantFaceTypes.Floor;
            this.minimum_operation_time = 1;
            this.switch_over_time = 24;
        }
        this._discriminator = "RadiantwithDOASAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.doas_availability_schedule = _data["doas_availability_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RadiantwithDOASAbridged";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : RadiantwithDOASEquipmentType.DOAS_Radiant_Chiller_Boiler;
            this.radiant_face_type = _data["radiant_face_type"] !== undefined ? _data["radiant_face_type"] : RadiantFaceTypes.Floor;
            this.minimum_operation_time = _data["minimum_operation_time"] !== undefined ? _data["minimum_operation_time"] : 1;
            this.switch_over_time = _data["switch_over_time"] !== undefined ? _data["switch_over_time"] : 24;
        }
    }

    static override fromJS(data: any): RadiantwithDOASAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RadiantwithDOASAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["doas_availability_schedule"] = this.doas_availability_schedule;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        data["radiant_face_type"] = this.radiant_face_type;
        data["minimum_operation_time"] = this.minimum_operation_time;
        data["switch_over_time"] = this.switch_over_time;
        super.toJSON(data);
        return data;
    }
}

/** Low Temperature Radiant with DOAS HVAC system. This HVAC template will change the floor and/or ceiling constructions of the Rooms that it is applied to, replacing them with a construction that aligns with the radiant_type property (eg. CeilingMetalPanel). All rooms/zones in the system are connected to a Dedicated Outdoor Air System (DOAS) that supplies a constant volume of ventilation air at the same temperature to all rooms/zones. The ventilation air temperature will vary from 21.1C (70F) to 15.5C (60F) depending on the outdoor air temperature (the DOAS supplies cooler air when outdoor conditions are warmer). The ventilation air temperature is maintained by a two-speed direct expansion (DX) cooling coil and a single-speed DX heating coil with backup electrical resistance heat. The heating and cooling needs of the space are met with the radiant constructions, which use chilled water at 12.8C (55F) and a hot water temperature somewhere between 32.2C (90F) and 49C (120F) (warmer temperatures are used in colder climate zones). Note that radiant systems are particularly limited in cooling capacity and using them may result in many unmet hours. To reduce unmet hours, one can remove carpets, reduce internal loads, reduce solar and envelope gains during peak times, add thermal mass, and use an expanded comfort range. */
export interface IRadiantwithDOASAbridged extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    type?: string;
    /** Text for the specific type of system equipment from the RadiantwithDOASEquipmentType enumeration. */
    equipment_type?: RadiantwithDOASEquipmentType;
    /** Text to indicate which faces are thermally active by default. Note that this property has no effect when the rooms to which the HVAC system is assigned have constructions with internal source materials. In this case, those constructions will dictate the thermally active surfaces. */
    radiant_face_type?: RadiantFaceTypes;
    /** A number for the minimum number of hours of operation for the radiant system before it shuts off. */
    minimum_operation_time?: number;
    /** A number for the minimum number of hours for when the system can switch between heating and cooling. */
    switch_over_time?: number;
}

/** An enumeration. */
export enum FCUEquipmentType {
    FCU_Chiller_Boiler = "FCU_Chiller_Boiler",
    FCU_Chiller_ASHP = "FCU_Chiller_ASHP",
    FCU_Chiller_DHW = "FCU_Chiller_DHW",
    FCU_Chiller_ElectricBaseboard = "FCU_Chiller_ElectricBaseboard",
    FCU_Chiller_GasHeaters = "FCU_Chiller_GasHeaters",
    FCU_Chiller = "FCU_Chiller",
    FCU_ACChiller_Boiler = "FCU_ACChiller_Boiler",
    FCU_ACChiller_ASHP = "FCU_ACChiller_ASHP",
    FCU_ACChiller_DHW = "FCU_ACChiller_DHW",
    FCU_ACChiller_ElectricBaseboard = "FCU_ACChiller_ElectricBaseboard",
    FCU_ACChiller_GasHeaters = "FCU_ACChiller_GasHeaters",
    FCU_ACChiller = "FCU_ACChiller",
    FCU_DCW_Boiler = "FCU_DCW_Boiler",
    FCU_DCW_ASHP = "FCU_DCW_ASHP",
    FCU_DCW_DHW = "FCU_DCW_DHW",
    FCU_DCW_ElectricBaseboard = "FCU_DCW_ElectricBaseboard",
    FCU_DCW_GasHeaters = "FCU_DCW_GasHeaters",
    FCU_DCW = "FCU_DCW",
}

/** Fan Coil Unit (FCU) heating/cooling system (with no ventilation). Each room/zone receives its own Fan Coil Unit (FCU), which meets the heating and cooling loads of the space. The cooling coil in the FCU is always chilled water cooling coil, which is connected to a chilled water loop operating at 6.7C (44F). The heating coil is a hot water coil except when when electric baseboards or gas heaters are specified. Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. */
export class FCU extends IDdEnergyBaseModel implements IFCU {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "FCU";
    /** Text for the specific type of system equipment from the FCUEquipmentType enumeration. */
    equipment_type?: FCUEquipmentType;

    constructor(data?: IFCU) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "FCU";
            this.equipment_type = FCUEquipmentType.FCU_Chiller_Boiler;
        }
        this._discriminator = "FCU";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FCU";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : FCUEquipmentType.FCU_Chiller_Boiler;
        }
    }

    static override fromJS(data: any): FCU {
        data = typeof data === 'object' ? data : {};
        let result = new FCU();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Fan Coil Unit (FCU) heating/cooling system (with no ventilation). Each room/zone receives its own Fan Coil Unit (FCU), which meets the heating and cooling loads of the space. The cooling coil in the FCU is always chilled water cooling coil, which is connected to a chilled water loop operating at 6.7C (44F). The heating coil is a hot water coil except when when electric baseboards or gas heaters are specified. Hot water temperature is 82C (180F) for boiler/district heating and 49C (120F) when ASHP is used. */
export interface IFCU extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the FCUEquipmentType enumeration. */
    equipment_type?: FCUEquipmentType;
}

/** An enumeration. */
export enum WSHPEquipmentType {
    WSHP_FluidCooler_Boiler = "WSHP_FluidCooler_Boiler",
    WSHP_CoolingTower_Boiler = "WSHP_CoolingTower_Boiler",
    WSHP_GSHP = "WSHP_GSHP",
    WSHP_DCW_DHW = "WSHP_DCW_DHW",
}

/** Water Source Heat Pump (WSHP) heating/cooling system (with no ventilation). Each room/zone receives its own Water Source Heat Pump (WSHP), which meets the heating and cooling loads of the space. All WSHPs are connected to the same water condenser loop, which has its temperature maintained by the equipment_type (eg. Boiler with Cooling Tower). */
export class WSHP extends IDdEnergyBaseModel implements IWSHP {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "WSHP";
    /** Text for the specific type of system equipment from the WSHPEquipmentType enumeration. */
    equipment_type?: WSHPEquipmentType;

    constructor(data?: IWSHP) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "WSHP";
            this.equipment_type = WSHPEquipmentType.WSHP_FluidCooler_Boiler;
        }
        this._discriminator = "WSHP";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WSHP";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : WSHPEquipmentType.WSHP_FluidCooler_Boiler;
        }
    }

    static override fromJS(data: any): WSHP {
        data = typeof data === 'object' ? data : {};
        let result = new WSHP();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Water Source Heat Pump (WSHP) heating/cooling system (with no ventilation). Each room/zone receives its own Water Source Heat Pump (WSHP), which meets the heating and cooling loads of the space. All WSHPs are connected to the same water condenser loop, which has its temperature maintained by the equipment_type (eg. Boiler with Cooling Tower). */
export interface IWSHP extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the WSHPEquipmentType enumeration. */
    equipment_type?: WSHPEquipmentType;
}

/** An enumeration. */
export enum VRFEquipmentType {
    VRF = "VRF",
}

/** Variable Refrigerant Flow (VRF) heating/cooling system (with no ventilation). Each room/zone receives its own Variable Refrigerant Flow (VRF) terminal, which meets the heating and cooling loads of the space. All room/zone terminals are connected to the same outdoor unit, meaning that either all rooms must be in cooling or heating mode together. */
export class VRF extends IDdEnergyBaseModel implements IVRF {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "VRF";
    /** Text for the specific type of system equipment from the VRFEquipmentType enumeration. */
    equipment_type?: VRFEquipmentType;

    constructor(data?: IVRF) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "VRF";
            this.equipment_type = VRFEquipmentType.VRF;
        }
        this._discriminator = "VRF";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "VRF";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : VRFEquipmentType.VRF;
        }
    }

    static override fromJS(data: any): VRF {
        data = typeof data === 'object' ? data : {};
        let result = new VRF();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Variable Refrigerant Flow (VRF) heating/cooling system (with no ventilation). Each room/zone receives its own Variable Refrigerant Flow (VRF) terminal, which meets the heating and cooling loads of the space. All room/zone terminals are connected to the same outdoor unit, meaning that either all rooms must be in cooling or heating mode together. */
export interface IVRF extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the VRFEquipmentType enumeration. */
    equipment_type?: VRFEquipmentType;
}

/** An enumeration. */
export enum BaseboardEquipmentType {
    ElectricBaseboard = "ElectricBaseboard",
    BoilerBaseboard = "BoilerBaseboard",
    ASHPBaseboard = "ASHPBaseboard",
    DHWBaseboard = "DHWBaseboard",
}

/** Baseboard heating system. Baseboard systems are intended for spaces only requiring heating and no ventilation or cooling. Each room/zone will get its own baseboard heating unit that satisfies the heating load. */
export class Baseboard extends IDdEnergyBaseModel implements IBaseboard {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "Baseboard";
    /** Text for the specific type of system equipment from the BaseboardEquipmentType enumeration. */
    equipment_type?: BaseboardEquipmentType;

    constructor(data?: IBaseboard) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "Baseboard";
            this.equipment_type = BaseboardEquipmentType.ElectricBaseboard;
        }
        this._discriminator = "Baseboard";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Baseboard";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : BaseboardEquipmentType.ElectricBaseboard;
        }
    }

    static override fromJS(data: any): Baseboard {
        data = typeof data === 'object' ? data : {};
        let result = new Baseboard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Baseboard heating system. Baseboard systems are intended for spaces only requiring heating and no ventilation or cooling. Each room/zone will get its own baseboard heating unit that satisfies the heating load. */
export interface IBaseboard extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the BaseboardEquipmentType enumeration. */
    equipment_type?: BaseboardEquipmentType;
}

/** An enumeration. */
export enum EvaporativeCoolerEquipmentType {
    EvapCoolers_ElectricBaseboard = "EvapCoolers_ElectricBaseboard",
    EvapCoolers_BoilerBaseboard = "EvapCoolers_BoilerBaseboard",
    EvapCoolers_ASHPBaseboard = "EvapCoolers_ASHPBaseboard",
    EvapCoolers_DHWBaseboard = "EvapCoolers_DHWBaseboard",
    EvapCoolers_Furnace = "EvapCoolers_Furnace",
    EvapCoolers_UnitHeaters = "EvapCoolers_UnitHeaters",
    EvapCoolers = "EvapCoolers",
}

/** Direct evaporative cooling systems (with optional heating). Each room/zone will receive its own air loop sized to meet the sensible load, which contains an evaporative cooler that directly adds humidity to the room air to cool it. The loop contains an outdoor air mixer, which is used whenever the outdoor air has a lower wet bulb temperature than the return air from the room. In the event that the combination of outdoor and room return air air is too humid, a backup single-speed direct expansion (DX) cooling coil will be used. Heating loads can be met with various options, including several types of baseboards, a furnace, or gas unit heaters. */
export class EvaporativeCooler extends IDdEnergyBaseModel implements IEvaporativeCooler {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "EvaporativeCooler";
    /** Text for the specific type of system equipment from the EvaporativeCoolerEquipmentType enumeration. */
    equipment_type?: EvaporativeCoolerEquipmentType;

    constructor(data?: IEvaporativeCooler) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "EvaporativeCooler";
            this.equipment_type = EvaporativeCoolerEquipmentType.EvapCoolers_ElectricBaseboard;
        }
        this._discriminator = "EvaporativeCooler";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "EvaporativeCooler";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : EvaporativeCoolerEquipmentType.EvapCoolers_ElectricBaseboard;
        }
    }

    static override fromJS(data: any): EvaporativeCooler {
        data = typeof data === 'object' ? data : {};
        let result = new EvaporativeCooler();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Direct evaporative cooling systems (with optional heating). Each room/zone will receive its own air loop sized to meet the sensible load, which contains an evaporative cooler that directly adds humidity to the room air to cool it. The loop contains an outdoor air mixer, which is used whenever the outdoor air has a lower wet bulb temperature than the return air from the room. In the event that the combination of outdoor and room return air air is too humid, a backup single-speed direct expansion (DX) cooling coil will be used. Heating loads can be met with various options, including several types of baseboards, a furnace, or gas unit heaters. */
export interface IEvaporativeCooler extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the EvaporativeCoolerEquipmentType enumeration. */
    equipment_type?: EvaporativeCoolerEquipmentType;
}

/** An enumeration. */
export enum ResidentialEquipmentType {
    ResidentialAC_ElectricBaseboard = "ResidentialAC_ElectricBaseboard",
    ResidentialAC_BoilerBaseboard = "ResidentialAC_BoilerBaseboard",
    ResidentialAC_ASHPBaseboard = "ResidentialAC_ASHPBaseboard",
    ResidentialAC_DHWBaseboard = "ResidentialAC_DHWBaseboard",
    ResidentialAC_ResidentialFurnace = "ResidentialAC_ResidentialFurnace",
    ResidentialAC = "ResidentialAC",
    ResidentialHP = "ResidentialHP",
    ResidentialHPNoCool = "ResidentialHPNoCool",
    ResidentialFurnace = "ResidentialFurnace",
}

/** Residential Air Conditioning, Heat Pump or Furnace system. Residential HVAC systems are intended primarily for single-family homes and include a wide variety of options. In all cases, each room/zone will receive its own air loop WITHOUT an outdoor air inlet (air is simply being recirculated through the loop). Residential air conditioning (AC) systems are modeled using a unitary system with a single-speed direct expansion (DX) cooling coil in the loop. Residential heat pump (HP) systems use a single-speed DX heating coil in the unitary system and the residential furnace option uses a gas coil in the unitary system. In all cases, the properties of these coils are set to reflect a typical residential system. */
export class Residential extends IDdEnergyBaseModel implements IResidential {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "Residential";
    /** Text for the specific type of system equipment from the ResidentialEquipmentType enumeration. */
    equipment_type?: ResidentialEquipmentType;

    constructor(data?: IResidential) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "Residential";
            this.equipment_type = ResidentialEquipmentType.ResidentialAC_ElectricBaseboard;
        }
        this._discriminator = "Residential";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Residential";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : ResidentialEquipmentType.ResidentialAC_ElectricBaseboard;
        }
    }

    static override fromJS(data: any): Residential {
        data = typeof data === 'object' ? data : {};
        let result = new Residential();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Residential Air Conditioning, Heat Pump or Furnace system. Residential HVAC systems are intended primarily for single-family homes and include a wide variety of options. In all cases, each room/zone will receive its own air loop WITHOUT an outdoor air inlet (air is simply being recirculated through the loop). Residential air conditioning (AC) systems are modeled using a unitary system with a single-speed direct expansion (DX) cooling coil in the loop. Residential heat pump (HP) systems use a single-speed DX heating coil in the unitary system and the residential furnace option uses a gas coil in the unitary system. In all cases, the properties of these coils are set to reflect a typical residential system. */
export interface IResidential extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the ResidentialEquipmentType enumeration. */
    equipment_type?: ResidentialEquipmentType;
}

/** An enumeration. */
export enum WindowACEquipmentType {
    WindowAC_ElectricBaseboard = "WindowAC_ElectricBaseboard",
    WindowAC_BoilerBaseboard = "WindowAC_BoilerBaseboard",
    WindowAC_ASHPBaseboard = "WindowAC_ASHPBaseboard",
    WindowAC_DHWBaseboard = "WindowAC_DHWBaseboard",
    WindowAC_Furnace = "WindowAC_Furnace",
    WindowAC_GasHeaters = "WindowAC_GasHeaters",
    WindowAC = "WindowAC",
}

/** Window Air Conditioning cooling system (with optional heating). Each room/zone will receive its own Packaged Terminal Air Conditioner (PTAC) with properties set to reflect a typical window air conditioning (AC) unit. No ventilation air is supplied by the unit and the cooling coil within the unit is a single-speed direct expansion (DX) cooling coil. Heating loads can be met with various options, including several types of baseboards, a furnace, or gas unit heaters. */
export class WindowAC extends IDdEnergyBaseModel implements IWindowAC {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "WindowAC";
    /** Text for the specific type of system equipment from the WindowACEquipmentType enumeration. */
    equipment_type?: WindowACEquipmentType;

    constructor(data?: IWindowAC) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "WindowAC";
            this.equipment_type = WindowACEquipmentType.WindowAC_ElectricBaseboard;
        }
        this._discriminator = "WindowAC";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowAC";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : WindowACEquipmentType.WindowAC_ElectricBaseboard;
        }
    }

    static override fromJS(data: any): WindowAC {
        data = typeof data === 'object' ? data : {};
        let result = new WindowAC();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Window Air Conditioning cooling system (with optional heating). Each room/zone will receive its own Packaged Terminal Air Conditioner (PTAC) with properties set to reflect a typical window air conditioning (AC) unit. No ventilation air is supplied by the unit and the cooling coil within the unit is a single-speed direct expansion (DX) cooling coil. Heating loads can be met with various options, including several types of baseboards, a furnace, or gas unit heaters. */
export interface IWindowAC extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the WindowACEquipmentType enumeration. */
    equipment_type?: WindowACEquipmentType;
}

/** An enumeration. */
export enum GasUnitHeaterEquipmentType {
    GasHeaters = "GasHeaters",
}

/** Gas unit heating system. Gas unit systems are intended for spaces only requiring heating and no ventilation or cooling. Each room/zone will get its own gaa heating unit that satisfies the heating load. */
export class GasUnitHeater extends IDdEnergyBaseModel implements IGasUnitHeater {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "GasUnitHeater";
    /** Text for the specific type of system equipment from the GasUnitHeaterEquipmentType enumeration. */
    equipment_type?: GasUnitHeaterEquipmentType;

    constructor(data?: IGasUnitHeater) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "GasUnitHeater";
            this.equipment_type = GasUnitHeaterEquipmentType.GasHeaters;
        }
        this._discriminator = "GasUnitHeater";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GasUnitHeater";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : GasUnitHeaterEquipmentType.GasHeaters;
        }
    }

    static override fromJS(data: any): GasUnitHeater {
        data = typeof data === 'object' ? data : {};
        let result = new GasUnitHeater();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        super.toJSON(data);
        return data;
    }
}

/** Gas unit heating system. Gas unit systems are intended for spaces only requiring heating and no ventilation or cooling. Each room/zone will get its own gaa heating unit that satisfies the heating load. */
export interface IGasUnitHeater extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the GasUnitHeaterEquipmentType enumeration. */
    equipment_type?: GasUnitHeaterEquipmentType;
}

/** An enumeration. */
export enum RadiantEquipmentType {
    Radiant_Chiller_Boiler = "Radiant_Chiller_Boiler",
    Radiant_Chiller_ASHP = "Radiant_Chiller_ASHP",
    Radiant_Chiller_DHW = "Radiant_Chiller_DHW",
    Radiant_ACChiller_Boiler = "Radiant_ACChiller_Boiler",
    Radiant_ACChiller_ASHP = "Radiant_ACChiller_ASHP",
    Radiant_ACChiller_DHW = "Radiant_ACChiller_DHW",
    Radiant_DCW_Boiler = "Radiant_DCW_Boiler",
    Radiant_DCW_ASHP = "Radiant_DCW_ASHP",
    Radiant_DCW_DHW = "Radiant_DCW_DHW",
}

/** Low temperature radiant HVAC system. This HVAC template will change the floor and/or ceiling constructions of the Rooms that it is applied to, replacing them with a construction that aligns with the radiant_type property (eg. CeilingMetalPanel). The heating and cooling needs of the space are met with the radiant constructions, which use chilled water at 12.8C (55F) and a hot water temperature somewhere between 32.2C (90F) and 49C (120F) (warmer temperatures are used in colder climate zones). Note that radiant systems are particularly limited in cooling capacity and using them may result in many unmet hours. To reduce unmet hours, one can remove carpets, reduce internal loads, reduce solar and envelope gains during peak times, add thermal mass, and use an expanded comfort range. */
export class Radiant extends IDdEnergyBaseModel implements IRadiant {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "Radiant";
    /** Text for the specific type of system equipment from the RadiantEquipmentType enumeration. */
    equipment_type?: RadiantEquipmentType;
    /** Text to indicate which faces are thermally active by default. Note that this property has no effect when the rooms to which the HVAC system is assigned have constructions with internal source materials. In this case, those constructions will dictate the thermally active surfaces. */
    radiant_face_type?: RadiantFaceTypes;
    /** A number for the minimum number of hours of operation for the radiant system before it shuts off. */
    minimum_operation_time?: number;
    /** A number for the minimum number of hours for when the system can switch between heating and cooling. */
    switch_over_time?: number;

    constructor(data?: IRadiant) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "Radiant";
            this.equipment_type = RadiantEquipmentType.Radiant_Chiller_Boiler;
            this.radiant_face_type = RadiantFaceTypes.Floor;
            this.minimum_operation_time = 1;
            this.switch_over_time = 24;
        }
        this._discriminator = "Radiant";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Radiant";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : RadiantEquipmentType.Radiant_Chiller_Boiler;
            this.radiant_face_type = _data["radiant_face_type"] !== undefined ? _data["radiant_face_type"] : RadiantFaceTypes.Floor;
            this.minimum_operation_time = _data["minimum_operation_time"] !== undefined ? _data["minimum_operation_time"] : 1;
            this.switch_over_time = _data["switch_over_time"] !== undefined ? _data["switch_over_time"] : 24;
        }
    }

    static override fromJS(data: any): Radiant {
        data = typeof data === 'object' ? data : {};
        let result = new Radiant();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        data["radiant_face_type"] = this.radiant_face_type;
        data["minimum_operation_time"] = this.minimum_operation_time;
        data["switch_over_time"] = this.switch_over_time;
        super.toJSON(data);
        return data;
    }
}

/** Low temperature radiant HVAC system. This HVAC template will change the floor and/or ceiling constructions of the Rooms that it is applied to, replacing them with a construction that aligns with the radiant_type property (eg. CeilingMetalPanel). The heating and cooling needs of the space are met with the radiant constructions, which use chilled water at 12.8C (55F) and a hot water temperature somewhere between 32.2C (90F) and 49C (120F) (warmer temperatures are used in colder climate zones). Note that radiant systems are particularly limited in cooling capacity and using them may result in many unmet hours. To reduce unmet hours, one can remove carpets, reduce internal loads, reduce solar and envelope gains during peak times, add thermal mass, and use an expanded comfort range. */
export interface IRadiant extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
    /** Text for the specific type of system equipment from the RadiantEquipmentType enumeration. */
    equipment_type?: RadiantEquipmentType;
    /** Text to indicate which faces are thermally active by default. Note that this property has no effect when the rooms to which the HVAC system is assigned have constructions with internal source materials. In this case, those constructions will dictate the thermally active surfaces. */
    radiant_face_type?: RadiantFaceTypes;
    /** A number for the minimum number of hours of operation for the radiant system before it shuts off. */
    minimum_operation_time?: number;
    /** A number for the minimum number of hours for when the system can switch between heating and cooling. */
    switch_over_time?: number;
}

/** Detailed HVAC system object defined using IronBug or OpenStudio .NET bindings. */
export class DetailedHVAC extends IDdEnergyBaseModel implements IDetailedHVAC {
    /** A JSON-serializable dictionary representing the full specification of the detailed system. This can be obtained by calling the ToJson() method on any IronBug HVAC system and then serializing the resulting JSON string into a Python dictionary using the native Python json package. Note that the Rooms that the HVAC is assigned to must be specified as ThermalZones under this specification in order for the resulting Model this HVAC is a part of to be valid. */
    specification!: any;
    readonly type: string = "DetailedHVAC";

    constructor(data?: IDetailedHVAC) {
        super(data);
        if (!data) {
            this.type = "DetailedHVAC";
        }
        this._discriminator = "DetailedHVAC";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.specification = _data["specification"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DetailedHVAC";
        }
    }

    static override fromJS(data: any): DetailedHVAC {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedHVAC();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specification"] = this.specification;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Detailed HVAC system object defined using IronBug or OpenStudio .NET bindings. */
export interface IDetailedHVAC extends IIDdEnergyBaseModel {
    /** A JSON-serializable dictionary representing the full specification of the detailed system. This can be obtained by calling the ToJson() method on any IronBug HVAC system and then serializing the resulting JSON string into a Python dictionary using the native Python json package. Note that the Rooms that the HVAC is assigned to must be specified as ThermalZones under this specification in order for the resulting Model this HVAC is a part of to be valid. */
    specification: any;
    type?: string;
}

/** An enumeration. */
export enum SHWEquipmentType {
    Gas_WaterHeater = "Gas_WaterHeater",
    Electric_WaterHeater = "Electric_WaterHeater",
    HeatPump_WaterHeater = "HeatPump_WaterHeater",
    Gas_TanklessHeater = "Gas_TanklessHeater",
    Electric_TanklessHeater = "Electric_TanklessHeater",
}

/** Provides a model for a Service Hot Water system. */
export class SHWSystem extends IDdEnergyBaseModel implements ISHWSystem {
    readonly type: string = "SHWSystem";
    /** Text to indicate the type of air-side economizer used on the ideal air system. Economizers will mix in a greater amount of outdoor air to cool the zone (rather than running the cooling system) when the zone needs cooling and the outdoor air is cooler than the zone. */
    equipment_type?: SHWEquipmentType;
    /** A number for the efficiency of the heater within the system. For Gas systems, this is the efficiency of the burner. For HeatPump systems, this is the rated COP of the system. For electric systems, this should usually be set to 1. If set to Autocalculate, this value will automatically be set based on the equipment_type. Gas_WaterHeater - 0.8, Electric_WaterHeater - 1.0, HeatPump_WaterHeater - 3.5, Gas_TanklessHeater - 0.8, Electric_TanklessHeater - 1.0. */
    heater_efficiency?: Heater_efficiency;
    /** A number for the ambient temperature in which the hot water tank is located [C]. This can also be the identifier of a Room in which the tank is located. */
    ambient_condition?: Ambient_condition;
    /** A number for the loss of heat from the water heater tank to the surrounding ambient conditions [W/K]. */
    ambient_loss_coefficient?: number;

    constructor(data?: ISHWSystem) {
        super(data);
        if (!data) {
            this.type = "SHWSystem";
            this.equipment_type = SHWEquipmentType.Gas_WaterHeater;
            this.ambient_loss_coefficient = 6;
        }
        this._discriminator = "SHWSystem";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "SHWSystem";
            this.equipment_type = _data["equipment_type"] !== undefined ? _data["equipment_type"] : SHWEquipmentType.Gas_WaterHeater;
            this.heater_efficiency = _data["heater_efficiency"];
            this.ambient_condition = _data["ambient_condition"];
            this.ambient_loss_coefficient = _data["ambient_loss_coefficient"] !== undefined ? _data["ambient_loss_coefficient"] : 6;
        }
    }

    static override fromJS(data: any): SHWSystem {
        data = typeof data === 'object' ? data : {};
        let result = new SHWSystem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["equipment_type"] = this.equipment_type;
        data["heater_efficiency"] = this.heater_efficiency;
        data["ambient_condition"] = this.ambient_condition;
        data["ambient_loss_coefficient"] = this.ambient_loss_coefficient;
        super.toJSON(data);
        return data;
    }
}

/** Provides a model for a Service Hot Water system. */
export interface ISHWSystem extends IIDdEnergyBaseModel {
    type?: string;
    /** Text to indicate the type of air-side economizer used on the ideal air system. Economizers will mix in a greater amount of outdoor air to cool the zone (rather than running the cooling system) when the zone needs cooling and the outdoor air is cooler than the zone. */
    equipment_type?: SHWEquipmentType;
    /** A number for the efficiency of the heater within the system. For Gas systems, this is the efficiency of the burner. For HeatPump systems, this is the rated COP of the system. For electric systems, this should usually be set to 1. If set to Autocalculate, this value will automatically be set based on the equipment_type. Gas_WaterHeater - 0.8, Electric_WaterHeater - 1.0, HeatPump_WaterHeater - 3.5, Gas_TanklessHeater - 0.8, Electric_TanklessHeater - 1.0. */
    heater_efficiency?: Heater_efficiency;
    /** A number for the ambient temperature in which the hot water tank is located [C]. This can also be the identifier of a Room in which the tank is located. */
    ambient_condition?: Ambient_condition;
    /** A number for the loss of heat from the water heater tank to the surrounding ambient conditions [W/K]. */
    ambient_loss_coefficient?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ProgramTypeAbridged extends IDdEnergyBaseModel implements IProgramTypeAbridged {
    readonly type: string = "ProgramTypeAbridged";
    /** People to describe the occupancy of the program. If None, no occupancy will be assumed for the program. */
    people?: PeopleAbridged;
    /** Lighting to describe the lighting usage of the program. If None, no lighting will be assumed for the program. */
    lighting?: LightingAbridged;
    /** ElectricEquipment to describe the usage of electric equipment within the program. If None, no electric equipment will be assumed. */
    electric_equipment?: ElectricEquipmentAbridged;
    /** GasEquipment to describe the usage of gas equipment within the program. If None, no gas equipment will be assumed. */
    gas_equipment?: GasEquipmentAbridged;
    /** ServiceHotWater object to describe the usage of hot water within the program. If None, no hot water will be assumed. */
    service_hot_water?: ServiceHotWaterAbridged;
    /** Infiltration to describe the outdoor air leakage of the program. If None, no infiltration will be assumed for the program. */
    infiltration?: InfiltrationAbridged;
    /** Ventilation to describe the minimum outdoor air requirement of the program. If None, no ventilation requirement will be assumed. */
    ventilation?: VentilationAbridged;
    /** Setpoint object to describe the temperature and humidity setpoints of the program.  If None, the ProgramType cannot be assigned to a Room that is conditioned. */
    setpoint?: SetpointAbridged;

    constructor(data?: IProgramTypeAbridged) {
        super(data);
        if (!data) {
            this.type = "ProgramTypeAbridged";
        }
        this._discriminator = "ProgramTypeAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ProgramTypeAbridged";
            this.people = _data["people"] ? PeopleAbridged.fromJS(_data["people"]) : <any>undefined;
            this.lighting = _data["lighting"] ? LightingAbridged.fromJS(_data["lighting"]) : <any>undefined;
            this.electric_equipment = _data["electric_equipment"] ? ElectricEquipmentAbridged.fromJS(_data["electric_equipment"]) : <any>undefined;
            this.gas_equipment = _data["gas_equipment"] ? GasEquipmentAbridged.fromJS(_data["gas_equipment"]) : <any>undefined;
            this.service_hot_water = _data["service_hot_water"] ? ServiceHotWaterAbridged.fromJS(_data["service_hot_water"]) : <any>undefined;
            this.infiltration = _data["infiltration"] ? InfiltrationAbridged.fromJS(_data["infiltration"]) : <any>undefined;
            this.ventilation = _data["ventilation"] ? VentilationAbridged.fromJS(_data["ventilation"]) : <any>undefined;
            this.setpoint = _data["setpoint"] ? SetpointAbridged.fromJS(_data["setpoint"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ProgramTypeAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramTypeAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["people"] = this.people ? this.people.toJSON() : <any>undefined;
        data["lighting"] = this.lighting ? this.lighting.toJSON() : <any>undefined;
        data["electric_equipment"] = this.electric_equipment ? this.electric_equipment.toJSON() : <any>undefined;
        data["gas_equipment"] = this.gas_equipment ? this.gas_equipment.toJSON() : <any>undefined;
        data["service_hot_water"] = this.service_hot_water ? this.service_hot_water.toJSON() : <any>undefined;
        data["infiltration"] = this.infiltration ? this.infiltration.toJSON() : <any>undefined;
        data["ventilation"] = this.ventilation ? this.ventilation.toJSON() : <any>undefined;
        data["setpoint"] = this.setpoint ? this.setpoint.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IProgramTypeAbridged extends IIDdEnergyBaseModel {
    type?: string;
    /** People to describe the occupancy of the program. If None, no occupancy will be assumed for the program. */
    people?: PeopleAbridged;
    /** Lighting to describe the lighting usage of the program. If None, no lighting will be assumed for the program. */
    lighting?: LightingAbridged;
    /** ElectricEquipment to describe the usage of electric equipment within the program. If None, no electric equipment will be assumed. */
    electric_equipment?: ElectricEquipmentAbridged;
    /** GasEquipment to describe the usage of gas equipment within the program. If None, no gas equipment will be assumed. */
    gas_equipment?: GasEquipmentAbridged;
    /** ServiceHotWater object to describe the usage of hot water within the program. If None, no hot water will be assumed. */
    service_hot_water?: ServiceHotWaterAbridged;
    /** Infiltration to describe the outdoor air leakage of the program. If None, no infiltration will be assumed for the program. */
    infiltration?: InfiltrationAbridged;
    /** Ventilation to describe the minimum outdoor air requirement of the program. If None, no ventilation requirement will be assumed. */
    ventilation?: VentilationAbridged;
    /** Setpoint object to describe the temperature and humidity setpoints of the program.  If None, the ProgramType cannot be assigned to a Room that is conditioned. */
    setpoint?: SetpointAbridged;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class People extends IDdEnergyBaseModel implements IPeople {
    /** People per floor area expressed as [people/m2] */
    people_per_area!: number;
    /** A schedule for the occupancy over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the people_per_area to yield a complete occupancy profile. */
    occupancy_schedule!: Occupancy_schedule;
    readonly type: string = "People";
    /** A schedule for the activity of the occupants over the course of the year. The type of this schedule should be ActivityLevel and the values of the schedule equal to the number of Watts given off by an individual person in the room. If None, a default constant schedule with 120 Watts per person will be used, which is typical of awake, adult humans who are seated. */
    activity_schedule?: Activity_schedule;
    /** The radiant fraction of sensible heat released by people. (Default: 0.3). */
    radiant_fraction?: number;
    /** Number for the latent fraction of heat gain due to people or an Autocalculate object. */
    latent_fraction?: latent_fraction;

    constructor(data?: IPeople) {
        super(data);
        if (!data) {
            this.type = "People";
            this.radiant_fraction = 0.3;
        }
        this._discriminator = "People";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.people_per_area = _data["people_per_area"];
            this.occupancy_schedule = _data["occupancy_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "People";
            this.activity_schedule = _data["activity_schedule"];
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0.3;
            this.latent_fraction = _data["latent_fraction"];
        }
    }

    static override fromJS(data: any): People {
        data = typeof data === 'object' ? data : {};
        let result = new People();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["people_per_area"] = this.people_per_area;
        data["occupancy_schedule"] = this.occupancy_schedule;
        data["type"] = this.type;
        data["activity_schedule"] = this.activity_schedule;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IPeople extends IIDdEnergyBaseModel {
    /** People per floor area expressed as [people/m2] */
    people_per_area: number;
    /** A schedule for the occupancy over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the people_per_area to yield a complete occupancy profile. */
    occupancy_schedule: Occupancy_schedule;
    type?: string;
    /** A schedule for the activity of the occupants over the course of the year. The type of this schedule should be ActivityLevel and the values of the schedule equal to the number of Watts given off by an individual person in the room. If None, a default constant schedule with 120 Watts per person will be used, which is typical of awake, adult humans who are seated. */
    activity_schedule?: Activity_schedule;
    /** The radiant fraction of sensible heat released by people. (Default: 0.3). */
    radiant_fraction?: number;
    /** Number for the latent fraction of heat gain due to people or an Autocalculate object. */
    latent_fraction?: latent_fraction;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class Lighting extends IDdEnergyBaseModel implements ILighting {
    /** Lighting per floor area as [W/m2]. */
    watts_per_area!: number;
    /** The schedule for the use of lights over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete lighting profile. */
    schedule!: schedule2;
    readonly type: string = "Lighting";
    /** The fraction of heat from lights that goes into the zone as visible (short-wave) radiation. (Default: 0.25). */
    visible_fraction?: number;
    /** The fraction of heat from lights that is long-wave radiation. (Default: 0.32). */
    radiant_fraction?: number;
    /** The fraction of the heat from lights that goes into the zone return air. (Default: 0). */
    return_air_fraction?: number;
    /** The baseline lighting power density in [W/m2] of floor area. This baseline is useful to track how much better the installed lights are in comparison to a standard like ASHRAE 90.1. If set to None, it will default to 11.84029 W/m2, which is that ASHRAE 90.1-2004 baseline for an office. */
    baseline_watts_per_area?: number;

    constructor(data?: ILighting) {
        super(data);
        if (!data) {
            this.type = "Lighting";
            this.visible_fraction = 0.25;
            this.radiant_fraction = 0.32;
            this.return_air_fraction = 0;
            this.baseline_watts_per_area = 11.84029;
        }
        this._discriminator = "Lighting";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts_per_area = _data["watts_per_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Lighting";
            this.visible_fraction = _data["visible_fraction"] !== undefined ? _data["visible_fraction"] : 0.25;
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0.32;
            this.return_air_fraction = _data["return_air_fraction"] !== undefined ? _data["return_air_fraction"] : 0;
            this.baseline_watts_per_area = _data["baseline_watts_per_area"] !== undefined ? _data["baseline_watts_per_area"] : 11.84029;
        }
    }

    static override fromJS(data: any): Lighting {
        data = typeof data === 'object' ? data : {};
        let result = new Lighting();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts_per_area"] = this.watts_per_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["visible_fraction"] = this.visible_fraction;
        data["radiant_fraction"] = this.radiant_fraction;
        data["return_air_fraction"] = this.return_air_fraction;
        data["baseline_watts_per_area"] = this.baseline_watts_per_area;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface ILighting extends IIDdEnergyBaseModel {
    /** Lighting per floor area as [W/m2]. */
    watts_per_area: number;
    /** The schedule for the use of lights over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete lighting profile. */
    schedule: schedule2;
    type?: string;
    /** The fraction of heat from lights that goes into the zone as visible (short-wave) radiation. (Default: 0.25). */
    visible_fraction?: number;
    /** The fraction of heat from lights that is long-wave radiation. (Default: 0.32). */
    radiant_fraction?: number;
    /** The fraction of the heat from lights that goes into the zone return air. (Default: 0). */
    return_air_fraction?: number;
    /** The baseline lighting power density in [W/m2] of floor area. This baseline is useful to track how much better the installed lights are in comparison to a standard like ASHRAE 90.1. If set to None, it will default to 11.84029 W/m2, which is that ASHRAE 90.1-2004 baseline for an office. */
    baseline_watts_per_area?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ElectricEquipment extends IDdEnergyBaseModel implements IElectricEquipment {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area!: number;
    /** The schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule!: schedule3;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    readonly type: string = "ElectricEquipment";

    constructor(data?: IElectricEquipment) {
        super(data);
        if (!data) {
            this.radiant_fraction = 0;
            this.latent_fraction = 0;
            this.lost_fraction = 0;
            this.type = "ElectricEquipment";
        }
        this._discriminator = "ElectricEquipment";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts_per_area = _data["watts_per_area"];
            this.schedule = _data["schedule"];
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0;
            this.lost_fraction = _data["lost_fraction"] !== undefined ? _data["lost_fraction"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ElectricEquipment";
        }
    }

    static override fromJS(data: any): ElectricEquipment {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricEquipment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts_per_area"] = this.watts_per_area;
        data["schedule"] = this.schedule;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        data["lost_fraction"] = this.lost_fraction;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IElectricEquipment extends IIDdEnergyBaseModel {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area: number;
    /** The schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule: schedule3;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class GasEquipment extends IDdEnergyBaseModel implements IGasEquipment {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area!: number;
    /** The schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule!: schedule4;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    readonly type: string = "GasEquipment";

    constructor(data?: IGasEquipment) {
        super(data);
        if (!data) {
            this.radiant_fraction = 0;
            this.latent_fraction = 0;
            this.lost_fraction = 0;
            this.type = "GasEquipment";
        }
        this._discriminator = "GasEquipment";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watts_per_area = _data["watts_per_area"];
            this.schedule = _data["schedule"];
            this.radiant_fraction = _data["radiant_fraction"] !== undefined ? _data["radiant_fraction"] : 0;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0;
            this.lost_fraction = _data["lost_fraction"] !== undefined ? _data["lost_fraction"] : 0;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GasEquipment";
        }
    }

    static override fromJS(data: any): GasEquipment {
        data = typeof data === 'object' ? data : {};
        let result = new GasEquipment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watts_per_area"] = this.watts_per_area;
        data["schedule"] = this.schedule;
        data["radiant_fraction"] = this.radiant_fraction;
        data["latent_fraction"] = this.latent_fraction;
        data["lost_fraction"] = this.lost_fraction;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IGasEquipment extends IIDdEnergyBaseModel {
    /** Equipment level per floor area as [W/m2]. */
    watts_per_area: number;
    /** The schedule for the use of equipment over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the watts_per_area to yield a complete equipment profile. */
    schedule: schedule4;
    /** Number for the amount of long-wave radiation heat given off by equipment. Default value is 0. */
    radiant_fraction?: number;
    /** Number for the amount of latent heat given off by equipment. Default value is 0. */
    latent_fraction?: number;
    /** Number for the amount of “lost” heat being given off by equipment. The default value is 0. */
    lost_fraction?: number;
    type?: string;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ServiceHotWater extends IDdEnergyBaseModel implements IServiceHotWater {
    /** Number for the total volume flow rate of water per unit area of floor [L/h-m2]. */
    flow_per_area!: number;
    /** The schedule for the use of hot water over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_area to yield a complete water usage profile. */
    schedule!: schedule5;
    readonly type: string = "ServiceHotWater";
    /** Number for the target temperature of water out of the tap (C). This the temperature after hot water has been mixed with cold water from the water mains. The default is 60C, which essentially assumes that the flow_per_area on this object is only for water straight out of the water heater. */
    target_temperature?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load given off as sensible heat in the zone. */
    sensible_fraction?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load that is latent. */
    latent_fraction?: number;

    constructor(data?: IServiceHotWater) {
        super(data);
        if (!data) {
            this.type = "ServiceHotWater";
            this.target_temperature = 60;
            this.sensible_fraction = 0.2;
            this.latent_fraction = 0.05;
        }
        this._discriminator = "ServiceHotWater";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_per_area = _data["flow_per_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ServiceHotWater";
            this.target_temperature = _data["target_temperature"] !== undefined ? _data["target_temperature"] : 60;
            this.sensible_fraction = _data["sensible_fraction"] !== undefined ? _data["sensible_fraction"] : 0.2;
            this.latent_fraction = _data["latent_fraction"] !== undefined ? _data["latent_fraction"] : 0.05;
        }
    }

    static override fromJS(data: any): ServiceHotWater {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceHotWater();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_per_area"] = this.flow_per_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["target_temperature"] = this.target_temperature;
        data["sensible_fraction"] = this.sensible_fraction;
        data["latent_fraction"] = this.latent_fraction;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IServiceHotWater extends IIDdEnergyBaseModel {
    /** Number for the total volume flow rate of water per unit area of floor [L/h-m2]. */
    flow_per_area: number;
    /** The schedule for the use of hot water over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_area to yield a complete water usage profile. */
    schedule: schedule5;
    type?: string;
    /** Number for the target temperature of water out of the tap (C). This the temperature after hot water has been mixed with cold water from the water mains. The default is 60C, which essentially assumes that the flow_per_area on this object is only for water straight out of the water heater. */
    target_temperature?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load given off as sensible heat in the zone. */
    sensible_fraction?: number;
    /** A number between 0 and 1 for the fraction of the total hot water load that is latent. */
    latent_fraction?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class Infiltration extends IDdEnergyBaseModel implements IInfiltration {
    /** Number for the infiltration per exterior surface area in m3/s-m2. */
    flow_per_exterior_area!: number;
    /** The schedule for the infiltration over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_exterior_area to yield a complete infiltration profile. */
    schedule!: schedule6;
    readonly type: string = "Infiltration";
    constant_coefficient?: number;
    temperature_coefficient?: number;
    velocity_coefficient?: number;

    constructor(data?: IInfiltration) {
        super(data);
        if (!data) {
            this.type = "Infiltration";
            this.constant_coefficient = 1;
            this.temperature_coefficient = 0;
            this.velocity_coefficient = 0;
        }
        this._discriminator = "Infiltration";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.flow_per_exterior_area = _data["flow_per_exterior_area"];
            this.schedule = _data["schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Infiltration";
            this.constant_coefficient = _data["constant_coefficient"] !== undefined ? _data["constant_coefficient"] : 1;
            this.temperature_coefficient = _data["temperature_coefficient"] !== undefined ? _data["temperature_coefficient"] : 0;
            this.velocity_coefficient = _data["velocity_coefficient"] !== undefined ? _data["velocity_coefficient"] : 0;
        }
    }

    static override fromJS(data: any): Infiltration {
        data = typeof data === 'object' ? data : {};
        let result = new Infiltration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flow_per_exterior_area"] = this.flow_per_exterior_area;
        data["schedule"] = this.schedule;
        data["type"] = this.type;
        data["constant_coefficient"] = this.constant_coefficient;
        data["temperature_coefficient"] = this.temperature_coefficient;
        data["velocity_coefficient"] = this.velocity_coefficient;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IInfiltration extends IIDdEnergyBaseModel {
    /** Number for the infiltration per exterior surface area in m3/s-m2. */
    flow_per_exterior_area: number;
    /** The schedule for the infiltration over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the flow_per_exterior_area to yield a complete infiltration profile. */
    schedule: schedule6;
    type?: string;
    constant_coefficient?: number;
    temperature_coefficient?: number;
    velocity_coefficient?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class Ventilation extends IDdEnergyBaseModel implements IVentilation {
    readonly type: string = "Ventilation";
    /** Intensity of ventilation in[] m3/s per person]. Note that setting this value does not mean that ventilation is varied based on real-time occupancy but rather that the design level of ventilation is determined using this value and the People object of the Room. */
    flow_per_person?: number;
    /** Intensity of ventilation in [m3/s per m2 of floor area]. */
    flow_per_area?: number;
    /** Intensity of ventilation in air changes per hour (ACH) for the entire Room. */
    air_changes_per_hour?: number;
    /** Intensity of ventilation in m3/s for the entire Room. */
    flow_per_zone?: number;
    /** Schedule for the ventilation over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the total design flow rate (determined from the sum of the other 4 fields) to yield a complete ventilation profile. */
    schedule?: schedule7;

    constructor(data?: IVentilation) {
        super(data);
        if (!data) {
            this.type = "Ventilation";
            this.flow_per_person = 0;
            this.flow_per_area = 0;
            this.air_changes_per_hour = 0;
            this.flow_per_zone = 0;
        }
        this._discriminator = "Ventilation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Ventilation";
            this.flow_per_person = _data["flow_per_person"] !== undefined ? _data["flow_per_person"] : 0;
            this.flow_per_area = _data["flow_per_area"] !== undefined ? _data["flow_per_area"] : 0;
            this.air_changes_per_hour = _data["air_changes_per_hour"] !== undefined ? _data["air_changes_per_hour"] : 0;
            this.flow_per_zone = _data["flow_per_zone"] !== undefined ? _data["flow_per_zone"] : 0;
            this.schedule = _data["schedule"];
        }
    }

    static override fromJS(data: any): Ventilation {
        data = typeof data === 'object' ? data : {};
        let result = new Ventilation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["flow_per_person"] = this.flow_per_person;
        data["flow_per_area"] = this.flow_per_area;
        data["air_changes_per_hour"] = this.air_changes_per_hour;
        data["flow_per_zone"] = this.flow_per_zone;
        data["schedule"] = this.schedule;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IVentilation extends IIDdEnergyBaseModel {
    type?: string;
    /** Intensity of ventilation in[] m3/s per person]. Note that setting this value does not mean that ventilation is varied based on real-time occupancy but rather that the design level of ventilation is determined using this value and the People object of the Room. */
    flow_per_person?: number;
    /** Intensity of ventilation in [m3/s per m2 of floor area]. */
    flow_per_area?: number;
    /** Intensity of ventilation in air changes per hour (ACH) for the entire Room. */
    air_changes_per_hour?: number;
    /** Intensity of ventilation in m3/s for the entire Room. */
    flow_per_zone?: number;
    /** Schedule for the ventilation over the course of the year. The type of this schedule should be Fractional and the fractional values will get multiplied by the total design flow rate (determined from the sum of the other 4 fields) to yield a complete ventilation profile. */
    schedule?: schedule7;
}

/** Used to specify information about the setpoint schedule. */
export class Setpoint extends IDdEnergyBaseModel implements ISetpoint {
    /** Schedule for the cooling setpoint. The values in this schedule should be temperature in [C]. */
    cooling_schedule!: Cooling_schedule;
    /** Schedule for the heating setpoint. The values in this schedule should be temperature in [C]. */
    heating_schedule!: Heating_schedule;
    readonly type: string = "Setpoint";
    /** Schedule for the humidification setpoint. The values in this schedule should be in [%]. */
    humidifying_schedule?: Humidifying_schedule;
    /** Schedule for the dehumidification setpoint. The values in this schedule should be in [%]. */
    dehumidifying_schedule?: Dehumidifying_schedule;
    /** An optional positive number for the temperature difference between the cutout temperature and the setpoint temperature. Specifying a non-zero number here is useful for modeling the throttling range associated with a given setup of setpoint controls and HVAC equipment. Throttling ranges describe the range where a zone is slightly over-cooled or over-heated beyond the thermostat setpoint. They are used to avoid situations where HVAC systems turn on only to turn off a few minutes later, thereby wearing out the parts of mechanical systems faster. They can have a minor impact on energy consumption and can often have significant impacts on occupant thermal comfort, though using the default value of zero will often yield results that are close enough when trying to estimate the annual heating/cooling energy use. Specifying a value of zero effectively assumes that the system will turn on whenever conditions are outside the setpoint range and will cut out as soon as the setpoint is reached. */
    setpoint_cutout_difference?: number;

    constructor(data?: ISetpoint) {
        super(data);
        if (!data) {
            this.type = "Setpoint";
            this.setpoint_cutout_difference = 0;
        }
        this._discriminator = "Setpoint";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cooling_schedule = _data["cooling_schedule"];
            this.heating_schedule = _data["heating_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Setpoint";
            this.humidifying_schedule = _data["humidifying_schedule"];
            this.dehumidifying_schedule = _data["dehumidifying_schedule"];
            this.setpoint_cutout_difference = _data["setpoint_cutout_difference"] !== undefined ? _data["setpoint_cutout_difference"] : 0;
        }
    }

    static override fromJS(data: any): Setpoint {
        data = typeof data === 'object' ? data : {};
        let result = new Setpoint();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cooling_schedule"] = this.cooling_schedule;
        data["heating_schedule"] = this.heating_schedule;
        data["type"] = this.type;
        data["humidifying_schedule"] = this.humidifying_schedule;
        data["dehumidifying_schedule"] = this.dehumidifying_schedule;
        data["setpoint_cutout_difference"] = this.setpoint_cutout_difference;
        super.toJSON(data);
        return data;
    }
}

/** Used to specify information about the setpoint schedule. */
export interface ISetpoint extends IIDdEnergyBaseModel {
    /** Schedule for the cooling setpoint. The values in this schedule should be temperature in [C]. */
    cooling_schedule: Cooling_schedule;
    /** Schedule for the heating setpoint. The values in this schedule should be temperature in [C]. */
    heating_schedule: Heating_schedule;
    type?: string;
    /** Schedule for the humidification setpoint. The values in this schedule should be in [%]. */
    humidifying_schedule?: Humidifying_schedule;
    /** Schedule for the dehumidification setpoint. The values in this schedule should be in [%]. */
    dehumidifying_schedule?: Dehumidifying_schedule;
    /** An optional positive number for the temperature difference between the cutout temperature and the setpoint temperature. Specifying a non-zero number here is useful for modeling the throttling range associated with a given setup of setpoint controls and HVAC equipment. Throttling ranges describe the range where a zone is slightly over-cooled or over-heated beyond the thermostat setpoint. They are used to avoid situations where HVAC systems turn on only to turn off a few minutes later, thereby wearing out the parts of mechanical systems faster. They can have a minor impact on energy consumption and can often have significant impacts on occupant thermal comfort, though using the default value of zero will often yield results that are close enough when trying to estimate the annual heating/cooling energy use. Specifying a value of zero effectively assumes that the system will turn on whenever conditions are outside the setpoint range and will cut out as soon as the setpoint is reached. */
    setpoint_cutout_difference?: number;
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export class ProgramType extends IDdEnergyBaseModel implements IProgramType {
    readonly type: string = "ProgramType";
    /** People to describe the occupancy of the program. If None, no occupancy will be assumed for the program. */
    people?: People;
    /** Lighting to describe the lighting usage of the program. If None, no lighting will be assumed for the program. */
    lighting?: Lighting;
    /** ElectricEquipment to describe the usage of electric equipment within the program. If None, no electric equipment will be assumed. */
    electric_equipment?: ElectricEquipment;
    /** GasEquipment to describe the usage of gas equipment within the program. If None, no gas equipment will be assumed. */
    gas_equipment?: GasEquipment;
    /** ServiceHotWater object to describe the usage of hot water within the program. If None, no hot water will be assumed. */
    service_hot_water?: ServiceHotWater;
    /** Infiltration to describe the outdoor air leakage of the program. If None, no infiltration will be assumed for the program. */
    infiltration?: Infiltration;
    /** Ventilation to describe the minimum outdoor air requirement of the program. If None, no ventilation requirement will be assumed. */
    ventilation?: Ventilation;
    /** Setpoint object to describe the temperature and humidity setpoints of the program.  If None, the ProgramType cannot be assigned to a Room that is conditioned. */
    setpoint?: Setpoint;

    constructor(data?: IProgramType) {
        super(data);
        if (!data) {
            this.type = "ProgramType";
        }
        this._discriminator = "ProgramType";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ProgramType";
            this.people = _data["people"] ? People.fromJS(_data["people"]) : <any>undefined;
            this.lighting = _data["lighting"] ? Lighting.fromJS(_data["lighting"]) : <any>undefined;
            this.electric_equipment = _data["electric_equipment"] ? ElectricEquipment.fromJS(_data["electric_equipment"]) : <any>undefined;
            this.gas_equipment = _data["gas_equipment"] ? GasEquipment.fromJS(_data["gas_equipment"]) : <any>undefined;
            this.service_hot_water = _data["service_hot_water"] ? ServiceHotWater.fromJS(_data["service_hot_water"]) : <any>undefined;
            this.infiltration = _data["infiltration"] ? Infiltration.fromJS(_data["infiltration"]) : <any>undefined;
            this.ventilation = _data["ventilation"] ? Ventilation.fromJS(_data["ventilation"]) : <any>undefined;
            this.setpoint = _data["setpoint"] ? Setpoint.fromJS(_data["setpoint"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ProgramType {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramType();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["people"] = this.people ? this.people.toJSON() : <any>undefined;
        data["lighting"] = this.lighting ? this.lighting.toJSON() : <any>undefined;
        data["electric_equipment"] = this.electric_equipment ? this.electric_equipment.toJSON() : <any>undefined;
        data["gas_equipment"] = this.gas_equipment ? this.gas_equipment.toJSON() : <any>undefined;
        data["service_hot_water"] = this.service_hot_water ? this.service_hot_water.toJSON() : <any>undefined;
        data["infiltration"] = this.infiltration ? this.infiltration.toJSON() : <any>undefined;
        data["ventilation"] = this.ventilation ? this.ventilation.toJSON() : <any>undefined;
        data["setpoint"] = this.setpoint ? this.setpoint.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring an EnergyPlus identifier and user_data. */
export interface IProgramType extends IIDdEnergyBaseModel {
    type?: string;
    /** People to describe the occupancy of the program. If None, no occupancy will be assumed for the program. */
    people?: People;
    /** Lighting to describe the lighting usage of the program. If None, no lighting will be assumed for the program. */
    lighting?: Lighting;
    /** ElectricEquipment to describe the usage of electric equipment within the program. If None, no electric equipment will be assumed. */
    electric_equipment?: ElectricEquipment;
    /** GasEquipment to describe the usage of gas equipment within the program. If None, no gas equipment will be assumed. */
    gas_equipment?: GasEquipment;
    /** ServiceHotWater object to describe the usage of hot water within the program. If None, no hot water will be assumed. */
    service_hot_water?: ServiceHotWater;
    /** Infiltration to describe the outdoor air leakage of the program. If None, no infiltration will be assumed for the program. */
    infiltration?: Infiltration;
    /** Ventilation to describe the minimum outdoor air requirement of the program. If None, no ventilation requirement will be assumed. */
    ventilation?: Ventilation;
    /** Setpoint object to describe the temperature and humidity setpoints of the program.  If None, the ProgramType cannot be assigned to a Room that is conditioned. */
    setpoint?: Setpoint;
}

/** Used to define a schedule for a default day, further described by ScheduleRule. */
export class ScheduleRulesetAbridged extends IDdEnergyBaseModel implements IScheduleRulesetAbridged {
    /** A list of ScheduleDays that are referenced in the other keys of this ScheduleRulesetAbridged. */
    day_schedules!: ScheduleDay[];
    /** An identifier for the ScheduleDay that will be used for all days when no ScheduleRule is applied. This ScheduleDay must be in the day_schedules. */
    default_day_schedule!: string;
    readonly type: string = "ScheduleRulesetAbridged";
    /** A list of ScheduleRuleAbridged that note exceptions to the default_day_schedule. These rules should be ordered from highest to lowest priority. */
    schedule_rules?: ScheduleRuleAbridged[];
    /** An identifier for the ScheduleDay that will be used for holidays. This ScheduleDay must be in the day_schedules. */
    holiday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the summer design day. This ScheduleDay must be in the day_schedules. */
    summer_designday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the winter design day. This ScheduleDay must be in the day_schedules. */
    winter_designday_schedule?: string;
    /** Identifier of a ScheduleTypeLimit that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: string;

    constructor(data?: IScheduleRulesetAbridged) {
        super(data);
        if (!data) {
            this.day_schedules = [];
            this.type = "ScheduleRulesetAbridged";
        }
        this._discriminator = "ScheduleRulesetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["day_schedules"])) {
                this.day_schedules = [] as any;
                for (let item of _data["day_schedules"])
                    this.day_schedules!.push(ScheduleDay.fromJS(item));
            }
            this.default_day_schedule = _data["default_day_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleRulesetAbridged";
            if (Array.isArray(_data["schedule_rules"])) {
                this.schedule_rules = [] as any;
                for (let item of _data["schedule_rules"])
                    this.schedule_rules!.push(ScheduleRuleAbridged.fromJS(item));
            }
            this.holiday_schedule = _data["holiday_schedule"];
            this.summer_designday_schedule = _data["summer_designday_schedule"];
            this.winter_designday_schedule = _data["winter_designday_schedule"];
            this.schedule_type_limit = _data["schedule_type_limit"];
        }
    }

    static override fromJS(data: any): ScheduleRulesetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleRulesetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.day_schedules)) {
            data["day_schedules"] = [];
            for (let item of this.day_schedules)
                data["day_schedules"].push(item.toJSON());
        }
        data["default_day_schedule"] = this.default_day_schedule;
        data["type"] = this.type;
        if (Array.isArray(this.schedule_rules)) {
            data["schedule_rules"] = [];
            for (let item of this.schedule_rules)
                data["schedule_rules"].push(item.toJSON());
        }
        data["holiday_schedule"] = this.holiday_schedule;
        data["summer_designday_schedule"] = this.summer_designday_schedule;
        data["winter_designday_schedule"] = this.winter_designday_schedule;
        data["schedule_type_limit"] = this.schedule_type_limit;
        super.toJSON(data);
        return data;
    }
}

/** Used to define a schedule for a default day, further described by ScheduleRule. */
export interface IScheduleRulesetAbridged extends IIDdEnergyBaseModel {
    /** A list of ScheduleDays that are referenced in the other keys of this ScheduleRulesetAbridged. */
    day_schedules: ScheduleDay[];
    /** An identifier for the ScheduleDay that will be used for all days when no ScheduleRule is applied. This ScheduleDay must be in the day_schedules. */
    default_day_schedule: string;
    type?: string;
    /** A list of ScheduleRuleAbridged that note exceptions to the default_day_schedule. These rules should be ordered from highest to lowest priority. */
    schedule_rules?: ScheduleRuleAbridged[];
    /** An identifier for the ScheduleDay that will be used for holidays. This ScheduleDay must be in the day_schedules. */
    holiday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the summer design day. This ScheduleDay must be in the day_schedules. */
    summer_designday_schedule?: string;
    /** An identifier for the ScheduleDay that will be used for the winter design day. This ScheduleDay must be in the day_schedules. */
    winter_designday_schedule?: string;
    /** Identifier of a ScheduleTypeLimit that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: string;
}

/** Used to specify a start date and a list of values for a period of analysis. */
export class ScheduleFixedIntervalAbridged extends IDdEnergyBaseModel implements IScheduleFixedIntervalAbridged {
    /** A list of timeseries values occuring at each timestep over the course of the simulation. */
    values!: number[];
    readonly type: string = "ScheduleFixedIntervalAbridged";
    /** Identifier of a ScheduleTypeLimit that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: string;
    /** An integer for the number of steps per hour that the input values correspond to.  For example, if each value represents 30 minutes, the timestep is 2. For 15 minutes, it is 4. */
    timestep?: number;
    /** A list of two integers for [month, day], representing the start date when the schedule values begin to take effect.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /**  A value that will be used for all times not covered by the input values. Typically, your simulation should not need to use this value if the input values completely cover the simulation period. */
    placeholder_value?: number;
    /** Boolean to note whether values in between intervals should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;

    constructor(data?: IScheduleFixedIntervalAbridged) {
        super(data);
        if (!data) {
            this.values = [];
            this.type = "ScheduleFixedIntervalAbridged";
            this.timestep = 1;
            this.placeholder_value = 0;
            this.interpolate = false;
        }
        this._discriminator = "ScheduleFixedIntervalAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ScheduleFixedIntervalAbridged";
            this.schedule_type_limit = _data["schedule_type_limit"];
            this.timestep = _data["timestep"] !== undefined ? _data["timestep"] : 1;
            if (Array.isArray(_data["start_date"])) {
                this.start_date = [] as any;
                for (let item of _data["start_date"])
                    this.start_date!.push(item);
            }
            this.placeholder_value = _data["placeholder_value"] !== undefined ? _data["placeholder_value"] : 0;
            this.interpolate = _data["interpolate"] !== undefined ? _data["interpolate"] : false;
        }
    }

    static override fromJS(data: any): ScheduleFixedIntervalAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleFixedIntervalAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["type"] = this.type;
        data["schedule_type_limit"] = this.schedule_type_limit;
        data["timestep"] = this.timestep;
        if (Array.isArray(this.start_date)) {
            data["start_date"] = [];
            for (let item of this.start_date)
                data["start_date"].push(item);
        }
        data["placeholder_value"] = this.placeholder_value;
        data["interpolate"] = this.interpolate;
        super.toJSON(data);
        return data;
    }
}

/** Used to specify a start date and a list of values for a period of analysis. */
export interface IScheduleFixedIntervalAbridged extends IIDdEnergyBaseModel {
    /** A list of timeseries values occuring at each timestep over the course of the simulation. */
    values: number[];
    type?: string;
    /** Identifier of a ScheduleTypeLimit that will be used to validate schedule values against upper/lower limits and assign units to the schedule values. If None, no validation will occur. */
    schedule_type_limit?: string;
    /** An integer for the number of steps per hour that the input values correspond to.  For example, if each value represents 30 minutes, the timestep is 2. For 15 minutes, it is 4. */
    timestep?: number;
    /** A list of two integers for [month, day], representing the start date when the schedule values begin to take effect.A third integer may be added to denote whether the date should be re-serialized for a leap year (it should be a 1 in this case). */
    start_date?: number[];
    /**  A value that will be used for all times not covered by the input values. Typically, your simulation should not need to use this value if the input values completely cover the simulation period. */
    placeholder_value?: number;
    /** Boolean to note whether values in between intervals should be linearly interpolated or whether successive values should take effect immediately upon the beginning time corresponding to them. */
    interpolate?: boolean;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ModelEnergyProperties extends _OpenAPIGenBaseModel implements IModelEnergyProperties {
    readonly type: string = "ModelEnergyProperties";
    /** Global Energy construction set. */
    readonly global_construction_set?: GlobalConstructionSet;
    /** List of all ConstructionSets in the Model. */
    construction_sets?: Construction_sets[];
    /** A list of all unique constructions in the model. This includes constructions across all the Model construction_sets. */
    constructions?: constructions[];
    /** A list of all unique materials in the model. This includes materials needed to make the Model constructions. */
    materials?: materials3[];
    /** List of all HVAC systems in the Model. */
    hvacs?: Hvacs[];
    /** List of all Service Hot Water (SHW) systems in the Model. */
    shws?: SHWSystem[];
    /** List of all ProgramTypes in the Model. */
    program_types?: Program_types[];
    /** A list of all unique schedules in the model. This includes schedules across all HVAC systems, ProgramTypes and ContextShades. */
    schedules?: Schedules[];
    /** A list of all unique ScheduleTypeLimits in the model. This all ScheduleTypeLimits needed to make the Model schedules. */
    schedule_type_limits?: ScheduleTypeLimit[];

    constructor(data?: IModelEnergyProperties) {
        super(data);
        if (!data) {
            this.type = "ModelEnergyProperties";
        }
        this._discriminator = "ModelEnergyProperties";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModelEnergyProperties";
            (<any>this).global_construction_set = _data["global_construction_set"] ? GlobalConstructionSet.fromJS(_data["global_construction_set"]) : <any>undefined;
            if (Array.isArray(_data["construction_sets"])) {
                this.construction_sets = [] as any;
                for (let item of _data["construction_sets"])
                    this.construction_sets!.push(item);
            }
            if (Array.isArray(_data["constructions"])) {
                this.constructions = [] as any;
                for (let item of _data["constructions"])
                    this.constructions!.push(item);
            }
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(item);
            }
            if (Array.isArray(_data["hvacs"])) {
                this.hvacs = [] as any;
                for (let item of _data["hvacs"])
                    this.hvacs!.push(item);
            }
            if (Array.isArray(_data["shws"])) {
                this.shws = [] as any;
                for (let item of _data["shws"])
                    this.shws!.push(SHWSystem.fromJS(item));
            }
            if (Array.isArray(_data["program_types"])) {
                this.program_types = [] as any;
                for (let item of _data["program_types"])
                    this.program_types!.push(item);
            }
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [] as any;
                for (let item of _data["schedules"])
                    this.schedules!.push(item);
            }
            if (Array.isArray(_data["schedule_type_limits"])) {
                this.schedule_type_limits = [] as any;
                for (let item of _data["schedule_type_limits"])
                    this.schedule_type_limits!.push(ScheduleTypeLimit.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ModelEnergyProperties {
        data = typeof data === 'object' ? data : {};
        let result = new ModelEnergyProperties();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["global_construction_set"] = this.global_construction_set ? this.global_construction_set.toJSON() : <any>undefined;
        if (Array.isArray(this.construction_sets)) {
            data["construction_sets"] = [];
            for (let item of this.construction_sets)
                data["construction_sets"].push(item);
        }
        if (Array.isArray(this.constructions)) {
            data["constructions"] = [];
            for (let item of this.constructions)
                data["constructions"].push(item);
        }
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item);
        }
        if (Array.isArray(this.hvacs)) {
            data["hvacs"] = [];
            for (let item of this.hvacs)
                data["hvacs"].push(item);
        }
        if (Array.isArray(this.shws)) {
            data["shws"] = [];
            for (let item of this.shws)
                data["shws"].push(item.toJSON());
        }
        if (Array.isArray(this.program_types)) {
            data["program_types"] = [];
            for (let item of this.program_types)
                data["program_types"].push(item);
        }
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item);
        }
        if (Array.isArray(this.schedule_type_limits)) {
            data["schedule_type_limits"] = [];
            for (let item of this.schedule_type_limits)
                data["schedule_type_limits"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IModelEnergyProperties extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Global Energy construction set. */
    global_construction_set?: GlobalConstructionSet;
    /** List of all ConstructionSets in the Model. */
    construction_sets?: Construction_sets[];
    /** A list of all unique constructions in the model. This includes constructions across all the Model construction_sets. */
    constructions?: constructions[];
    /** A list of all unique materials in the model. This includes materials needed to make the Model constructions. */
    materials?: materials3[];
    /** List of all HVAC systems in the Model. */
    hvacs?: Hvacs[];
    /** List of all Service Hot Water (SHW) systems in the Model. */
    shws?: SHWSystem[];
    /** List of all ProgramTypes in the Model. */
    program_types?: Program_types[];
    /** A list of all unique schedules in the model. This includes schedules across all HVAC systems, ProgramTypes and ContextShades. */
    schedules?: Schedules[];
    /** A list of all unique ScheduleTypeLimits in the model. This all ScheduleTypeLimits needed to make the Model schedules. */
    schedule_type_limits?: ScheduleTypeLimit[];
}

/** Set containing radiance modifiers needed for a model's roofs. */
export class RoofCeilingModifierSet extends _OpenAPIGenBaseModel implements IRoofCeilingModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: Exterior_modifier;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: Interior_modifier;
    readonly type: string = "RoofCeilingModifierSet";

    constructor(data?: IRoofCeilingModifierSet) {
        super(data);
        if (!data) {
            this.type = "RoofCeilingModifierSet";
        }
        this._discriminator = "RoofCeilingModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoofCeilingModifierSet";
        }
    }

    static override fromJS(data: any): RoofCeilingModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new RoofCeilingModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's roofs. */
export interface IRoofCeilingModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: Exterior_modifier;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: Interior_modifier;
    type?: string;
}

/** Base class for the abridged modifier sets assigned to Faces. */
export class BaseModifierSetAbridged extends _OpenAPIGenBaseModel implements IBaseModifierSetAbridged {
    /** Identifier for a radiance modifier object for faces with an  Outdoors boundary condition. */
    exterior_modifier?: string;
    /** Identifier for a radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: string;
    readonly type: string = "BaseModifierSetAbridged";

    constructor(data?: IBaseModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "BaseModifierSetAbridged";
        }
        this._discriminator = "BaseModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BaseModifierSetAbridged";
        }
    }

    static override fromJS(data: any): BaseModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "WallModifierSetAbridged") {
            let result = new WallModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "FloorModifierSetAbridged") {
            let result = new FloorModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "RoofCeilingModifierSetAbridged") {
            let result = new RoofCeilingModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "DoorModifierSetAbridged") {
            let result = new DoorModifierSetAbridged();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShadeModifierSetAbridged") {
            let result = new ShadeModifierSetAbridged();
            result.init(data);
            return result;
        }
        let result = new BaseModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for the abridged modifier sets assigned to Faces. */
export interface IBaseModifierSetAbridged extends I_OpenAPIGenBaseModel {
    /** Identifier for a radiance modifier object for faces with an  Outdoors boundary condition. */
    exterior_modifier?: string;
    /** Identifier for a radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: string;
    type?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Walls. */
export class WallModifierSetAbridged extends BaseModifierSetAbridged implements IWallModifierSetAbridged {
    readonly type: string = "WallModifierSetAbridged";

    constructor(data?: IWallModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "WallModifierSetAbridged";
        }
        this._discriminator = "WallModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WallModifierSetAbridged";
        }
    }

    static override fromJS(data: any): WallModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new WallModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Walls. */
export interface IWallModifierSetAbridged extends IBaseModifierSetAbridged {
    type?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Floors. */
export class FloorModifierSetAbridged extends BaseModifierSetAbridged implements IFloorModifierSetAbridged {
    readonly type: string = "FloorModifierSetAbridged";

    constructor(data?: IFloorModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "FloorModifierSetAbridged";
        }
        this._discriminator = "FloorModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FloorModifierSetAbridged";
        }
    }

    static override fromJS(data: any): FloorModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new FloorModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Floors. */
export interface IFloorModifierSetAbridged extends IBaseModifierSetAbridged {
    type?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Roofs. */
export class RoofCeilingModifierSetAbridged extends BaseModifierSetAbridged implements IRoofCeilingModifierSetAbridged {
    readonly type: string = "RoofCeilingModifierSetAbridged";

    constructor(data?: IRoofCeilingModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "RoofCeilingModifierSetAbridged";
        }
        this._discriminator = "RoofCeilingModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoofCeilingModifierSetAbridged";
        }
    }

    static override fromJS(data: any): RoofCeilingModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new RoofCeilingModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Roofs. */
export interface IRoofCeilingModifierSetAbridged extends IBaseModifierSetAbridged {
    type?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Apertures. */
export class ApertureModifierSetAbridged extends _OpenAPIGenBaseModel implements IApertureModifierSetAbridged {
    readonly type: string = "ApertureModifierSetAbridged";
    /** Identifier of modifier object for apertures with an Outdoors boundary condition, False is_operable property, and Wall parent Face. */
    window_modifier?: string;
    /** Identifier of modifier object for apertures with a Surface boundary condition. */
    interior_modifier?: string;
    /** Identifier of modifier object for apertures with an Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_modifier?: string;
    /** Identifier of modifier object for apertures with an Outdoors boundary condition and a True is_operable property. */
    operable_modifier?: string;

    constructor(data?: IApertureModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "ApertureModifierSetAbridged";
        }
        this._discriminator = "ApertureModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureModifierSetAbridged";
            this.window_modifier = _data["window_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            this.skylight_modifier = _data["skylight_modifier"];
            this.operable_modifier = _data["operable_modifier"];
        }
    }

    static override fromJS(data: any): ApertureModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["window_modifier"] = this.window_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["skylight_modifier"] = this.skylight_modifier;
        data["operable_modifier"] = this.operable_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Apertures. */
export interface IApertureModifierSetAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of modifier object for apertures with an Outdoors boundary condition, False is_operable property, and Wall parent Face. */
    window_modifier?: string;
    /** Identifier of modifier object for apertures with a Surface boundary condition. */
    interior_modifier?: string;
    /** Identifier of modifier object for apertures with an Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_modifier?: string;
    /** Identifier of modifier object for apertures with an Outdoors boundary condition and a True is_operable property. */
    operable_modifier?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Doors. */
export class DoorModifierSetAbridged extends BaseModifierSetAbridged implements IDoorModifierSetAbridged {
    readonly type: string = "DoorModifierSetAbridged";
    /** Identifier of modifier object for glass with a Surface boundary condition. */
    interior_glass_modifier?: string;
    /** Identifier of modifier object for glass with an Outdoors boundary condition. */
    exterior_glass_modifier?: string;
    /** Identifier of a modifier object for doors with an Outdoors boundary condition and a RoofCeiling or Floor face type for their parent face. */
    overhead_modifier?: string;

    constructor(data?: IDoorModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "DoorModifierSetAbridged";
        }
        this._discriminator = "DoorModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorModifierSetAbridged";
            this.interior_glass_modifier = _data["interior_glass_modifier"];
            this.exterior_glass_modifier = _data["exterior_glass_modifier"];
            this.overhead_modifier = _data["overhead_modifier"];
        }
    }

    static override fromJS(data: any): DoorModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new DoorModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["interior_glass_modifier"] = this.interior_glass_modifier;
        data["exterior_glass_modifier"] = this.exterior_glass_modifier;
        data["overhead_modifier"] = this.overhead_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Doors. */
export interface IDoorModifierSetAbridged extends IBaseModifierSetAbridged {
    type?: string;
    /** Identifier of modifier object for glass with a Surface boundary condition. */
    interior_glass_modifier?: string;
    /** Identifier of modifier object for glass with an Outdoors boundary condition. */
    exterior_glass_modifier?: string;
    /** Identifier of a modifier object for doors with an Outdoors boundary condition and a RoofCeiling or Floor face type for their parent face. */
    overhead_modifier?: string;
}

/** Abridged set containing radiance modifiers needed for a model's Shade. */
export class ShadeModifierSetAbridged extends BaseModifierSetAbridged implements IShadeModifierSetAbridged {
    readonly type: string = "ShadeModifierSetAbridged";

    constructor(data?: IShadeModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "ShadeModifierSetAbridged";
        }
        this._discriminator = "ShadeModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadeModifierSetAbridged";
        }
    }

    static override fromJS(data: any): ShadeModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ShadeModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing radiance modifiers needed for a model's Shade. */
export interface IShadeModifierSetAbridged extends IBaseModifierSetAbridged {
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class GlobalModifierSet extends _OpenAPIGenBaseModel implements IGlobalModifierSet {
    readonly type: string = "GlobalModifierSet";
    /** Global Honeybee Radiance modifiers. */
    readonly modifiers?: Modifiers[];
    /** Global Honeybee WallModifierSet. */
    readonly wall_set?: WallModifierSetAbridged;
    /** Global Honeybee FloorModifierSet. */
    readonly floor_set?: FloorModifierSetAbridged;
    /** Global Honeybee RoofCeilingModifierSet. */
    readonly roof_ceiling_set?: RoofCeilingModifierSetAbridged;
    /** Global Honeybee ApertureModifierSet. */
    readonly aperture_set?: ApertureModifierSetAbridged;
    /** Global Honeybee DoorModifierSet. */
    readonly door_set?: DoorModifierSetAbridged;
    /** Global Honeybee ShadeModifierSet. */
    readonly shade_set?: ShadeModifierSetAbridged;
    /** Global Honeybee Modifier for AirBoundary Faces. */
    readonly air_boundary_modifier?: string;
    /** Global Honeybee Modifier for context Shades. */
    readonly context_modifier?: string;

    constructor(data?: IGlobalModifierSet) {
        super(data);
        if (!data) {
            this.type = "GlobalModifierSet";
            this.air_boundary_modifier = "air_boundary";
            this.context_modifier = "generic_context_0.20";
        }
        this._discriminator = "GlobalModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GlobalModifierSet";
            if (Array.isArray(_data["modifiers"])) {
                (<any>this).modifiers = [] as any;
                for (let item of _data["modifiers"])
                    (<any>this).modifiers!.push(item);
            }
            (<any>this).wall_set = _data["wall_set"] ? WallModifierSetAbridged.fromJS(_data["wall_set"]) : <any>undefined;
            (<any>this).floor_set = _data["floor_set"] ? FloorModifierSetAbridged.fromJS(_data["floor_set"]) : <any>undefined;
            (<any>this).roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingModifierSetAbridged.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            (<any>this).aperture_set = _data["aperture_set"] ? ApertureModifierSetAbridged.fromJS(_data["aperture_set"]) : <any>undefined;
            (<any>this).door_set = _data["door_set"] ? DoorModifierSetAbridged.fromJS(_data["door_set"]) : <any>undefined;
            (<any>this).shade_set = _data["shade_set"] ? ShadeModifierSetAbridged.fromJS(_data["shade_set"]) : <any>undefined;
            (<any>this).air_boundary_modifier = _data["air_boundary_modifier"] !== undefined ? _data["air_boundary_modifier"] : "air_boundary";
            (<any>this).context_modifier = _data["context_modifier"] !== undefined ? _data["context_modifier"] : "generic_context_0.20";
        }
    }

    static override fromJS(data: any): GlobalModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item);
        }
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_set"] = this.shade_set ? this.shade_set.toJSON() : <any>undefined;
        data["air_boundary_modifier"] = this.air_boundary_modifier;
        data["context_modifier"] = this.context_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IGlobalModifierSet extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Global Honeybee Radiance modifiers. */
    modifiers?: Modifiers[];
    /** Global Honeybee WallModifierSet. */
    wall_set?: WallModifierSetAbridged;
    /** Global Honeybee FloorModifierSet. */
    floor_set?: FloorModifierSetAbridged;
    /** Global Honeybee RoofCeilingModifierSet. */
    roof_ceiling_set?: RoofCeilingModifierSetAbridged;
    /** Global Honeybee ApertureModifierSet. */
    aperture_set?: ApertureModifierSetAbridged;
    /** Global Honeybee DoorModifierSet. */
    door_set?: DoorModifierSetAbridged;
    /** Global Honeybee ShadeModifierSet. */
    shade_set?: ShadeModifierSetAbridged;
    /** Global Honeybee Modifier for AirBoundary Faces. */
    air_boundary_modifier?: string;
    /** Global Honeybee Modifier for context Shades. */
    context_modifier?: string;
}

/** Set containing radiance modifiers needed for a model's Walls. */
export class WallModifierSet extends _OpenAPIGenBaseModel implements IWallModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier;
    readonly type: string = "WallModifierSet";

    constructor(data?: IWallModifierSet) {
        super(data);
        if (!data) {
            this.type = "WallModifierSet";
        }
        this._discriminator = "WallModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WallModifierSet";
        }
    }

    static override fromJS(data: any): WallModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new WallModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's Walls. */
export interface IWallModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier;
    type?: string;
}

/** Set containing radiance modifiers needed for a model's Floors. */
export class FloorModifierSet extends _OpenAPIGenBaseModel implements IFloorModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier2;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier2;
    readonly type: string = "FloorModifierSet";

    constructor(data?: IFloorModifierSet) {
        super(data);
        if (!data) {
            this.type = "FloorModifierSet";
        }
        this._discriminator = "FloorModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "FloorModifierSet";
        }
    }

    static override fromJS(data: any): FloorModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new FloorModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's Floors. */
export interface IFloorModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier2;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier2;
    type?: string;
}

/** Set containing radiance modifiers needed for a model's Apertures. */
export class ApertureModifierSet extends _OpenAPIGenBaseModel implements IApertureModifierSet {
    readonly type: string = "ApertureModifierSet";
    /** A modifier object for apertures with an Outdoors boundary condition, False is_operable property, and Wall parent Face. */
    window_modifier?: Window_modifier;
    /** A modifier object for apertures with a Surface boundary condition. */
    interior_modifier?: interior_modifier3;
    /** A modifier object for apertures with an Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_modifier?: Skylight_modifier;
    /** A modifier object for apertures with an Outdoors boundary condition and a True is_operable property. */
    operable_modifier?: Operable_modifier;

    constructor(data?: IApertureModifierSet) {
        super(data);
        if (!data) {
            this.type = "ApertureModifierSet";
        }
        this._discriminator = "ApertureModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ApertureModifierSet";
            this.window_modifier = _data["window_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            this.skylight_modifier = _data["skylight_modifier"];
            this.operable_modifier = _data["operable_modifier"];
        }
    }

    static override fromJS(data: any): ApertureModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new ApertureModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["window_modifier"] = this.window_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["skylight_modifier"] = this.skylight_modifier;
        data["operable_modifier"] = this.operable_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's Apertures. */
export interface IApertureModifierSet extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A modifier object for apertures with an Outdoors boundary condition, False is_operable property, and Wall parent Face. */
    window_modifier?: Window_modifier;
    /** A modifier object for apertures with a Surface boundary condition. */
    interior_modifier?: interior_modifier3;
    /** A modifier object for apertures with an Outdoors boundary condition, False is_operable property, and a RoofCeiling or Floor face type for their parent face. */
    skylight_modifier?: Skylight_modifier;
    /** A modifier object for apertures with an Outdoors boundary condition and a True is_operable property. */
    operable_modifier?: Operable_modifier;
}

/** Set containing radiance modifiers needed for a model's Doors. */
export class DoorModifierSet extends _OpenAPIGenBaseModel implements IDoorModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier3;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier4;
    /** A modifier object for glass with a Surface boundary condition. */
    interior_glass_modifier?: Interior_glass_modifier;
    /** A modifier object for glass with an Outdoors boundary condition. */
    exterior_glass_modifier?: Exterior_glass_modifier;
    /** A window modifier object for doors with an Outdoors boundary condition and a RoofCeiling or Floor face type for their parent face. */
    overhead_modifier?: Overhead_modifier;
    readonly type: string = "DoorModifierSet";

    constructor(data?: IDoorModifierSet) {
        super(data);
        if (!data) {
            this.type = "DoorModifierSet";
        }
        this._discriminator = "DoorModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            this.interior_glass_modifier = _data["interior_glass_modifier"];
            this.exterior_glass_modifier = _data["exterior_glass_modifier"];
            this.overhead_modifier = _data["overhead_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DoorModifierSet";
        }
    }

    static override fromJS(data: any): DoorModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new DoorModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["interior_glass_modifier"] = this.interior_glass_modifier;
        data["exterior_glass_modifier"] = this.exterior_glass_modifier;
        data["overhead_modifier"] = this.overhead_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's Doors. */
export interface IDoorModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier3;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier4;
    /** A modifier object for glass with a Surface boundary condition. */
    interior_glass_modifier?: Interior_glass_modifier;
    /** A modifier object for glass with an Outdoors boundary condition. */
    exterior_glass_modifier?: Exterior_glass_modifier;
    /** A window modifier object for doors with an Outdoors boundary condition and a RoofCeiling or Floor face type for their parent face. */
    overhead_modifier?: Overhead_modifier;
    type?: string;
}

/** Set containing radiance modifiers needed for a model's Shade. */
export class ShadeModifierSet extends _OpenAPIGenBaseModel implements IShadeModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier4;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier5;
    readonly type: string = "ShadeModifierSet";

    constructor(data?: IShadeModifierSet) {
        super(data);
        if (!data) {
            this.type = "ShadeModifierSet";
        }
        this._discriminator = "ShadeModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ShadeModifierSet";
        }
    }

    static override fromJS(data: any): ShadeModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new ShadeModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Set containing radiance modifiers needed for a model's Shade. */
export interface IShadeModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier4;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier5;
    type?: string;
}

/** Set containing all radiance modifiers needed to create a radiance model. */
export class ModifierSet extends IDdRadianceBaseModel implements IModifierSet {
    readonly type: string = "ModifierSet";
    /** An optional WallModifierSet object for this ModifierSet. (default: None). */
    wall_set?: WallModifierSet;
    /** An optional FloorModifierSet object for this ModifierSet. (default: None). */
    floor_set?: FloorModifierSet;
    /** An optional RoofCeilingModifierSet object for this ModifierSet. (default: None). */
    roof_ceiling_set?: RoofCeilingModifierSet;
    /** An optional ApertureModifierSet object for this ModifierSet. (default: None). */
    aperture_set?: ApertureModifierSet;
    /** An optional DoorModifierSet object for this ModifierSet. (default: None). */
    door_set?: DoorModifierSet;
    /** An optional ShadeModifierSet object for this ModifierSet. (default: None). */
    shade_set?: ShadeModifierSet;
    /** An optional Modifier to be used for all Faces with an AirBoundary face type. If None, it will be the honeybee generic air wall modifier. */
    air_boundary_modifier?: Air_boundary_modifier;

    constructor(data?: IModifierSet) {
        super(data);
        if (!data) {
            this.type = "ModifierSet";
        }
        this._discriminator = "ModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModifierSet";
            this.wall_set = _data["wall_set"] ? WallModifierSet.fromJS(_data["wall_set"]) : <any>undefined;
            this.floor_set = _data["floor_set"] ? FloorModifierSet.fromJS(_data["floor_set"]) : <any>undefined;
            this.roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingModifierSet.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            this.aperture_set = _data["aperture_set"] ? ApertureModifierSet.fromJS(_data["aperture_set"]) : <any>undefined;
            this.door_set = _data["door_set"] ? DoorModifierSet.fromJS(_data["door_set"]) : <any>undefined;
            this.shade_set = _data["shade_set"] ? ShadeModifierSet.fromJS(_data["shade_set"]) : <any>undefined;
            this.air_boundary_modifier = _data["air_boundary_modifier"];
        }
    }

    static override fromJS(data: any): ModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new ModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_set"] = this.shade_set ? this.shade_set.toJSON() : <any>undefined;
        data["air_boundary_modifier"] = this.air_boundary_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Set containing all radiance modifiers needed to create a radiance model. */
export interface IModifierSet extends IIDdRadianceBaseModel {
    type?: string;
    /** An optional WallModifierSet object for this ModifierSet. (default: None). */
    wall_set?: WallModifierSet;
    /** An optional FloorModifierSet object for this ModifierSet. (default: None). */
    floor_set?: FloorModifierSet;
    /** An optional RoofCeilingModifierSet object for this ModifierSet. (default: None). */
    roof_ceiling_set?: RoofCeilingModifierSet;
    /** An optional ApertureModifierSet object for this ModifierSet. (default: None). */
    aperture_set?: ApertureModifierSet;
    /** An optional DoorModifierSet object for this ModifierSet. (default: None). */
    door_set?: DoorModifierSet;
    /** An optional ShadeModifierSet object for this ModifierSet. (default: None). */
    shade_set?: ShadeModifierSet;
    /** An optional Modifier to be used for all Faces with an AirBoundary face type. If None, it will be the honeybee generic air wall modifier. */
    air_boundary_modifier?: Air_boundary_modifier;
}

/** Abridged set containing all modifiers needed to create a radiance model. */
export class ModifierSetAbridged extends IDdRadianceBaseModel implements IModifierSetAbridged {
    readonly type: string = "ModifierSetAbridged";
    /** Optional WallModifierSet object for this ModifierSet (default: None). */
    wall_set?: WallModifierSetAbridged;
    /** Optional FloorModifierSet object for this ModifierSet (default: None). */
    floor_set?: FloorModifierSetAbridged;
    /** Optional RoofCeilingModifierSet object for this ModifierSet (default: None). */
    roof_ceiling_set?: RoofCeilingModifierSetAbridged;
    /** Optional ApertureModifierSet object for this ModifierSet (default: None). */
    aperture_set?: ApertureModifierSetAbridged;
    /** Optional DoorModifierSet object for this ModifierSet (default: None). */
    door_set?: DoorModifierSetAbridged;
    /** Optional ShadeModifierSet object for this ModifierSet (default: None). */
    shade_set?: ShadeModifierSetAbridged;
    /** Optional Modifier to be used for all Faces with an AirBoundary face type. If None, it will be the honeybee generic air wall modifier. */
    air_boundary_modifier?: string;

    constructor(data?: IModifierSetAbridged) {
        super(data);
        if (!data) {
            this.type = "ModifierSetAbridged";
        }
        this._discriminator = "ModifierSetAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModifierSetAbridged";
            this.wall_set = _data["wall_set"] ? WallModifierSetAbridged.fromJS(_data["wall_set"]) : <any>undefined;
            this.floor_set = _data["floor_set"] ? FloorModifierSetAbridged.fromJS(_data["floor_set"]) : <any>undefined;
            this.roof_ceiling_set = _data["roof_ceiling_set"] ? RoofCeilingModifierSetAbridged.fromJS(_data["roof_ceiling_set"]) : <any>undefined;
            this.aperture_set = _data["aperture_set"] ? ApertureModifierSetAbridged.fromJS(_data["aperture_set"]) : <any>undefined;
            this.door_set = _data["door_set"] ? DoorModifierSetAbridged.fromJS(_data["door_set"]) : <any>undefined;
            this.shade_set = _data["shade_set"] ? ShadeModifierSetAbridged.fromJS(_data["shade_set"]) : <any>undefined;
            this.air_boundary_modifier = _data["air_boundary_modifier"];
        }
    }

    static override fromJS(data: any): ModifierSetAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ModifierSetAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["wall_set"] = this.wall_set ? this.wall_set.toJSON() : <any>undefined;
        data["floor_set"] = this.floor_set ? this.floor_set.toJSON() : <any>undefined;
        data["roof_ceiling_set"] = this.roof_ceiling_set ? this.roof_ceiling_set.toJSON() : <any>undefined;
        data["aperture_set"] = this.aperture_set ? this.aperture_set.toJSON() : <any>undefined;
        data["door_set"] = this.door_set ? this.door_set.toJSON() : <any>undefined;
        data["shade_set"] = this.shade_set ? this.shade_set.toJSON() : <any>undefined;
        data["air_boundary_modifier"] = this.air_boundary_modifier;
        super.toJSON(data);
        return data;
    }
}

/** Abridged set containing all modifiers needed to create a radiance model. */
export interface IModifierSetAbridged extends IIDdRadianceBaseModel {
    type?: string;
    /** Optional WallModifierSet object for this ModifierSet (default: None). */
    wall_set?: WallModifierSetAbridged;
    /** Optional FloorModifierSet object for this ModifierSet (default: None). */
    floor_set?: FloorModifierSetAbridged;
    /** Optional RoofCeilingModifierSet object for this ModifierSet (default: None). */
    roof_ceiling_set?: RoofCeilingModifierSetAbridged;
    /** Optional ApertureModifierSet object for this ModifierSet (default: None). */
    aperture_set?: ApertureModifierSetAbridged;
    /** Optional DoorModifierSet object for this ModifierSet (default: None). */
    door_set?: DoorModifierSetAbridged;
    /** Optional ShadeModifierSet object for this ModifierSet (default: None). */
    shade_set?: ShadeModifierSetAbridged;
    /** Optional Modifier to be used for all Faces with an AirBoundary face type. If None, it will be the honeybee generic air wall modifier. */
    air_boundary_modifier?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ModelRadianceProperties extends _OpenAPIGenBaseModel implements IModelRadianceProperties {
    readonly type: string = "ModelRadianceProperties";
    /** Global Radiance modifier set. */
    readonly global_modifier_set?: GlobalModifierSet;
    /** List of all ModifierSets in the Model. */
    modifier_sets?: Modifier_sets[];
    /** A list of all unique modifiers in the model. This includes modifiers across all the Model modifier_sets. */
    modifiers?: modifiers[];

    constructor(data?: IModelRadianceProperties) {
        super(data);
        if (!data) {
            this.type = "ModelRadianceProperties";
        }
        this._discriminator = "ModelRadianceProperties";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModelRadianceProperties";
            (<any>this).global_modifier_set = _data["global_modifier_set"] ? GlobalModifierSet.fromJS(_data["global_modifier_set"]) : <any>undefined;
            if (Array.isArray(_data["modifier_sets"])) {
                this.modifier_sets = [] as any;
                for (let item of _data["modifier_sets"])
                    this.modifier_sets!.push(item);
            }
            if (Array.isArray(_data["modifiers"])) {
                this.modifiers = [] as any;
                for (let item of _data["modifiers"])
                    this.modifiers!.push(item);
            }
        }
    }

    static override fromJS(data: any): ModelRadianceProperties {
        data = typeof data === 'object' ? data : {};
        let result = new ModelRadianceProperties();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["global_modifier_set"] = this.global_modifier_set ? this.global_modifier_set.toJSON() : <any>undefined;
        if (Array.isArray(this.modifier_sets)) {
            data["modifier_sets"] = [];
            for (let item of this.modifier_sets)
                data["modifier_sets"].push(item);
        }
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IModelRadianceProperties extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Global Radiance modifier set. */
    global_modifier_set?: GlobalModifierSet;
    /** List of all ModifierSets in the Model. */
    modifier_sets?: Modifier_sets[];
    /** A list of all unique modifiers in the model. This includes modifiers across all the Model modifier_sets. */
    modifiers?: modifiers[];
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Room2DEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IRoom2DEnergyPropertiesAbridged {
    readonly type: string = "Room2DEnergyPropertiesAbridged";
    /** Name of a ConstructionSet to specify all constructions for the Room2D. If None, the Room2D will use the Story or Building construction_set or the Model global_construction_set. Any ConstructionSet assigned here will override those assigned to these objects. */
    construction_set?: string;
    /** Name of a ProgramType to specify all schedules and loads for the Room2D. If None, the Room2D will have no loads or setpoints. */
    program_type?: string;
    /** An optional identifier of a HVAC system (such as an IdealAirSystem) that specifies how the Room2D is conditioned. If None, it will be assumed that the Room2D is not conditioned. */
    hvac?: string;
    /** An optional identifier of a Service Hot Water (SHW) system that specifies how the hot water load of the Room is met. If None, the hot water load will be met with a generic system that only measures thermal loadand does not account for system efficiencies. */
    shw?: string;
    /** An optional VentilationControl object to dictate the opening of windows. If None, the windows will never open. */
    window_vent_control?: VentilationControlAbridged;
    /** An optional VentilationOpening to specify the operable portion of all windows of the Room2D. If None, the windows will never open. */
    window_vent_opening?: VentilationOpening;
    /** An optional list of Process objects for process loads within the room. These can represent wood burning fireplaces, kilns, manufacturing equipment, and various industrial processes. They can also be used to represent certain pieces of equipment to be separated from the other end uses, such as MRI machines, theatrical lighting, and elevators. */
    process_loads?: ProcessAbridged[];

    constructor(data?: IRoom2DEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "Room2DEnergyPropertiesAbridged";
        }
        this._discriminator = "Room2DEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Room2DEnergyPropertiesAbridged";
            this.construction_set = _data["construction_set"];
            this.program_type = _data["program_type"];
            this.hvac = _data["hvac"];
            this.shw = _data["shw"];
            this.window_vent_control = _data["window_vent_control"] ? VentilationControlAbridged.fromJS(_data["window_vent_control"]) : <any>undefined;
            this.window_vent_opening = _data["window_vent_opening"] ? VentilationOpening.fromJS(_data["window_vent_opening"]) : <any>undefined;
            if (Array.isArray(_data["process_loads"])) {
                this.process_loads = [] as any;
                for (let item of _data["process_loads"])
                    this.process_loads!.push(ProcessAbridged.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Room2DEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new Room2DEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction_set"] = this.construction_set;
        data["program_type"] = this.program_type;
        data["hvac"] = this.hvac;
        data["shw"] = this.shw;
        data["window_vent_control"] = this.window_vent_control ? this.window_vent_control.toJSON() : <any>undefined;
        data["window_vent_opening"] = this.window_vent_opening ? this.window_vent_opening.toJSON() : <any>undefined;
        if (Array.isArray(this.process_loads)) {
            data["process_loads"] = [];
            for (let item of this.process_loads)
                data["process_loads"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IRoom2DEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ConstructionSet to specify all constructions for the Room2D. If None, the Room2D will use the Story or Building construction_set or the Model global_construction_set. Any ConstructionSet assigned here will override those assigned to these objects. */
    construction_set?: string;
    /** Name of a ProgramType to specify all schedules and loads for the Room2D. If None, the Room2D will have no loads or setpoints. */
    program_type?: string;
    /** An optional identifier of a HVAC system (such as an IdealAirSystem) that specifies how the Room2D is conditioned. If None, it will be assumed that the Room2D is not conditioned. */
    hvac?: string;
    /** An optional identifier of a Service Hot Water (SHW) system that specifies how the hot water load of the Room is met. If None, the hot water load will be met with a generic system that only measures thermal loadand does not account for system efficiencies. */
    shw?: string;
    /** An optional VentilationControl object to dictate the opening of windows. If None, the windows will never open. */
    window_vent_control?: VentilationControlAbridged;
    /** An optional VentilationOpening to specify the operable portion of all windows of the Room2D. If None, the windows will never open. */
    window_vent_opening?: VentilationOpening;
    /** An optional list of Process objects for process loads within the room. These can represent wood burning fireplaces, kilns, manufacturing equipment, and various industrial processes. They can also be used to represent certain pieces of equipment to be separated from the other end uses, such as MRI machines, theatrical lighting, and elevators. */
    process_loads?: ProcessAbridged[];
}

/** Base class for all window parameters. */
export class _WindowParameterBase extends _OpenAPIGenBaseModel implements I_WindowParameterBase {
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). When a list is used, each item in the list will be assigned to the generated Honeybee apertures. */
    user_data?: any;
    readonly type: string = "_WindowParameterBase";

    constructor(data?: I_WindowParameterBase) {
        super(data);
        if (!data) {
            this.type = "_WindowParameterBase";
        }
        this._discriminator = "_WindowParameterBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user_data = _data["user_data"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_WindowParameterBase";
        }
    }

    static override fromJS(data: any): _WindowParameterBase {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "SingleWindow") {
            let result = new SingleWindow();
            result.init(data);
            return result;
        }
        if (data["type"] === "SimpleWindowArea") {
            let result = new SimpleWindowArea();
            result.init(data);
            return result;
        }
        if (data["type"] === "SimpleWindowRatio") {
            let result = new SimpleWindowRatio();
            result.init(data);
            return result;
        }
        if (data["type"] === "RepeatingWindowRatio") {
            let result = new RepeatingWindowRatio();
            result.init(data);
            return result;
        }
        if (data["type"] === "RectangularWindows") {
            let result = new RectangularWindows();
            result.init(data);
            return result;
        }
        if (data["type"] === "DetailedWindows") {
            let result = new DetailedWindows();
            result.init(data);
            return result;
        }
        let result = new _WindowParameterBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_data"] = this.user_data;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all window parameters. */
export interface I_WindowParameterBase extends I_OpenAPIGenBaseModel {
    /** Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list). When a list is used, each item in the list will be assigned to the generated Honeybee apertures. */
    user_data?: any;
    type?: string;
}

/** A single window in the wall center defined by a width * height. */
export class SingleWindow extends _WindowParameterBase implements ISingleWindow {
    /** A number for the window width. Note that, if this width is applied to a wall that is too narrow for this width, the generated window will automatically be shortened when it is applied to the wall. In this way, setting the width to be `float("inf")` will create parameters that always generate a ribbon window. */
    width!: number;
    /** A number for the window height. Note that, if this height is applied to a wall that is too short for this height, the generated window will automatically be shortened when it is applied to the wall. */
    height!: number;
    readonly type: string = "SingleWindow";
    /** A number for the window sill height. */
    sill_height?: number;

    constructor(data?: ISingleWindow) {
        super(data);
        if (!data) {
            this.type = "SingleWindow";
            this.sill_height = 1;
        }
        this._discriminator = "SingleWindow";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "SingleWindow";
            this.sill_height = _data["sill_height"] !== undefined ? _data["sill_height"] : 1;
        }
    }

    static override fromJS(data: any): SingleWindow {
        data = typeof data === 'object' ? data : {};
        let result = new SingleWindow();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["type"] = this.type;
        data["sill_height"] = this.sill_height;
        super.toJSON(data);
        return data;
    }
}

/** A single window in the wall center defined by a width * height. */
export interface ISingleWindow extends I_WindowParameterBase {
    /** A number for the window width. Note that, if this width is applied to a wall that is too narrow for this width, the generated window will automatically be shortened when it is applied to the wall. In this way, setting the width to be `float("inf")` will create parameters that always generate a ribbon window. */
    width: number;
    /** A number for the window height. Note that, if this height is applied to a wall that is too short for this height, the generated window will automatically be shortened when it is applied to the wall. */
    height: number;
    type?: string;
    /** A number for the window sill height. */
    sill_height?: number;
}

/** A single window defined by an absolute area. */
export class SimpleWindowArea extends _WindowParameterBase implements ISimpleWindowArea {
    /** A number for the window area in current model units. If this area is larger than the area of the Wall that it is appliedto, the window will fill the parent Wall at a 99 percent ratio. */
    window_area!: number;
    readonly type: string = "SimpleWindowArea";

    constructor(data?: ISimpleWindowArea) {
        super(data);
        if (!data) {
            this.type = "SimpleWindowArea";
        }
        this._discriminator = "SimpleWindowArea";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.window_area = _data["window_area"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "SimpleWindowArea";
        }
    }

    static override fromJS(data: any): SimpleWindowArea {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWindowArea();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["window_area"] = this.window_area;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A single window defined by an absolute area. */
export interface ISimpleWindowArea extends I_WindowParameterBase {
    /** A number for the window area in current model units. If this area is larger than the area of the Wall that it is appliedto, the window will fill the parent Wall at a 99 percent ratio. */
    window_area: number;
    type?: string;
}

/** A single window defined by an area ratio with the base surface. */
export class SimpleWindowRatio extends _WindowParameterBase implements ISimpleWindowRatio {
    /** A number between 0 and 1 for the ratio between the window area and the parent wall surface area. */
    window_ratio!: number;
    readonly type: string = "SimpleWindowRatio";

    constructor(data?: ISimpleWindowRatio) {
        super(data);
        if (!data) {
            this.type = "SimpleWindowRatio";
        }
        this._discriminator = "SimpleWindowRatio";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.window_ratio = _data["window_ratio"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "SimpleWindowRatio";
        }
    }

    static override fromJS(data: any): SimpleWindowRatio {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWindowRatio();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["window_ratio"] = this.window_ratio;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A single window defined by an area ratio with the base surface. */
export interface ISimpleWindowRatio extends I_WindowParameterBase {
    /** A number between 0 and 1 for the ratio between the window area and the parent wall surface area. */
    window_ratio: number;
    type?: string;
}

/** Repeating windows derived from an area ratio with the base wall. */
export class RepeatingWindowRatio extends _WindowParameterBase implements IRepeatingWindowRatio {
    /** A number between 0 and 1 for the ratio between the window area and the parent wall surface area. */
    window_ratio!: number;
    /** A number for the target height of the windows. Note that, if the window ratio is too large for the height, the ratio will take precedence and the actual window_height will be larger than this value. */
    window_height!: number;
    /** A number for the target height above the bottom edge of the wall to start the windows. Note that, if the ratio is too large for the height, the ratio will take precedence and the sill_height will be smaller than this value. */
    sill_height!: number;
    /** A number for the target separation between individual window centerlines.  If this number is larger than the parent rectangle base, only one window will be produced. */
    horizontal_separation!: number;
    readonly type: string = "RepeatingWindowRatio";
    /** An optional number to create a single vertical separation between top and bottom windows. */
    vertical_separation?: number;

    constructor(data?: IRepeatingWindowRatio) {
        super(data);
        if (!data) {
            this.type = "RepeatingWindowRatio";
            this.vertical_separation = 0;
        }
        this._discriminator = "RepeatingWindowRatio";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.window_ratio = _data["window_ratio"];
            this.window_height = _data["window_height"];
            this.sill_height = _data["sill_height"];
            this.horizontal_separation = _data["horizontal_separation"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RepeatingWindowRatio";
            this.vertical_separation = _data["vertical_separation"] !== undefined ? _data["vertical_separation"] : 0;
        }
    }

    static override fromJS(data: any): RepeatingWindowRatio {
        data = typeof data === 'object' ? data : {};
        let result = new RepeatingWindowRatio();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["window_ratio"] = this.window_ratio;
        data["window_height"] = this.window_height;
        data["sill_height"] = this.sill_height;
        data["horizontal_separation"] = this.horizontal_separation;
        data["type"] = this.type;
        data["vertical_separation"] = this.vertical_separation;
        super.toJSON(data);
        return data;
    }
}

/** Repeating windows derived from an area ratio with the base wall. */
export interface IRepeatingWindowRatio extends I_WindowParameterBase {
    /** A number between 0 and 1 for the ratio between the window area and the parent wall surface area. */
    window_ratio: number;
    /** A number for the target height of the windows. Note that, if the window ratio is too large for the height, the ratio will take precedence and the actual window_height will be larger than this value. */
    window_height: number;
    /** A number for the target height above the bottom edge of the wall to start the windows. Note that, if the ratio is too large for the height, the ratio will take precedence and the sill_height will be smaller than this value. */
    sill_height: number;
    /** A number for the target separation between individual window centerlines.  If this number is larger than the parent rectangle base, only one window will be produced. */
    horizontal_separation: number;
    type?: string;
    /** An optional number to create a single vertical separation between top and bottom windows. */
    vertical_separation?: number;
}

/** Several rectangular windows, defined by origin, width and height. */
export class RectangularWindows extends _WindowParameterBase implements IRectangularWindows {
    /** An array of 2D points within the plane of the wall for the origin of each window. Each point should be a list of 2 (x, y) values. The wall plane is assumed to have an origin at the first point of the wall segment and an X-axis extending along the length of the segment. The wall plane Y-axis always points upwards. Therefore, both X and Y values of each origin point should be positive. */
    origins!: number[][];
    /** An array of positive numbers for the window widths. The length of this list must match the length of the origins. */
    widths!: number[];
    /** An array of positive numbers for the window heights. The length of this list must match the length of the origins. */
    heights!: number[];
    readonly type: string = "RectangularWindows";
    /** An array of booleans that align with the origins and note whether each of the geometries represents a door (True) or a window (False). If None, it will be assumed that all geometries represent windows and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];

    constructor(data?: IRectangularWindows) {
        super(data);
        if (!data) {
            this.origins = [];
            this.widths = [];
            this.heights = [];
            this.type = "RectangularWindows";
        }
        this._discriminator = "RectangularWindows";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["origins"])) {
                this.origins = [] as any;
                for (let item of _data["origins"])
                    this.origins!.push(item);
            }
            if (Array.isArray(_data["widths"])) {
                this.widths = [] as any;
                for (let item of _data["widths"])
                    this.widths!.push(item);
            }
            if (Array.isArray(_data["heights"])) {
                this.heights = [] as any;
                for (let item of _data["heights"])
                    this.heights!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RectangularWindows";
            if (Array.isArray(_data["are_doors"])) {
                this.are_doors = [] as any;
                for (let item of _data["are_doors"])
                    this.are_doors!.push(item);
            }
        }
    }

    static override fromJS(data: any): RectangularWindows {
        data = typeof data === 'object' ? data : {};
        let result = new RectangularWindows();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.origins)) {
            data["origins"] = [];
            for (let item of this.origins)
                data["origins"].push(item);
        }
        if (Array.isArray(this.widths)) {
            data["widths"] = [];
            for (let item of this.widths)
                data["widths"].push(item);
        }
        if (Array.isArray(this.heights)) {
            data["heights"] = [];
            for (let item of this.heights)
                data["heights"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.are_doors)) {
            data["are_doors"] = [];
            for (let item of this.are_doors)
                data["are_doors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Several rectangular windows, defined by origin, width and height. */
export interface IRectangularWindows extends I_WindowParameterBase {
    /** An array of 2D points within the plane of the wall for the origin of each window. Each point should be a list of 2 (x, y) values. The wall plane is assumed to have an origin at the first point of the wall segment and an X-axis extending along the length of the segment. The wall plane Y-axis always points upwards. Therefore, both X and Y values of each origin point should be positive. */
    origins: number[][];
    /** An array of positive numbers for the window widths. The length of this list must match the length of the origins. */
    widths: number[];
    /** An array of positive numbers for the window heights. The length of this list must match the length of the origins. */
    heights: number[];
    type?: string;
    /** An array of booleans that align with the origins and note whether each of the geometries represents a door (True) or a window (False). If None, it will be assumed that all geometries represent windows and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];
}

/** Several detailed windows defined by 2D Polygons (lists of 2D vertices). */
export class DetailedWindows extends _WindowParameterBase implements IDetailedWindows {
    /** An array of arrays with each sub-array representing a polygonal boundary of a window. Each sub-array should consist of arrays representing points, which can either contain 2 values (indicating they are 2D vertices within the plane of a parent wall segment) or they can contain 3 values (indicating they are 3D world coordinates). For 2D points, the wall plane is assumed to have an origin at the first point of the wall segment and an X-axis extending along the length of the segment. The wall plane Y-axis always points upwards. Therefore, both X and Y values of each point in the polygon should always be positive. Some sample code to convert from 2D vertices to 2D vertices in the plane of the wall can be found here: https://www.ladybug.tools/dragonfly-core/docs/dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows */
    polygons!: number[][][];
    readonly type: string = "DetailedWindows";
    /** An array of booleans that align with the polygons and note whether each of the polygons represents a door (True) or a window (False). If None, it will be assumed that all polygons represent windows and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];

    constructor(data?: IDetailedWindows) {
        super(data);
        if (!data) {
            this.polygons = [];
            this.type = "DetailedWindows";
        }
        this._discriminator = "DetailedWindows";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["polygons"])) {
                this.polygons = [] as any;
                for (let item of _data["polygons"])
                    this.polygons!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DetailedWindows";
            if (Array.isArray(_data["are_doors"])) {
                this.are_doors = [] as any;
                for (let item of _data["are_doors"])
                    this.are_doors!.push(item);
            }
        }
    }

    static override fromJS(data: any): DetailedWindows {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedWindows();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.polygons)) {
            data["polygons"] = [];
            for (let item of this.polygons)
                data["polygons"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.are_doors)) {
            data["are_doors"] = [];
            for (let item of this.are_doors)
                data["are_doors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Several detailed windows defined by 2D Polygons (lists of 2D vertices). */
export interface IDetailedWindows extends I_WindowParameterBase {
    /** An array of arrays with each sub-array representing a polygonal boundary of a window. Each sub-array should consist of arrays representing points, which can either contain 2 values (indicating they are 2D vertices within the plane of a parent wall segment) or they can contain 3 values (indicating they are 3D world coordinates). For 2D points, the wall plane is assumed to have an origin at the first point of the wall segment and an X-axis extending along the length of the segment. The wall plane Y-axis always points upwards. Therefore, both X and Y values of each point in the polygon should always be positive. Some sample code to convert from 2D vertices to 2D vertices in the plane of the wall can be found here: https://www.ladybug.tools/dragonfly-core/docs/dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows */
    polygons: number[][][];
    type?: string;
    /** An array of booleans that align with the polygons and note whether each of the polygons represents a door (True) or a window (False). If None, it will be assumed that all polygons represent windows and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];
}

/** Extruded borders over all windows in the wall. */
export class ExtrudedBorder extends _OpenAPIGenBaseModel implements IExtrudedBorder {
    /** A number for the depth of the border. */
    depth!: number;
    readonly type: string = "ExtrudedBorder";

    constructor(data?: IExtrudedBorder) {
        super(data);
        if (!data) {
            this.type = "ExtrudedBorder";
        }
        this._discriminator = "ExtrudedBorder";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.depth = _data["depth"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ExtrudedBorder";
        }
    }

    static override fromJS(data: any): ExtrudedBorder {
        data = typeof data === 'object' ? data : {};
        let result = new ExtrudedBorder();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["depth"] = this.depth;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Extruded borders over all windows in the wall. */
export interface IExtrudedBorder extends I_OpenAPIGenBaseModel {
    /** A number for the depth of the border. */
    depth: number;
    type?: string;
}

/** A single overhang over an entire wall. */
export class Overhang extends _OpenAPIGenBaseModel implements IOverhang {
    /** A number for the overhang depth. */
    depth!: number;
    readonly type: string = "Overhang";
    /** A number between -90 and 90 for the for an angle to rotate the overhang in degrees. 0 indicates an overhang perpendicular to the wall. Positive values indicate a downward rotation. Negative values indicate an upward rotation. */
    angle?: number;

    constructor(data?: IOverhang) {
        super(data);
        if (!data) {
            this.type = "Overhang";
            this.angle = 0;
        }
        this._discriminator = "Overhang";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.depth = _data["depth"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Overhang";
            this.angle = _data["angle"] !== undefined ? _data["angle"] : 0;
        }
    }

    static override fromJS(data: any): Overhang {
        data = typeof data === 'object' ? data : {};
        let result = new Overhang();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["depth"] = this.depth;
        data["type"] = this.type;
        data["angle"] = this.angle;
        super.toJSON(data);
        return data;
    }
}

/** A single overhang over an entire wall. */
export interface IOverhang extends I_OpenAPIGenBaseModel {
    /** A number for the overhang depth. */
    depth: number;
    type?: string;
    /** A number between -90 and 90 for the for an angle to rotate the overhang in degrees. 0 indicates an overhang perpendicular to the wall. Positive values indicate a downward rotation. Negative values indicate an upward rotation. */
    angle?: number;
}

/** Base class for for a series of louvered shades over a wall. */
export class _LouversBase extends _OpenAPIGenBaseModel implements I_LouversBase {
    /** A number for the depth to extrude the louvers. */
    depth!: number;
    /** A number for the distance to louvers from the wall. */
    offset?: number;
    /** A number between -90 and 90 for the for an angle to rotate the louvers in degrees. 0 indicates louvers perpendicular to the wall. Positive values indicate a downward rotation. Negative values indicate an upward rotation. */
    angle?: number;
    /** A list of two float values representing the (x, y) of a 2D vector for the direction along which contours are generated. (0, 1) will generate horizontal contours, (1, 0) will generate vertical contours, and (1, 1) will generate diagonal contours. */
    contour_vector?: number[];
    /** Boolean to note whether the side the louvers start from should be flipped. Default is False to have contours on top or right. Setting to True will start contours on the bottom or left. */
    flip_start_side?: boolean;
    readonly type: string = "_LouversBase";

    constructor(data?: I_LouversBase) {
        super(data);
        if (!data) {
            this.offset = 0;
            this.angle = 0;
            this.flip_start_side = false;
            this.type = "_LouversBase";
        }
        this._discriminator = "_LouversBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.depth = _data["depth"];
            this.offset = _data["offset"] !== undefined ? _data["offset"] : 0;
            this.angle = _data["angle"] !== undefined ? _data["angle"] : 0;
            if (Array.isArray(_data["contour_vector"])) {
                this.contour_vector = [] as any;
                for (let item of _data["contour_vector"])
                    this.contour_vector!.push(item);
            }
            this.flip_start_side = _data["flip_start_side"] !== undefined ? _data["flip_start_side"] : false;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_LouversBase";
        }
    }

    static override fromJS(data: any): _LouversBase {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "LouversByDistance") {
            let result = new LouversByDistance();
            result.init(data);
            return result;
        }
        if (data["type"] === "LouversByCount") {
            let result = new LouversByCount();
            result.init(data);
            return result;
        }
        let result = new _LouversBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["depth"] = this.depth;
        data["offset"] = this.offset;
        data["angle"] = this.angle;
        if (Array.isArray(this.contour_vector)) {
            data["contour_vector"] = [];
            for (let item of this.contour_vector)
                data["contour_vector"].push(item);
        }
        data["flip_start_side"] = this.flip_start_side;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for for a series of louvered shades over a wall. */
export interface I_LouversBase extends I_OpenAPIGenBaseModel {
    /** A number for the depth to extrude the louvers. */
    depth: number;
    /** A number for the distance to louvers from the wall. */
    offset?: number;
    /** A number between -90 and 90 for the for an angle to rotate the louvers in degrees. 0 indicates louvers perpendicular to the wall. Positive values indicate a downward rotation. Negative values indicate an upward rotation. */
    angle?: number;
    /** A list of two float values representing the (x, y) of a 2D vector for the direction along which contours are generated. (0, 1) will generate horizontal contours, (1, 0) will generate vertical contours, and (1, 1) will generate diagonal contours. */
    contour_vector?: number[];
    /** Boolean to note whether the side the louvers start from should be flipped. Default is False to have contours on top or right. Setting to True will start contours on the bottom or left. */
    flip_start_side?: boolean;
    type?: string;
}

/** A series of louvered Shades at a given distance between each louver. */
export class LouversByDistance extends _LouversBase implements ILouversByDistance {
    /** A number for the approximate distance between each louver. */
    distance!: number;
    readonly type: string = "LouversByDistance";

    constructor(data?: ILouversByDistance) {
        super(data);
        if (!data) {
            this.type = "LouversByDistance";
        }
        this._discriminator = "LouversByDistance";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.distance = _data["distance"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "LouversByDistance";
        }
    }

    static override fromJS(data: any): LouversByDistance {
        data = typeof data === 'object' ? data : {};
        let result = new LouversByDistance();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["distance"] = this.distance;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A series of louvered Shades at a given distance between each louver. */
export interface ILouversByDistance extends I_LouversBase {
    /** A number for the approximate distance between each louver. */
    distance: number;
    type?: string;
}

/** A specific number of louvered Shades over a wall. */
export class LouversByCount extends _LouversBase implements ILouversByCount {
    /** A positive integer for the number of louvers to generate. */
    louver_count!: number;
    readonly type: string = "LouversByCount";

    constructor(data?: ILouversByCount) {
        super(data);
        if (!data) {
            this.type = "LouversByCount";
        }
        this._discriminator = "LouversByCount";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.louver_count = _data["louver_count"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "LouversByCount";
        }
    }

    static override fromJS(data: any): LouversByCount {
        data = typeof data === 'object' ? data : {};
        let result = new LouversByCount();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["louver_count"] = this.louver_count;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A specific number of louvered Shades over a wall. */
export interface ILouversByCount extends I_LouversBase {
    /** A positive integer for the number of louvers to generate. */
    louver_count: number;
    type?: string;
}

/** Gridded skylights defined by an absolute area. */
export class GriddedSkylightArea extends _OpenAPIGenBaseModel implements IGriddedSkylightArea {
    /** A number for the skylight area in current model units. If this area is larger than the area of the roof that it is applied to, the skylight will fill the parent roof at a 99 percent ratio. */
    skylight_area!: number;
    readonly type: string = "GriddedSkylightArea";
    /** A number for the spacing between the centers of each grid cell. This should be less than a third of the dimension of the Roof geometry if multiple, evenly-spaced skylights are desired. If Autocalculate, a spacing of one third the smaller dimension of the parent Roof will be automatically assumed. */
    spacing?: Spacing;

    constructor(data?: IGriddedSkylightArea) {
        super(data);
        if (!data) {
            this.type = "GriddedSkylightArea";
        }
        this._discriminator = "GriddedSkylightArea";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.skylight_area = _data["skylight_area"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GriddedSkylightArea";
            this.spacing = _data["spacing"];
        }
    }

    static override fromJS(data: any): GriddedSkylightArea {
        data = typeof data === 'object' ? data : {};
        let result = new GriddedSkylightArea();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skylight_area"] = this.skylight_area;
        data["type"] = this.type;
        data["spacing"] = this.spacing;
        super.toJSON(data);
        return data;
    }
}

/** Gridded skylights defined by an absolute area. */
export interface IGriddedSkylightArea extends I_OpenAPIGenBaseModel {
    /** A number for the skylight area in current model units. If this area is larger than the area of the roof that it is applied to, the skylight will fill the parent roof at a 99 percent ratio. */
    skylight_area: number;
    type?: string;
    /** A number for the spacing between the centers of each grid cell. This should be less than a third of the dimension of the Roof geometry if multiple, evenly-spaced skylights are desired. If Autocalculate, a spacing of one third the smaller dimension of the parent Roof will be automatically assumed. */
    spacing?: Spacing;
}

/** Gridded skylights derived from an area ratio with the roof. */
export class GriddedSkylightRatio extends _OpenAPIGenBaseModel implements IGriddedSkylightRatio {
    /** A number between 0 and 1 for the ratio between the skylight area and the total Roof face area. */
    skylight_ratio!: number;
    readonly type: string = "GriddedSkylightRatio";
    /** A number for the spacing between the centers of each grid cell. This should be less than a third of the dimension of the Roof geometry if multiple, evenly-spaced skylights are desired. If Autocalculate, a spacing of one third the smaller dimension of the parent Roof will be automatically assumed. */
    spacing?: spacing;

    constructor(data?: IGriddedSkylightRatio) {
        super(data);
        if (!data) {
            this.type = "GriddedSkylightRatio";
        }
        this._discriminator = "GriddedSkylightRatio";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.skylight_ratio = _data["skylight_ratio"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "GriddedSkylightRatio";
            this.spacing = _data["spacing"];
        }
    }

    static override fromJS(data: any): GriddedSkylightRatio {
        data = typeof data === 'object' ? data : {};
        let result = new GriddedSkylightRatio();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skylight_ratio"] = this.skylight_ratio;
        data["type"] = this.type;
        data["spacing"] = this.spacing;
        super.toJSON(data);
        return data;
    }
}

/** Gridded skylights derived from an area ratio with the roof. */
export interface IGriddedSkylightRatio extends I_OpenAPIGenBaseModel {
    /** A number between 0 and 1 for the ratio between the skylight area and the total Roof face area. */
    skylight_ratio: number;
    type?: string;
    /** A number for the spacing between the centers of each grid cell. This should be less than a third of the dimension of the Roof geometry if multiple, evenly-spaced skylights are desired. If Autocalculate, a spacing of one third the smaller dimension of the parent Roof will be automatically assumed. */
    spacing?: spacing;
}

/** Several detailed skylights defined by 2D Polygons (lists of 2D vertices). */
export class DetailedSkylights extends _OpenAPIGenBaseModel implements IDetailedSkylights {
    /** An array of arrays with each sub-array representing a polygonal boundary of a skylight. Each sub-array should consist of arrays representing points, which contain 2 values for 2D coordinates in the world XY system. These coordinate values should lie within the parent Room2D Polygon. */
    polygons!: number[][][];
    readonly type: string = "DetailedSkylights";
    /** An array of booleans that align with the polygons and note whether each of the polygons represents an overhead door (True) or a skylight (False). If None, it will be assumed that all polygons represent skylights and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];

    constructor(data?: IDetailedSkylights) {
        super(data);
        if (!data) {
            this.polygons = [];
            this.type = "DetailedSkylights";
        }
        this._discriminator = "DetailedSkylights";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["polygons"])) {
                this.polygons = [] as any;
                for (let item of _data["polygons"])
                    this.polygons!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "DetailedSkylights";
            if (Array.isArray(_data["are_doors"])) {
                this.are_doors = [] as any;
                for (let item of _data["are_doors"])
                    this.are_doors!.push(item);
            }
        }
    }

    static override fromJS(data: any): DetailedSkylights {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedSkylights();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.polygons)) {
            data["polygons"] = [];
            for (let item of this.polygons)
                data["polygons"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.are_doors)) {
            data["are_doors"] = [];
            for (let item of this.are_doors)
                data["are_doors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Several detailed skylights defined by 2D Polygons (lists of 2D vertices). */
export interface IDetailedSkylights extends I_OpenAPIGenBaseModel {
    /** An array of arrays with each sub-array representing a polygonal boundary of a skylight. Each sub-array should consist of arrays representing points, which contain 2 values for 2D coordinates in the world XY system. These coordinate values should lie within the parent Room2D Polygon. */
    polygons: number[][][];
    type?: string;
    /** An array of booleans that align with the polygons and note whether each of the polygons represents an overhead door (True) or a skylight (False). If None, it will be assumed that all polygons represent skylights and they will be translated to Apertures in any resulting Honeybee model. */
    are_doors?: boolean[];
}

/** Instructions for a SensorGrid generated from a Room2D's floors. */
export class RoomGridParameter extends _GridParameterBase implements IRoomGridParameter {
    readonly type: string = "RoomGridParameter";
    /** A number for how far to offset the grid from the Room2D floors. (Default: 1.0, suitable for Models in Meters). */
    offset?: number;
    /** A number for the distance at which sensors close to walls should be removed. Note that this option has no effect unless the value is more than half of the dimension. */
    wall_offset?: number;

    constructor(data?: IRoomGridParameter) {
        super(data);
        if (!data) {
            this.type = "RoomGridParameter";
            this.offset = 1;
            this.wall_offset = 0;
        }
        this._discriminator = "RoomGridParameter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoomGridParameter";
            this.offset = _data["offset"] !== undefined ? _data["offset"] : 1;
            this.wall_offset = _data["wall_offset"] !== undefined ? _data["wall_offset"] : 0;
        }
    }

    static override fromJS(data: any): RoomGridParameter {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "RoomRadialGridParameter") {
            let result = new RoomRadialGridParameter();
            result.init(data);
            return result;
        }
        let result = new RoomGridParameter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["offset"] = this.offset;
        data["wall_offset"] = this.wall_offset;
        super.toJSON(data);
        return data;
    }
}

/** Instructions for a SensorGrid generated from a Room2D's floors. */
export interface IRoomGridParameter extends I_GridParameterBase {
    type?: string;
    /** A number for how far to offset the grid from the Room2D floors. (Default: 1.0, suitable for Models in Meters). */
    offset?: number;
    /** A number for the distance at which sensors close to walls should be removed. Note that this option has no effect unless the value is more than half of the dimension. */
    wall_offset?: number;
}

/** Instructions for a SensorGrid of radial directions around positions from floors. This type of sensor grid is particularly helpful for studies of multiple view directions, such as imageless glare studies. */
export class RoomRadialGridParameter extends RoomGridParameter implements IRoomRadialGridParameter {
    /** A positive integer for the number of radial directions to be generated around each position. */
    dir_count?: number;
    /** A vector as 3 (x, y, z) values to set the start direction of the generated directions. This can be used to orient the resulting sensors to specific parts of the scene. It can also change the elevation of the resulting directions since this start vector will always be rotated in the XY plane to generate the resulting directions. */
    start_vector?: number[];
    /** An optional number to override the radius of the meshes generated around each sensor. If Autocalculate, it will be equal to 45 percent of the grid dimension. */
    mesh_radius?: Mesh_radius;
    readonly type: string = "RoomRadialGridParameter";

    constructor(data?: IRoomRadialGridParameter) {
        super(data);
        if (!data) {
            this.dir_count = 8;
            this.type = "RoomRadialGridParameter";
        }
        this._discriminator = "RoomRadialGridParameter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dir_count = _data["dir_count"] !== undefined ? _data["dir_count"] : 8;
            if (Array.isArray(_data["start_vector"])) {
                this.start_vector = [] as any;
                for (let item of _data["start_vector"])
                    this.start_vector!.push(item);
            }
            this.mesh_radius = _data["mesh_radius"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoomRadialGridParameter";
        }
    }

    static override fromJS(data: any): RoomRadialGridParameter {
        data = typeof data === 'object' ? data : {};
        let result = new RoomRadialGridParameter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dir_count"] = this.dir_count;
        if (Array.isArray(this.start_vector)) {
            data["start_vector"] = [];
            for (let item of this.start_vector)
                data["start_vector"].push(item);
        }
        data["mesh_radius"] = this.mesh_radius;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Instructions for a SensorGrid of radial directions around positions from floors. This type of sensor grid is particularly helpful for studies of multiple view directions, such as imageless glare studies. */
export interface IRoomRadialGridParameter extends IRoomGridParameter {
    /** A positive integer for the number of radial directions to be generated around each position. */
    dir_count?: number;
    /** A vector as 3 (x, y, z) values to set the start direction of the generated directions. This can be used to orient the resulting sensors to specific parts of the scene. It can also change the elevation of the resulting directions since this start vector will always be rotated in the XY plane to generate the resulting directions. */
    start_vector?: number[];
    /** An optional number to override the radius of the meshes generated around each sensor. If Autocalculate, it will be equal to 45 percent of the grid dimension. */
    mesh_radius?: Mesh_radius;
    type?: string;
}

/** An enumeration. */
export enum ExteriorApertureType {
    Window = "Window",
    Skylight = "Skylight",
    All = "All",
}

/** Instructions for a SensorGrid generated from exterior Aperture. */
export class ExteriorApertureGridParameter extends _GridParameterBase implements IExteriorApertureGridParameter {
    readonly type: string = "ExteriorApertureGridParameter";
    /** A number for how far to offset the grid from the Apertures. (Default: 0.1, suitable for Models in Meters). */
    offset?: number;
    /** Text to specify the type of Aperture that will be used to generate grids. Window indicates Apertures in Walls. Skylights are in parent Roof faces. */
    aperture_type?: ExteriorApertureType;

    constructor(data?: IExteriorApertureGridParameter) {
        super(data);
        if (!data) {
            this.type = "ExteriorApertureGridParameter";
            this.offset = 0.1;
            this.aperture_type = ExteriorApertureType.All;
        }
        this._discriminator = "ExteriorApertureGridParameter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ExteriorApertureGridParameter";
            this.offset = _data["offset"] !== undefined ? _data["offset"] : 0.1;
            this.aperture_type = _data["aperture_type"] !== undefined ? _data["aperture_type"] : ExteriorApertureType.All;
        }
    }

    static override fromJS(data: any): ExteriorApertureGridParameter {
        data = typeof data === 'object' ? data : {};
        let result = new ExteriorApertureGridParameter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["offset"] = this.offset;
        data["aperture_type"] = this.aperture_type;
        super.toJSON(data);
        return data;
    }
}

/** Instructions for a SensorGrid generated from exterior Aperture. */
export interface IExteriorApertureGridParameter extends I_GridParameterBase {
    type?: string;
    /** A number for how far to offset the grid from the Apertures. (Default: 0.1, suitable for Models in Meters). */
    offset?: number;
    /** Text to specify the type of Aperture that will be used to generate grids. Window indicates Apertures in Walls. Skylights are in parent Roof faces. */
    aperture_type?: ExteriorApertureType;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Room2DRadiancePropertiesAbridged extends _OpenAPIGenBaseModel implements IRoom2DRadiancePropertiesAbridged {
    readonly type: string = "Room2DRadiancePropertiesAbridged";
    /** Identifier of a ModifierSet to specify all modifiers for the Room2D. If None, the Room2D will use the Story or Building modifier_set or the Model global_modifier_set. Any ModifierSet assigned here will override those assigned to the parent objects. */
    modifier_set?: string;
    /** An optional list of GridParameter objects to describe how sensor grids should be generated for the Room2D. */
    grid_parameters?: Grid_parameters[];

    constructor(data?: IRoom2DRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "Room2DRadiancePropertiesAbridged";
        }
        this._discriminator = "Room2DRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Room2DRadiancePropertiesAbridged";
            this.modifier_set = _data["modifier_set"];
            if (Array.isArray(_data["grid_parameters"])) {
                this.grid_parameters = [] as any;
                for (let item of _data["grid_parameters"])
                    this.grid_parameters!.push(item);
            }
        }
    }

    static override fromJS(data: any): Room2DRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new Room2DRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier_set"] = this.modifier_set;
        if (Array.isArray(this.grid_parameters)) {
            data["grid_parameters"] = [];
            for (let item of this.grid_parameters)
                data["grid_parameters"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IRoom2DRadiancePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Identifier of a ModifierSet to specify all modifiers for the Room2D. If None, the Room2D will use the Story or Building modifier_set or the Model global_modifier_set. Any ModifierSet assigned here will override those assigned to the parent objects. */
    modifier_set?: string;
    /** An optional list of GridParameter objects to describe how sensor grids should be generated for the Room2D. */
    grid_parameters?: Grid_parameters[];
}

export class Room2DPropertiesAbridged extends _OpenAPIGenBaseModel implements IRoom2DPropertiesAbridged {
    readonly type: string = "Room2DPropertiesAbridged";
    energy?: Room2DEnergyPropertiesAbridged;
    radiance?: Room2DRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IRoom2DPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "Room2DPropertiesAbridged";
        }
        this._discriminator = "Room2DPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Room2DPropertiesAbridged";
            this.energy = _data["energy"] ? Room2DEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? Room2DRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Room2DPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new Room2DPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoom2DPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: Room2DEnergyPropertiesAbridged;
    radiance?: Room2DRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Room2D extends IDdBaseModel implements IRoom2D {
    /** A list of 2D points representing the outer boundary vertices of the Room2D. The list should include at least 3 points and each point should be a list of 2 (x, y) values. */
    floor_boundary!: number[][];
    /** A number to indicate the height of the floor plane in the Z axis. */
    floor_height!: number;
    /** A number for the distance between the floor and the ceiling. */
    floor_to_ceiling_height!: number;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: Room2DPropertiesAbridged;
    readonly type: string = "Room2D";
    /** Optional list of lists with one list for each hole in the floor plate. Each hole should be a list of at least 2 points and each point a list of 2 (x, y) values. If None, it will be assumed that there are no holes in the floor plate. */
    floor_holes?: number[][][];
    /** A boolean noting whether this Room2D has its floor in contact with the ground. */
    is_ground_contact?: boolean;
    /** A boolean noting whether this Room2D has its ceiling exposed to the outdoors. */
    is_top_exposed?: boolean;
    /** A list of boundary conditions that match the number of segments in the input floor_geometry + floor_holes. These will be used to assign boundary conditions to each of the walls of the Room in the resulting model. Their order should align with the order of segments in the floor_boundary and then with each hole segment. If None, all boundary conditions will be Outdoors or Ground depending on whether ceiling height of the room is at or below 0 (the assumed ground plane). */
    boundary_conditions?: Boundary_conditions[];
    /** A list of WindowParameter objects that dictate how the window geometries will be generated for each of the walls. If None, no windows will exist over the entire Room2D. */
    window_parameters?: Window_parameters[];
    /** A list of ShadingParameter objects that dictate how the shade geometries will be generated for each of the walls. If None, no shades will exist over the entire Room2D. */
    shading_parameters?: Shading_parameters[];
    /** A list of booleans for whether each wall has an air boundary type. False values indicate a standard opaque type while True values indicate an AirBoundary type. All walls will be False by default. Note that any walls with a True air boundary must have a Surface boundary condition without any windows. */
    air_boundaries?: boolean[];
    /** A SkylightParameter object describing how to generate skylights. If None, no skylights will exist on the Room2D. */
    skylight_parameters?: Skylight_parameters;

    constructor(data?: IRoom2D) {
        super(data);
        if (!data) {
            this.floor_boundary = [];
            this.properties = new Room2DPropertiesAbridged();
            this.type = "Room2D";
            this.is_ground_contact = false;
            this.is_top_exposed = false;
        }
        this._discriminator = "Room2D";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["floor_boundary"])) {
                this.floor_boundary = [] as any;
                for (let item of _data["floor_boundary"])
                    this.floor_boundary!.push(item);
            }
            this.floor_height = _data["floor_height"];
            this.floor_to_ceiling_height = _data["floor_to_ceiling_height"];
            this.properties = _data["properties"] ? Room2DPropertiesAbridged.fromJS(_data["properties"]) : new Room2DPropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Room2D";
            if (Array.isArray(_data["floor_holes"])) {
                this.floor_holes = [] as any;
                for (let item of _data["floor_holes"])
                    this.floor_holes!.push(item);
            }
            this.is_ground_contact = _data["is_ground_contact"] !== undefined ? _data["is_ground_contact"] : false;
            this.is_top_exposed = _data["is_top_exposed"] !== undefined ? _data["is_top_exposed"] : false;
            if (Array.isArray(_data["boundary_conditions"])) {
                this.boundary_conditions = [] as any;
                for (let item of _data["boundary_conditions"])
                    this.boundary_conditions!.push(item);
            }
            if (Array.isArray(_data["window_parameters"])) {
                this.window_parameters = [] as any;
                for (let item of _data["window_parameters"])
                    this.window_parameters!.push(item);
            }
            if (Array.isArray(_data["shading_parameters"])) {
                this.shading_parameters = [] as any;
                for (let item of _data["shading_parameters"])
                    this.shading_parameters!.push(item);
            }
            if (Array.isArray(_data["air_boundaries"])) {
                this.air_boundaries = [] as any;
                for (let item of _data["air_boundaries"])
                    this.air_boundaries!.push(item);
            }
            this.skylight_parameters = _data["skylight_parameters"];
        }
    }

    static override fromJS(data: any): Room2D {
        data = typeof data === 'object' ? data : {};
        let result = new Room2D();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.floor_boundary)) {
            data["floor_boundary"] = [];
            for (let item of this.floor_boundary)
                data["floor_boundary"].push(item);
        }
        data["floor_height"] = this.floor_height;
        data["floor_to_ceiling_height"] = this.floor_to_ceiling_height;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.floor_holes)) {
            data["floor_holes"] = [];
            for (let item of this.floor_holes)
                data["floor_holes"].push(item);
        }
        data["is_ground_contact"] = this.is_ground_contact;
        data["is_top_exposed"] = this.is_top_exposed;
        if (Array.isArray(this.boundary_conditions)) {
            data["boundary_conditions"] = [];
            for (let item of this.boundary_conditions)
                data["boundary_conditions"].push(item);
        }
        if (Array.isArray(this.window_parameters)) {
            data["window_parameters"] = [];
            for (let item of this.window_parameters)
                data["window_parameters"].push(item);
        }
        if (Array.isArray(this.shading_parameters)) {
            data["shading_parameters"] = [];
            for (let item of this.shading_parameters)
                data["shading_parameters"].push(item);
        }
        if (Array.isArray(this.air_boundaries)) {
            data["air_boundaries"] = [];
            for (let item of this.air_boundaries)
                data["air_boundaries"].push(item);
        }
        data["skylight_parameters"] = this.skylight_parameters;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IRoom2D extends IIDdBaseModel {
    /** A list of 2D points representing the outer boundary vertices of the Room2D. The list should include at least 3 points and each point should be a list of 2 (x, y) values. */
    floor_boundary: number[][];
    /** A number to indicate the height of the floor plane in the Z axis. */
    floor_height: number;
    /** A number for the distance between the floor and the ceiling. */
    floor_to_ceiling_height: number;
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: Room2DPropertiesAbridged;
    type?: string;
    /** Optional list of lists with one list for each hole in the floor plate. Each hole should be a list of at least 2 points and each point a list of 2 (x, y) values. If None, it will be assumed that there are no holes in the floor plate. */
    floor_holes?: number[][][];
    /** A boolean noting whether this Room2D has its floor in contact with the ground. */
    is_ground_contact?: boolean;
    /** A boolean noting whether this Room2D has its ceiling exposed to the outdoors. */
    is_top_exposed?: boolean;
    /** A list of boundary conditions that match the number of segments in the input floor_geometry + floor_holes. These will be used to assign boundary conditions to each of the walls of the Room in the resulting model. Their order should align with the order of segments in the floor_boundary and then with each hole segment. If None, all boundary conditions will be Outdoors or Ground depending on whether ceiling height of the room is at or below 0 (the assumed ground plane). */
    boundary_conditions?: Boundary_conditions[];
    /** A list of WindowParameter objects that dictate how the window geometries will be generated for each of the walls. If None, no windows will exist over the entire Room2D. */
    window_parameters?: Window_parameters[];
    /** A list of ShadingParameter objects that dictate how the shade geometries will be generated for each of the walls. If None, no shades will exist over the entire Room2D. */
    shading_parameters?: Shading_parameters[];
    /** A list of booleans for whether each wall has an air boundary type. False values indicate a standard opaque type while True values indicate an AirBoundary type. All walls will be False by default. Note that any walls with a True air boundary must have a Surface boundary condition without any windows. */
    air_boundaries?: boolean[];
    /** A SkylightParameter object describing how to generate skylights. If None, no skylights will exist on the Room2D. */
    skylight_parameters?: Skylight_parameters;
}

/** Geometry for specifying sloped roofs over a Story. */
export class RoofSpecification extends _OpenAPIGenBaseModel implements IRoofSpecification {
    /** An array of Face3D objects representing the geometry of the Roof. None of these geometries should overlap in plan and, together, these Face3D should either completely cover or skip each Room2D of the Story to which the RoofSpecification is assigned. */
    geometry!: Face3D[];
    readonly type: string = "RoofSpecification";

    constructor(data?: IRoofSpecification) {
        super(data);
        if (!data) {
            this.geometry = [];
            this.type = "RoofSpecification";
        }
        this._discriminator = "RoofSpecification";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["geometry"])) {
                this.geometry = [] as any;
                for (let item of _data["geometry"])
                    this.geometry!.push(Face3D.fromJS(item));
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "RoofSpecification";
        }
    }

    static override fromJS(data: any): RoofSpecification {
        data = typeof data === 'object' ? data : {};
        let result = new RoofSpecification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geometry)) {
            data["geometry"] = [];
            for (let item of this.geometry)
                data["geometry"].push(item.toJSON());
        }
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Geometry for specifying sloped roofs over a Story. */
export interface IRoofSpecification extends I_OpenAPIGenBaseModel {
    /** An array of Face3D objects representing the geometry of the Roof. None of these geometries should overlap in plan and, together, these Face3D should either completely cover or skip each Room2D of the Story to which the RoofSpecification is assigned. */
    geometry: Face3D[];
    type?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class StoryEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IStoryEnergyPropertiesAbridged {
    readonly type: string = "StoryEnergyPropertiesAbridged";
    /** Name of a ConstructionSet to specify all constructions for the Story. If None, the Story will use the Building construction_set or the Model global_construction_set. Any ConstructionSet assigned here will override those assigned to these objects. */
    construction_set?: string;

    constructor(data?: IStoryEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "StoryEnergyPropertiesAbridged";
        }
        this._discriminator = "StoryEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "StoryEnergyPropertiesAbridged";
            this.construction_set = _data["construction_set"];
        }
    }

    static override fromJS(data: any): StoryEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new StoryEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction_set"] = this.construction_set;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IStoryEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ConstructionSet to specify all constructions for the Story. If None, the Story will use the Building construction_set or the Model global_construction_set. Any ConstructionSet assigned here will override those assigned to these objects. */
    construction_set?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class StoryRadiancePropertiesAbridged extends _OpenAPIGenBaseModel implements IStoryRadiancePropertiesAbridged {
    readonly type: string = "StoryRadiancePropertiesAbridged";
    /** Name of a ModifierSet to specify all modifiers for the Story. If None, the Story will use the Building modifier_set or the Model global_modifier_set. Any ModifierSet assigned here will override those assigned to the parent objects. */
    modifier_set?: string;

    constructor(data?: IStoryRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "StoryRadiancePropertiesAbridged";
        }
        this._discriminator = "StoryRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "StoryRadiancePropertiesAbridged";
            this.modifier_set = _data["modifier_set"];
        }
    }

    static override fromJS(data: any): StoryRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new StoryRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier_set"] = this.modifier_set;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IStoryRadiancePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ModifierSet to specify all modifiers for the Story. If None, the Story will use the Building modifier_set or the Model global_modifier_set. Any ModifierSet assigned here will override those assigned to the parent objects. */
    modifier_set?: string;
}

export class StoryPropertiesAbridged extends _OpenAPIGenBaseModel implements IStoryPropertiesAbridged {
    readonly type: string = "StoryPropertiesAbridged";
    energy?: StoryEnergyPropertiesAbridged;
    radiance?: StoryRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IStoryPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "StoryPropertiesAbridged";
        }
        this._discriminator = "StoryPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "StoryPropertiesAbridged";
            this.energy = _data["energy"] ? StoryEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? StoryRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): StoryPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new StoryPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IStoryPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: StoryEnergyPropertiesAbridged;
    radiance?: StoryRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Story extends IDdBaseModel implements IStory {
    /** An array of dragonfly Room2D objects that together form an entire story of a building. */
    room_2ds!: Room2D[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: StoryPropertiesAbridged;
    readonly type: string = "Story";
    /** A number for the distance from the floor plate of this story to the floor of the story above this one (if it exists). If Autocalculate, this value will be the maximum floor_to_ceiling_height of the input room_2ds. */
    floor_to_floor_height?: Floor_to_floor_height;
    /** A number to indicate the height of the floor plane in the Z axis.If Autocalculate, this will be the minimum floor height of all the room_2ds, which is suitable for cases where there are no floor plenums. */
    floor_height?: Floor_height;
    /** An integer that denotes the number of times that this Story is repeated over the height of the building. */
    multiplier?: number;
    /** An optional RoofSpecification object containing geometry for generating sloped roofs over the Story. The RoofSpecification will only affect the child Room2Ds that have a True is_top_exposed property and it will only be utilized in translation to Honeybee when the Story multiplier is 1. If None, all Room2D ceilings will be flat. */
    roof?: RoofSpecification;

    constructor(data?: IStory) {
        super(data);
        if (!data) {
            this.room_2ds = [];
            this.properties = new StoryPropertiesAbridged();
            this.type = "Story";
            this.multiplier = 1;
        }
        this._discriminator = "Story";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["room_2ds"])) {
                this.room_2ds = [] as any;
                for (let item of _data["room_2ds"])
                    this.room_2ds!.push(Room2D.fromJS(item));
            }
            this.properties = _data["properties"] ? StoryPropertiesAbridged.fromJS(_data["properties"]) : new StoryPropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Story";
            this.floor_to_floor_height = _data["floor_to_floor_height"];
            this.floor_height = _data["floor_height"];
            this.multiplier = _data["multiplier"] !== undefined ? _data["multiplier"] : 1;
            this.roof = _data["roof"] ? RoofSpecification.fromJS(_data["roof"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Story {
        data = typeof data === 'object' ? data : {};
        let result = new Story();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.room_2ds)) {
            data["room_2ds"] = [];
            for (let item of this.room_2ds)
                data["room_2ds"].push(item.toJSON());
        }
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["floor_to_floor_height"] = this.floor_to_floor_height;
        data["floor_height"] = this.floor_height;
        data["multiplier"] = this.multiplier;
        data["roof"] = this.roof ? this.roof.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IStory extends IIDdBaseModel {
    /** An array of dragonfly Room2D objects that together form an entire story of a building. */
    room_2ds: Room2D[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: StoryPropertiesAbridged;
    type?: string;
    /** A number for the distance from the floor plate of this story to the floor of the story above this one (if it exists). If Autocalculate, this value will be the maximum floor_to_ceiling_height of the input room_2ds. */
    floor_to_floor_height?: Floor_to_floor_height;
    /** A number to indicate the height of the floor plane in the Z axis.If Autocalculate, this will be the minimum floor height of all the room_2ds, which is suitable for cases where there are no floor plenums. */
    floor_height?: Floor_height;
    /** An integer that denotes the number of times that this Story is repeated over the height of the building. */
    multiplier?: number;
    /** An optional RoofSpecification object containing geometry for generating sloped roofs over the Story. The RoofSpecification will only affect the child Room2Ds that have a True is_top_exposed property and it will only be utilized in translation to Honeybee when the Story multiplier is 1. If None, all Room2D ceilings will be flat. */
    roof?: RoofSpecification;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class BuildingEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IBuildingEnergyPropertiesAbridged {
    readonly type: string = "BuildingEnergyPropertiesAbridged";
    /** Name of a ConstructionSet to specify all constructions for the Building. If None, the Model global_construction_set will be used. */
    construction_set?: string;

    constructor(data?: IBuildingEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "BuildingEnergyPropertiesAbridged";
        }
        this._discriminator = "BuildingEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BuildingEnergyPropertiesAbridged";
            this.construction_set = _data["construction_set"];
        }
    }

    static override fromJS(data: any): BuildingEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction_set"] = this.construction_set;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IBuildingEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ConstructionSet to specify all constructions for the Building. If None, the Model global_construction_set will be used. */
    construction_set?: string;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class BuildingRadiancePropertiesAbridged extends _OpenAPIGenBaseModel implements IBuildingRadiancePropertiesAbridged {
    readonly type: string = "BuildingRadiancePropertiesAbridged";
    /** Name of a ModifierSet to specify all modifiers for the Building. If None, the Model global_modifier_set will be used. */
    modifier_set?: string;

    constructor(data?: IBuildingRadiancePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "BuildingRadiancePropertiesAbridged";
        }
        this._discriminator = "BuildingRadiancePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BuildingRadiancePropertiesAbridged";
            this.modifier_set = _data["modifier_set"];
        }
    }

    static override fromJS(data: any): BuildingRadiancePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingRadiancePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["modifier_set"] = this.modifier_set;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IBuildingRadiancePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ModifierSet to specify all modifiers for the Building. If None, the Model global_modifier_set will be used. */
    modifier_set?: string;
}

export class BuildingPropertiesAbridged extends _OpenAPIGenBaseModel implements IBuildingPropertiesAbridged {
    readonly type: string = "BuildingPropertiesAbridged";
    energy?: BuildingEnergyPropertiesAbridged;
    radiance?: BuildingRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IBuildingPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "BuildingPropertiesAbridged";
        }
        this._discriminator = "BuildingPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BuildingPropertiesAbridged";
            this.energy = _data["energy"] ? BuildingEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? BuildingRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BuildingPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBuildingPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: BuildingEnergyPropertiesAbridged;
    radiance?: BuildingRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Building extends IDdBaseModel implements IBuilding {
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: BuildingPropertiesAbridged;
    readonly type: string = "Building";
    /** An array of unique dragonfly Story objects that together form the entire building. Stories should generally be ordered from lowest floor to highest floor, though this is not required. Note that, if a given Story is repeated several times over the height of the building and this is represented by the multiplier, the unique story included in this list should be the first (lowest) story of the repeated floors. */
    unique_stories?: Story[];
    /** An optional array of 3D Honeybee Room objects for additional Rooms that are a part of the Building but are not represented within the unique_stories. This is useful when there are parts of the Building geometry that cannot easily be represented with the extruded floor plate and sloped roof assumptions that underlie Dragonfly Room2Ds and RoofSpecification. Cases where this input is most useful include sloped walls and certain types of domed roofs that become tedious to implement with RoofSpecification. Matching the Honeybee Room.story property to the Dragonfly Story.display_name of an object within the unique_stories will effectively place the Honeybee Room on that Story for the purposes of floor_area, exterior_wall_area, etc. However, note that the Honeybee Room.multiplier property takes precedence over whatever multiplier is assigned to the Dragonfly Story that the Room.story may reference. (Default: None). */
    room_3ds?: Room[];

    constructor(data?: IBuilding) {
        super(data);
        if (!data) {
            this.properties = new BuildingPropertiesAbridged();
            this.type = "Building";
        }
        this._discriminator = "Building";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.properties = _data["properties"] ? BuildingPropertiesAbridged.fromJS(_data["properties"]) : new BuildingPropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Building";
            if (Array.isArray(_data["unique_stories"])) {
                this.unique_stories = [] as any;
                for (let item of _data["unique_stories"])
                    this.unique_stories!.push(Story.fromJS(item));
            }
            if (Array.isArray(_data["room_3ds"])) {
                this.room_3ds = [] as any;
                for (let item of _data["room_3ds"])
                    this.room_3ds!.push(Room.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Building {
        data = typeof data === 'object' ? data : {};
        let result = new Building();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.unique_stories)) {
            data["unique_stories"] = [];
            for (let item of this.unique_stories)
                data["unique_stories"].push(item.toJSON());
        }
        if (Array.isArray(this.room_3ds)) {
            data["room_3ds"] = [];
            for (let item of this.room_3ds)
                data["room_3ds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IBuilding extends IIDdBaseModel {
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: BuildingPropertiesAbridged;
    type?: string;
    /** An array of unique dragonfly Story objects that together form the entire building. Stories should generally be ordered from lowest floor to highest floor, though this is not required. Note that, if a given Story is repeated several times over the height of the building and this is represented by the multiplier, the unique story included in this list should be the first (lowest) story of the repeated floors. */
    unique_stories?: Story[];
    /** An optional array of 3D Honeybee Room objects for additional Rooms that are a part of the Building but are not represented within the unique_stories. This is useful when there are parts of the Building geometry that cannot easily be represented with the extruded floor plate and sloped roof assumptions that underlie Dragonfly Room2Ds and RoofSpecification. Cases where this input is most useful include sloped walls and certain types of domed roofs that become tedious to implement with RoofSpecification. Matching the Honeybee Room.story property to the Dragonfly Story.display_name of an object within the unique_stories will effectively place the Honeybee Room on that Story for the purposes of floor_area, exterior_wall_area, etc. However, note that the Honeybee Room.multiplier property takes precedence over whatever multiplier is assigned to the Dragonfly Story that the Room.story may reference. (Default: None). */
    room_3ds?: Room[];
}

/** A RGB color. */
export class Color extends _OpenAPIGenBaseModel implements IColor {
    /** Value for red channel. */
    r!: number;
    /** Value for green channel. */
    g!: number;
    /** Value for blue channel. */
    b!: number;
    readonly type: string = "Color";
    /** Value for the alpha channel, which defines the opacity as a number between 0 (fully transparent) and 255 (fully opaque). */
    a?: number;

    constructor(data?: IColor) {
        super(data);
        if (!data) {
            this.type = "Color";
            this.a = 255;
        }
        this._discriminator = "Color";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.r = _data["r"];
            this.g = _data["g"];
            this.b = _data["b"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Color";
            this.a = _data["a"] !== undefined ? _data["a"] : 255;
        }
    }

    static override fromJS(data: any): Color {
        data = typeof data === 'object' ? data : {};
        let result = new Color();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["r"] = this.r;
        data["g"] = this.g;
        data["b"] = this.b;
        data["type"] = this.type;
        data["a"] = this.a;
        super.toJSON(data);
        return data;
    }
}

/** A RGB color. */
export interface IColor extends I_OpenAPIGenBaseModel {
    /** Value for red channel. */
    r: number;
    /** Value for green channel. */
    g: number;
    /** Value for blue channel. */
    b: number;
    type?: string;
    /** Value for the alpha channel, which defines the opacity as a number between 0 (fully transparent) and 255 (fully opaque). */
    a?: number;
}

/** A mesh in 3D space. */
export class Mesh3D extends _OpenAPIGenBaseModel implements IMesh3D {
    /** A list of points representing the vertices of the mesh. The list should include at least 3 points and each point should be a list of 3 (x, y, z) values. */
    vertices!: number[][];
    /** A list of lists with each sub-list having either 3 or 4 integers. These integers correspond to indices within the list of vertices. */
    faces!: number[][];
    readonly type: string = "Mesh3D";
    /** An optional list of colors that correspond to either the faces of the mesh or the vertices of the mesh. */
    colors?: Color[];

    constructor(data?: IMesh3D) {
        super(data);
        if (!data) {
            this.vertices = [];
            this.faces = [];
            this.type = "Mesh3D";
        }
        this._discriminator = "Mesh3D";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["vertices"])) {
                this.vertices = [] as any;
                for (let item of _data["vertices"])
                    this.vertices!.push(item);
            }
            if (Array.isArray(_data["faces"])) {
                this.faces = [] as any;
                for (let item of _data["faces"])
                    this.faces!.push(item);
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Mesh3D";
            if (Array.isArray(_data["colors"])) {
                this.colors = [] as any;
                for (let item of _data["colors"])
                    this.colors!.push(Color.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Mesh3D {
        data = typeof data === 'object' ? data : {};
        let result = new Mesh3D();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vertices)) {
            data["vertices"] = [];
            for (let item of this.vertices)
                data["vertices"].push(item);
        }
        if (Array.isArray(this.faces)) {
            data["faces"] = [];
            for (let item of this.faces)
                data["faces"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.colors)) {
            data["colors"] = [];
            for (let item of this.colors)
                data["colors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A mesh in 3D space. */
export interface IMesh3D extends I_OpenAPIGenBaseModel {
    /** A list of points representing the vertices of the mesh. The list should include at least 3 points and each point should be a list of 3 (x, y, z) values. */
    vertices: number[][];
    /** A list of lists with each sub-list having either 3 or 4 integers. These integers correspond to indices within the list of vertices. */
    faces: number[][];
    type?: string;
    /** An optional list of colors that correspond to either the faces of the mesh or the vertices of the mesh. */
    colors?: Color[];
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class ContextShadeEnergyPropertiesAbridged extends _OpenAPIGenBaseModel implements IContextShadeEnergyPropertiesAbridged {
    readonly type: string = "ContextShadeEnergyPropertiesAbridged";
    /** Name of a ShadeConstruction to set the reflectance and specularity of the ContextShade. If None, the the EnergyPlus default of 0.2 diffuse reflectance will be used. */
    construction?: string;
    /** Name of a schedule to set the transmittance of the ContextShade, which can vary throughout the simulation. If None, the ContextShade will be completely opaque. */
    transmittance_schedule?: string;

    constructor(data?: IContextShadeEnergyPropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ContextShadeEnergyPropertiesAbridged";
        }
        this._discriminator = "ContextShadeEnergyPropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ContextShadeEnergyPropertiesAbridged";
            this.construction = _data["construction"];
            this.transmittance_schedule = _data["transmittance_schedule"];
        }
    }

    static override fromJS(data: any): ContextShadeEnergyPropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ContextShadeEnergyPropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["construction"] = this.construction;
        data["transmittance_schedule"] = this.transmittance_schedule;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IContextShadeEnergyPropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of a ShadeConstruction to set the reflectance and specularity of the ContextShade. If None, the the EnergyPlus default of 0.2 diffuse reflectance will be used. */
    construction?: string;
    /** Name of a schedule to set the transmittance of the ContextShade, which can vary throughout the simulation. If None, the ContextShade will be completely opaque. */
    transmittance_schedule?: string;
}

export class ContextShadePropertiesAbridged extends _OpenAPIGenBaseModel implements IContextShadePropertiesAbridged {
    readonly type: string = "ContextShadePropertiesAbridged";
    energy?: ContextShadeEnergyPropertiesAbridged;
    radiance?: ContextShadeRadiancePropertiesAbridged;

    [key: string]: any;

    constructor(data?: IContextShadePropertiesAbridged) {
        super(data);
        if (!data) {
            this.type = "ContextShadePropertiesAbridged";
        }
        this._discriminator = "ContextShadePropertiesAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ContextShadePropertiesAbridged";
            this.energy = _data["energy"] ? ContextShadeEnergyPropertiesAbridged.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? ContextShadeRadiancePropertiesAbridged.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ContextShadePropertiesAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new ContextShadePropertiesAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IContextShadePropertiesAbridged extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: ContextShadeEnergyPropertiesAbridged;
    radiance?: ContextShadeRadiancePropertiesAbridged;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class ContextShade extends IDdBaseModel implements IContextShade {
    /** An array of planar Face3Ds and or Mesh3Ds that together represent the context shade. */
    geometry!: Geometry[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: ContextShadePropertiesAbridged;
    readonly type: string = "ContextShade";
    /** Boolean to note whether this shade is detached from any of the other geometry in the model. Cases where this should be True include shade representing surrounding buildings or context. */
    is_detached?: boolean;

    constructor(data?: IContextShade) {
        super(data);
        if (!data) {
            this.geometry = [];
            this.properties = new ContextShadePropertiesAbridged();
            this.type = "ContextShade";
            this.is_detached = true;
        }
        this._discriminator = "ContextShade";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["geometry"])) {
                this.geometry = [] as any;
                for (let item of _data["geometry"])
                    this.geometry!.push(item);
            }
            this.properties = _data["properties"] ? ContextShadePropertiesAbridged.fromJS(_data["properties"]) : new ContextShadePropertiesAbridged();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ContextShade";
            this.is_detached = _data["is_detached"] !== undefined ? _data["is_detached"] : true;
        }
    }

    static override fromJS(data: any): ContextShade {
        data = typeof data === 'object' ? data : {};
        let result = new ContextShade();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geometry)) {
            data["geometry"] = [];
            for (let item of this.geometry)
                data["geometry"].push(item);
        }
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["is_detached"] = this.is_detached;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IContextShade extends IIDdBaseModel {
    /** An array of planar Face3Ds and or Mesh3Ds that together represent the context shade. */
    geometry: Geometry[];
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: ContextShadePropertiesAbridged;
    type?: string;
    /** Boolean to note whether this shade is detached from any of the other geometry in the model. Cases where this should be True include shade representing surrounding buildings or context. */
    is_detached?: boolean;
}

/** An enumeration. */
export enum Units {
    Meters = "Meters",
    Millimeters = "Millimeters",
    Feet = "Feet",
    Inches = "Inches",
    Centimeters = "Centimeters",
}

export class ModelProperties extends _OpenAPIGenBaseModel implements IModelProperties {
    readonly type: string = "ModelProperties";
    energy?: ModelEnergyProperties;
    radiance?: ModelRadianceProperties;

    [key: string]: any;

    constructor(data?: IModelProperties) {
        super(data);
        if (!data) {
            this.type = "ModelProperties";
        }
        this._discriminator = "ModelProperties";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ModelProperties";
            this.energy = _data["energy"] ? ModelEnergyProperties.fromJS(_data["energy"]) : <any>undefined;
            this.radiance = _data["radiance"] ? ModelRadianceProperties.fromJS(_data["radiance"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ModelProperties {
        data = typeof data === 'object' ? data : {};
        let result = new ModelProperties();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["energy"] = this.energy ? this.energy.toJSON() : <any>undefined;
        data["radiance"] = this.radiance ? this.radiance.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IModelProperties extends I_OpenAPIGenBaseModel {
    type?: string;
    energy?: ModelEnergyProperties;
    radiance?: ModelRadianceProperties;

    [key: string]: any;
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export class Model extends IDdBaseModel implements IModel {
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties!: ModelProperties;
    readonly type: string = "Model";
    /** Text string for the current version of the schema. */
    version?: string;
    /** A list of Buildings in the model. */
    buildings?: Building[];
    /** A list of ContextShades in the model. */
    context_shades?: ContextShade[];
    /** Text indicating the units in which the model geometry exists. This is used to scale the geometry to the correct units for simulation engines like EnergyPlus, which requires all geometry be in meters. */
    units?: Units;
    /** The maximum difference between x, y, and z values at which vertices are considered equivalent. This value should be in the Model units and is used in a variety of checks and operations. A value of 0 will result in bypassing all checks so it is recommended that this always be a positive number when checks have not already been performed on a Model. The default of 0.01 is suitable for models in meters. */
    tolerance?: number;
    /** The max angle difference in degrees that vertices are allowed to differ from one another in order to consider them colinear. This value is used in a variety of checks and operations that can be performed on geometry. A value of 0 will result in no checks and an inability to perform certain operations so it is recommended that this always be a positive number when checks have not already been performed on a given Model. */
    angle_tolerance?: number;

    constructor(data?: IModel) {
        super(data);
        if (!data) {
            this.properties = new ModelProperties();
            this.type = "Model";
            this.version = "0.0.0";
            this.units = Units.Meters;
            this.tolerance = 0.01;
            this.angle_tolerance = 1;
        }
        this._discriminator = "Model";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.properties = _data["properties"] ? ModelProperties.fromJS(_data["properties"]) : new ModelProperties();
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Model";
            this.version = _data["version"] !== undefined ? _data["version"] : "0.0.0";
            if (Array.isArray(_data["buildings"])) {
                this.buildings = [] as any;
                for (let item of _data["buildings"])
                    this.buildings!.push(Building.fromJS(item));
            }
            if (Array.isArray(_data["context_shades"])) {
                this.context_shades = [] as any;
                for (let item of _data["context_shades"])
                    this.context_shades!.push(ContextShade.fromJS(item));
            }
            this.units = _data["units"] !== undefined ? _data["units"] : Units.Meters;
            this.tolerance = _data["tolerance"] !== undefined ? _data["tolerance"] : 0.01;
            this.angle_tolerance = _data["angle_tolerance"] !== undefined ? _data["angle_tolerance"] : 1;
        }
    }

    static override fromJS(data: any): Model {
        data = typeof data === 'object' ? data : {};
        let result = new Model();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["version"] = this.version;
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        if (Array.isArray(this.context_shades)) {
            data["context_shades"] = [];
            for (let item of this.context_shades)
                data["context_shades"].push(item.toJSON());
        }
        data["units"] = this.units;
        data["tolerance"] = this.tolerance;
        data["angle_tolerance"] = this.angle_tolerance;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects requiring a identifiers acceptable for all engines. */
export interface IModel extends IIDdBaseModel {
    /** Extension properties for particular simulation engines (Radiance, EnergyPlus). */
    properties: ModelProperties;
    type?: string;
    /** Text string for the current version of the schema. */
    version?: string;
    /** A list of Buildings in the model. */
    buildings?: Building[];
    /** A list of ContextShades in the model. */
    context_shades?: ContextShade[];
    /** Text indicating the units in which the model geometry exists. This is used to scale the geometry to the correct units for simulation engines like EnergyPlus, which requires all geometry be in meters. */
    units?: Units;
    /** The maximum difference between x, y, and z values at which vertices are considered equivalent. This value should be in the Model units and is used in a variety of checks and operations. A value of 0 will result in bypassing all checks so it is recommended that this always be a positive number when checks have not already been performed on a Model. The default of 0.01 is suitable for models in meters. */
    tolerance?: number;
    /** The max angle difference in degrees that vertices are allowed to differ from one another in order to consider them colinear. This value is used in a variety of checks and operations that can be performed on geometry. A value of 0 will result in no checks and an inability to perform certain operations so it is recommended that this always be a positive number when checks have not already been performed on a given Model. */
    angle_tolerance?: number;
}

/** A set of constructions for wall, floor, or roof assemblies. */
export class _FaceSubSet extends _OpenAPIGenBaseModel implements I_FaceSubSet {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    readonly type: string = "_FaceSubSet";

    constructor(data?: I_FaceSubSet) {
        super(data);
        if (!data) {
            this.type = "_FaceSubSet";
        }
        this._discriminator = "_FaceSubSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interior_construction = _data["interior_construction"] ? OpaqueConstruction.fromJS(_data["interior_construction"]) : <any>undefined;
            this.exterior_construction = _data["exterior_construction"] ? OpaqueConstruction.fromJS(_data["exterior_construction"]) : <any>undefined;
            this.ground_construction = _data["ground_construction"] ? OpaqueConstruction.fromJS(_data["ground_construction"]) : <any>undefined;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_FaceSubSet";
        }
    }

    static override fromJS(data: any): _FaceSubSet {
        data = typeof data === 'object' ? data : {};
        let result = new _FaceSubSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interior_construction"] = this.interior_construction ? this.interior_construction.toJSON() : <any>undefined;
        data["exterior_construction"] = this.exterior_construction ? this.exterior_construction.toJSON() : <any>undefined;
        data["ground_construction"] = this.ground_construction ? this.ground_construction.toJSON() : <any>undefined;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** A set of constructions for wall, floor, or roof assemblies. */
export interface I_FaceSubSet extends I_OpenAPIGenBaseModel {
    /** An OpaqueConstruction for walls with a Surface or Adiabatic boundary condition. */
    interior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with an Outdoors boundary condition. */
    exterior_construction?: OpaqueConstruction;
    /** An OpaqueConstruction for walls with a Ground boundary condition. */
    ground_construction?: OpaqueConstruction;
    type?: string;
}

/** Base class for the modifier sets assigned to Faces. */
export class BaseModifierSet extends _OpenAPIGenBaseModel implements IBaseModifierSet {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier5;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier6;
    readonly type: string = "BaseModifierSet";

    constructor(data?: IBaseModifierSet) {
        super(data);
        if (!data) {
            this.type = "BaseModifierSet";
        }
        this._discriminator = "BaseModifierSet";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exterior_modifier = _data["exterior_modifier"];
            this.interior_modifier = _data["interior_modifier"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "BaseModifierSet";
        }
    }

    static override fromJS(data: any): BaseModifierSet {
        data = typeof data === 'object' ? data : {};
        let result = new BaseModifierSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exterior_modifier"] = this.exterior_modifier;
        data["interior_modifier"] = this.interior_modifier;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for the modifier sets assigned to Faces. */
export interface IBaseModifierSet extends I_OpenAPIGenBaseModel {
    /** A radiance modifier object for faces with an Outdoors boundary condition. */
    exterior_modifier?: exterior_modifier5;
    /** A radiance modifier object for faces with a boundary condition other than Outdoors. */
    interior_modifier?: interior_modifier6;
    type?: string;
}

/** Base class for all heating/cooling systems without any ventilation. These systems are only designed to satisfy heating + cooling demand and they cannot meet any minimum ventilation requirements. As such, these systems tend to be used in residential or storage settings where meeting minimum ventilation requirements may not be required or the density of occupancy is so low that infiltration is enough to meet fresh air demand. */
export class _HeatCoolBase extends IDdEnergyBaseModel implements I_HeatCoolBase {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "_HeatCoolBase";

    constructor(data?: I_HeatCoolBase) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "_HeatCoolBase";
        }
        this._discriminator = "_HeatCoolBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_HeatCoolBase";
        }
    }

    static override fromJS(data: any): _HeatCoolBase {
        data = typeof data === 'object' ? data : {};
        let result = new _HeatCoolBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all heating/cooling systems without any ventilation. These systems are only designed to satisfy heating + cooling demand and they cannot meet any minimum ventilation requirements. As such, these systems tend to be used in residential or storage settings where meeting minimum ventilation requirements may not be required or the density of occupancy is so low that infiltration is enough to meet fresh air demand. */
export interface I_HeatCoolBase extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
}

/** Base class for HVAC systems following a standards template. */
export class _TemplateSystem extends IDdEnergyBaseModel implements I_TemplateSystem {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    readonly type: string = "_TemplateSystem";

    constructor(data?: I_TemplateSystem) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.type = "_TemplateSystem";
        }
        this._discriminator = "_TemplateSystem";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_TemplateSystem";
        }
    }

    static override fromJS(data: any): _TemplateSystem {
        data = typeof data === 'object' ? data : {};
        let result = new _TemplateSystem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for HVAC systems following a standards template. */
export interface I_TemplateSystem extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    type?: string;
}

/** Base class for Dedicated Outdoor Air System (DOAS) HVACs. DOAS systems separate minimum ventilation supply from the satisfaction of heating + cooling demand. Ventilation air tends to be supplied at neutral temperatures (close to room air temperature) and heating / cooling loads are met with additional pieces of zone equipment (eg. Fan Coil Units (FCUs)). Because DOAS systems only have to cool down and re-heat the minimum ventilation air, they tend to use less energy than all-air systems. They also tend to use less energy to distribute heating + cooling by pumping around hot/cold water or refrigerant instead of blowing hot/cold air. However, they do not provide as good of control over humidity and so they may not be appropriate for rooms with high latent loads like auditoriums, kitchens, laundromats, etc. */
export class _DOASBase extends IDdEnergyBaseModel implements I_DOASBase {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    readonly type: string = "_DOASBase";

    constructor(data?: I_DOASBase) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "_DOASBase";
        }
        this._discriminator = "_DOASBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            this.doas_availability_schedule = _data["doas_availability_schedule"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_DOASBase";
        }
    }

    static override fromJS(data: any): _DOASBase {
        data = typeof data === 'object' ? data : {};
        let result = new _DOASBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["doas_availability_schedule"] = this.doas_availability_schedule;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for Dedicated Outdoor Air System (DOAS) HVACs. DOAS systems separate minimum ventilation supply from the satisfaction of heating + cooling demand. Ventilation air tends to be supplied at neutral temperatures (close to room air temperature) and heating / cooling loads are met with additional pieces of zone equipment (eg. Fan Coil Units (FCUs)). Because DOAS systems only have to cool down and re-heat the minimum ventilation air, they tend to use less energy than all-air systems. They also tend to use less energy to distribute heating + cooling by pumping around hot/cold water or refrigerant instead of blowing hot/cold air. However, they do not provide as good of control over humidity and so they may not be appropriate for rooms with high latent loads like auditoriums, kitchens, laundromats, etc. */
export interface I_DOASBase extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    /** An optional On/Off discrete schedule to set when the dedicated outdoor air system (DOAS) shuts off. This will not only prevent any outdoor air from flowing thorough the system but will also shut off the fans, which can result in more energy savings when spaces served by the DOAS are completely unoccupied. If None, the DOAS will be always on. */
    doas_availability_schedule?: string;
    type?: string;
}

/** Base class for all-air systems. All-air systems provide both ventilation and heating + cooling demand with the same stream of warm/cool air. As such, they often grant tight control over zone humidity. However, because such systems often involve the cooling of air only to reheat it again, they are often more energy intensive than systems that separate ventilation from the meeting of thermal loads. */
export class _AllAirBase extends IDdEnergyBaseModel implements I_AllAirBase {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    readonly type: string = "_AllAirBase";

    constructor(data?: I_AllAirBase) {
        super(data);
        if (!data) {
            this.vintage = Vintages.ASHRAE_2019;
            this.economizer_type = AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = 0;
            this.latent_heat_recovery = 0;
            this.demand_controlled_ventilation = false;
            this.type = "_AllAirBase";
        }
        this._discriminator = "_AllAirBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.vintage = _data["vintage"] !== undefined ? _data["vintage"] : Vintages.ASHRAE_2019;
            this.economizer_type = _data["economizer_type"] !== undefined ? _data["economizer_type"] : AllAirEconomizerType.NoEconomizer;
            this.sensible_heat_recovery = _data["sensible_heat_recovery"] !== undefined ? _data["sensible_heat_recovery"] : 0;
            this.latent_heat_recovery = _data["latent_heat_recovery"] !== undefined ? _data["latent_heat_recovery"] : 0;
            this.demand_controlled_ventilation = _data["demand_controlled_ventilation"] !== undefined ? _data["demand_controlled_ventilation"] : false;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "_AllAirBase";
        }
    }

    static override fromJS(data: any): _AllAirBase {
        data = typeof data === 'object' ? data : {};
        let result = new _AllAirBase();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vintage"] = this.vintage;
        data["economizer_type"] = this.economizer_type;
        data["sensible_heat_recovery"] = this.sensible_heat_recovery;
        data["latent_heat_recovery"] = this.latent_heat_recovery;
        data["demand_controlled_ventilation"] = this.demand_controlled_ventilation;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all-air systems. All-air systems provide both ventilation and heating + cooling demand with the same stream of warm/cool air. As such, they often grant tight control over zone humidity. However, because such systems often involve the cooling of air only to reheat it again, they are often more energy intensive than systems that separate ventilation from the meeting of thermal loads. */
export interface I_AllAirBase extends IIDdEnergyBaseModel {
    /** Text for the vintage of the template system. This will be used to set efficiencies for various pieces of equipment within the system. Further information about these defaults can be found in the version of ASHRAE 90.1 corresponding to the selected vintage. Read-only versions of the standard can be found at: https://www.ashrae.org/technical-resources/standards-and-guidelines/read-only-versions-of-ashrae-standards */
    vintage?: Vintages;
    /** Text to indicate the type of air-side economizer used on the system (from the AllAirEconomizerType enumeration). */
    economizer_type?: AllAirEconomizerType;
    /** A number between 0 and 1 for the effectiveness of sensible heat recovery within the system. */
    sensible_heat_recovery?: number;
    /** A number between 0 and 1 for the effectiveness of latent heat recovery within the system. */
    latent_heat_recovery?: number;
    /** Boolean to note whether demand controlled ventilation should be used on the system, which will vary the amount of ventilation air according to the occupancy schedule of the Rooms. */
    demand_controlled_ventilation?: boolean;
    type?: string;
}

/** Construction for window objects with an included shade layer. */
export class WindowConstructionShadeAbridged extends IDdEnergyBaseModel implements IWindowConstructionShadeAbridged {
    /** A WindowConstructionAbridged object that serves as the "switched off" version of the construction (aka. the "bare construction"). The shade_material and shade_location will be used to modify this starting construction. */
    window_construction!: WindowConstructionAbridged;
    /** Identifier of a An EnergyWindowMaterialShade or an EnergyWindowMaterialBlind that serves as the shading layer for this construction. This can also be an EnergyWindowMaterialGlazing, which will indicate that the WindowConstruction has a dynamically-controlled glass pane like an electrochromic window assembly. */
    shade_material!: string;
    readonly type: string = "WindowConstructionShadeAbridged";
    /** Text to indicate where in the window assembly the shade_material is located.  Note that the WindowConstruction must have at least one gas gap to use the "Between" option. Also note that, for a WindowConstruction with more than one gas gap, the "Between" option defaults to using the inner gap as this is the only option that EnergyPlus supports. */
    shade_location?: ShadeLocation;
    /** Text to indicate how the shading device is controlled, which determines when the shading is “on” or “off.” */
    control_type?: ControlType;
    /** A number that corresponds to the specified control_type. This can be a value in (W/m2), (C) or (W) depending upon the control type.Note that this value cannot be None for any control type except "AlwaysOn." */
    setpoint?: number;
    /** An optional schedule identifier to be applied on top of the control_type. If None, the control_type will govern all behavior of the construction. */
    schedule?: string;

    constructor(data?: IWindowConstructionShadeAbridged) {
        super(data);
        if (!data) {
            this.window_construction = new WindowConstructionAbridged();
            this.type = "WindowConstructionShadeAbridged";
            this.shade_location = ShadeLocation.Interior;
            this.control_type = ControlType.AlwaysOn;
        }
        this._discriminator = "WindowConstructionShadeAbridged";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.window_construction = _data["window_construction"] ? WindowConstructionAbridged.fromJS(_data["window_construction"]) : new WindowConstructionAbridged();
            this.shade_material = _data["shade_material"];
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "WindowConstructionShadeAbridged";
            this.shade_location = _data["shade_location"] !== undefined ? _data["shade_location"] : ShadeLocation.Interior;
            this.control_type = _data["control_type"] !== undefined ? _data["control_type"] : ControlType.AlwaysOn;
            this.setpoint = _data["setpoint"];
            this.schedule = _data["schedule"];
        }
    }

    static override fromJS(data: any): WindowConstructionShadeAbridged {
        data = typeof data === 'object' ? data : {};
        let result = new WindowConstructionShadeAbridged();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["window_construction"] = this.window_construction ? this.window_construction.toJSON() : <any>undefined;
        data["shade_material"] = this.shade_material;
        data["type"] = this.type;
        data["shade_location"] = this.shade_location;
        data["control_type"] = this.control_type;
        data["setpoint"] = this.setpoint;
        data["schedule"] = this.schedule;
        super.toJSON(data);
        return data;
    }
}

/** Construction for window objects with an included shade layer. */
export interface IWindowConstructionShadeAbridged extends IIDdEnergyBaseModel {
    /** A WindowConstructionAbridged object that serves as the "switched off" version of the construction (aka. the "bare construction"). The shade_material and shade_location will be used to modify this starting construction. */
    window_construction: WindowConstructionAbridged;
    /** Identifier of a An EnergyWindowMaterialShade or an EnergyWindowMaterialBlind that serves as the shading layer for this construction. This can also be an EnergyWindowMaterialGlazing, which will indicate that the WindowConstruction has a dynamically-controlled glass pane like an electrochromic window assembly. */
    shade_material: string;
    type?: string;
    /** Text to indicate where in the window assembly the shade_material is located.  Note that the WindowConstruction must have at least one gas gap to use the "Between" option. Also note that, for a WindowConstruction with more than one gas gap, the "Between" option defaults to using the inner gap as this is the only option that EnergyPlus supports. */
    shade_location?: ShadeLocation;
    /** Text to indicate how the shading device is controlled, which determines when the shading is “on” or “off.” */
    control_type?: ControlType;
    /** A number that corresponds to the specified control_type. This can be a value in (W/m2), (C) or (W) depending upon the control type.Note that this value cannot be None for any control type except "AlwaysOn." */
    setpoint?: number;
    /** An optional schedule identifier to be applied on top of the control_type. If None, the control_type will govern all behavior of the construction. */
    schedule?: string;
}

export class Modifier implements IModifier {

    [key: string]: any;

    constructor(data?: IModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IModifier {

    [key: string]: any;
}

export class Dependencies implements IDependencies {

    [key: string]: any;

    constructor(data?: IDependencies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Dependencies {
        data = typeof data === 'object' ? data : {};
        let result = new Dependencies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IDependencies {

    [key: string]: any;
}

export class Alternate_material implements IAlternate_material {

    [key: string]: any;

    constructor(data?: IAlternate_material) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Alternate_material {
        data = typeof data === 'object' ? data : {};
        let result = new Alternate_material();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAlternate_material {

    [key: string]: any;
}

export class modifier implements Imodifier {

    [key: string]: any;

    constructor(data?: Imodifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier {
        data = typeof data === 'object' ? data : {};
        let result = new modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier {

    [key: string]: any;
}

export class dependencies implements Idependencies {

    [key: string]: any;

    constructor(data?: Idependencies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies {

    [key: string]: any;
}

export class modifier2 implements Imodifier2 {

    [key: string]: any;

    constructor(data?: Imodifier2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier2 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier2 {

    [key: string]: any;
}

export class dependencies2 implements Idependencies2 {

    [key: string]: any;

    constructor(data?: Idependencies2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies2 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies2 {

    [key: string]: any;
}

export class modifier3 implements Imodifier3 {

    [key: string]: any;

    constructor(data?: Imodifier3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier3 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier3 {

    [key: string]: any;
}

export class dependencies3 implements Idependencies3 {

    [key: string]: any;

    constructor(data?: Idependencies3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies3 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies3 {

    [key: string]: any;
}

export class modifier4 implements Imodifier4 {

    [key: string]: any;

    constructor(data?: Imodifier4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier4 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier4 {

    [key: string]: any;
}

export class dependencies4 implements Idependencies4 {

    [key: string]: any;

    constructor(data?: Idependencies4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies4 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies4 {

    [key: string]: any;
}

export class modifier5 implements Imodifier5 {

    [key: string]: any;

    constructor(data?: Imodifier5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier5 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier5 {

    [key: string]: any;
}

export class dependencies5 implements Idependencies5 {

    [key: string]: any;

    constructor(data?: Idependencies5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies5 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies5 {

    [key: string]: any;
}

export class modifier6 implements Imodifier6 {

    [key: string]: any;

    constructor(data?: Imodifier6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier6 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier6 {

    [key: string]: any;
}

export class dependencies6 implements Idependencies6 {

    [key: string]: any;

    constructor(data?: Idependencies6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies6 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies6 {

    [key: string]: any;
}

export class modifier7 implements Imodifier7 {

    [key: string]: any;

    constructor(data?: Imodifier7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifier7 {
        data = typeof data === 'object' ? data : {};
        let result = new modifier7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifier7 {

    [key: string]: any;
}

export class dependencies7 implements Idependencies7 {

    [key: string]: any;

    constructor(data?: Idependencies7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): dependencies7 {
        data = typeof data === 'object' ? data : {};
        let result = new dependencies7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Idependencies7 {

    [key: string]: any;
}

export class View_factor implements IView_factor {

    [key: string]: any;

    constructor(data?: IView_factor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): View_factor {
        data = typeof data === 'object' ? data : {};
        let result = new View_factor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IView_factor {

    [key: string]: any;
}

export class Temperature implements ITemperature {

    [key: string]: any;

    constructor(data?: ITemperature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Temperature {
        data = typeof data === 'object' ? data : {};
        let result = new Temperature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ITemperature {

    [key: string]: any;
}

export class Boundary_condition implements IBoundary_condition {

    [key: string]: any;

    constructor(data?: IBoundary_condition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Boundary_condition {
        data = typeof data === 'object' ? data : {};
        let result = new Boundary_condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IBoundary_condition {

    [key: string]: any;
}

export class boundary_condition implements Iboundary_condition {

    [key: string]: any;

    constructor(data?: Iboundary_condition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): boundary_condition {
        data = typeof data === 'object' ? data : {};
        let result = new boundary_condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iboundary_condition {

    [key: string]: any;
}

export class boundary_condition2 implements Iboundary_condition2 {

    [key: string]: any;

    constructor(data?: Iboundary_condition2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): boundary_condition2 {
        data = typeof data === 'object' ? data : {};
        let result = new boundary_condition2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iboundary_condition2 {

    [key: string]: any;
}

export class Latent_fraction implements ILatent_fraction {

    [key: string]: any;

    constructor(data?: ILatent_fraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Latent_fraction {
        data = typeof data === 'object' ? data : {};
        let result = new Latent_fraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ILatent_fraction {

    [key: string]: any;
}

export class Solar_reflectance_back implements ISolar_reflectance_back {

    [key: string]: any;

    constructor(data?: ISolar_reflectance_back) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Solar_reflectance_back {
        data = typeof data === 'object' ? data : {};
        let result = new Solar_reflectance_back();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISolar_reflectance_back {

    [key: string]: any;
}

export class Visible_reflectance_back implements IVisible_reflectance_back {

    [key: string]: any;

    constructor(data?: IVisible_reflectance_back) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Visible_reflectance_back {
        data = typeof data === 'object' ? data : {};
        let result = new Visible_reflectance_back();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IVisible_reflectance_back {

    [key: string]: any;
}

export class Materials implements IMaterials {

    [key: string]: any;

    constructor(data?: IMaterials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Materials {
        data = typeof data === 'object' ? data : {};
        let result = new Materials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IMaterials {

    [key: string]: any;
}

export class materials implements Imaterials {

    [key: string]: any;

    constructor(data?: Imaterials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): materials {
        data = typeof data === 'object' ? data : {};
        let result = new materials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imaterials {

    [key: string]: any;
}

export class Constructions implements IConstructions {

    [key: string]: any;

    constructor(data?: IConstructions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Constructions {
        data = typeof data === 'object' ? data : {};
        let result = new Constructions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IConstructions {

    [key: string]: any;
}

export class materials2 implements Imaterials2 {

    [key: string]: any;

    constructor(data?: Imaterials2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): materials2 {
        data = typeof data === 'object' ? data : {};
        let result = new materials2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imaterials2 {

    [key: string]: any;
}

export class Lower_limit implements ILower_limit {

    [key: string]: any;

    constructor(data?: ILower_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Lower_limit {
        data = typeof data === 'object' ? data : {};
        let result = new Lower_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ILower_limit {

    [key: string]: any;
}

export class Upper_limit implements IUpper_limit {

    [key: string]: any;

    constructor(data?: IUpper_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Upper_limit {
        data = typeof data === 'object' ? data : {};
        let result = new Upper_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IUpper_limit {

    [key: string]: any;
}

export class Shade_material implements IShade_material {

    [key: string]: any;

    constructor(data?: IShade_material) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Shade_material {
        data = typeof data === 'object' ? data : {};
        let result = new Shade_material();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IShade_material {

    [key: string]: any;
}

export class Schedule implements ISchedule {

    [key: string]: any;

    constructor(data?: ISchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISchedule {

    [key: string]: any;
}

export class schedule implements Ischedule {

    [key: string]: any;

    constructor(data?: Ischedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule {
        data = typeof data === 'object' ? data : {};
        let result = new schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule {

    [key: string]: any;
}

export class Interior_construction implements IInterior_construction {

    [key: string]: any;

    constructor(data?: IInterior_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Interior_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Interior_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IInterior_construction {

    [key: string]: any;
}

export class Window_construction implements IWindow_construction {

    [key: string]: any;

    constructor(data?: IWindow_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Window_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Window_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IWindow_construction {

    [key: string]: any;
}

export class Skylight_construction implements ISkylight_construction {

    [key: string]: any;

    constructor(data?: ISkylight_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Skylight_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Skylight_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISkylight_construction {

    [key: string]: any;
}

export class Operable_construction implements IOperable_construction {

    [key: string]: any;

    constructor(data?: IOperable_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Operable_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Operable_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IOperable_construction {

    [key: string]: any;
}

export class Exterior_glass_construction implements IExterior_glass_construction {

    [key: string]: any;

    constructor(data?: IExterior_glass_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Exterior_glass_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Exterior_glass_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IExterior_glass_construction {

    [key: string]: any;
}

export class Interior_glass_construction implements IInterior_glass_construction {

    [key: string]: any;

    constructor(data?: IInterior_glass_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Interior_glass_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Interior_glass_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IInterior_glass_construction {

    [key: string]: any;
}

export class Air_mixing_schedule implements IAir_mixing_schedule {

    [key: string]: any;

    constructor(data?: IAir_mixing_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Air_mixing_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Air_mixing_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAir_mixing_schedule {

    [key: string]: any;
}

export class Air_boundary_construction implements IAir_boundary_construction {

    [key: string]: any;

    constructor(data?: IAir_boundary_construction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Air_boundary_construction {
        data = typeof data === 'object' ? data : {};
        let result = new Air_boundary_construction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAir_boundary_construction {

    [key: string]: any;
}

export class Heating_limit implements IHeating_limit {

    [key: string]: any;

    constructor(data?: IHeating_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Heating_limit {
        data = typeof data === 'object' ? data : {};
        let result = new Heating_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeating_limit {

    [key: string]: any;
}

export class Cooling_limit implements ICooling_limit {

    [key: string]: any;

    constructor(data?: ICooling_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Cooling_limit {
        data = typeof data === 'object' ? data : {};
        let result = new Cooling_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICooling_limit {

    [key: string]: any;
}

export class Heater_efficiency implements IHeater_efficiency {

    [key: string]: any;

    constructor(data?: IHeater_efficiency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Heater_efficiency {
        data = typeof data === 'object' ? data : {};
        let result = new Heater_efficiency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeater_efficiency {

    [key: string]: any;
}

export class Ambient_condition implements IAmbient_condition {

    [key: string]: any;

    constructor(data?: IAmbient_condition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Ambient_condition {
        data = typeof data === 'object' ? data : {};
        let result = new Ambient_condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAmbient_condition {

    [key: string]: any;
}

export class Occupancy_schedule implements IOccupancy_schedule {

    [key: string]: any;

    constructor(data?: IOccupancy_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Occupancy_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Occupancy_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IOccupancy_schedule {

    [key: string]: any;
}

export class Activity_schedule implements IActivity_schedule {

    [key: string]: any;

    constructor(data?: IActivity_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Activity_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Activity_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IActivity_schedule {

    [key: string]: any;
}

export class latent_fraction implements Ilatent_fraction {

    [key: string]: any;

    constructor(data?: Ilatent_fraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): latent_fraction {
        data = typeof data === 'object' ? data : {};
        let result = new latent_fraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ilatent_fraction {

    [key: string]: any;
}

export class schedule2 implements Ischedule2 {

    [key: string]: any;

    constructor(data?: Ischedule2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule2 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule2 {

    [key: string]: any;
}

export class schedule3 implements Ischedule3 {

    [key: string]: any;

    constructor(data?: Ischedule3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule3 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule3 {

    [key: string]: any;
}

export class schedule4 implements Ischedule4 {

    [key: string]: any;

    constructor(data?: Ischedule4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule4 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule4 {

    [key: string]: any;
}

export class schedule5 implements Ischedule5 {

    [key: string]: any;

    constructor(data?: Ischedule5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule5 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule5 {

    [key: string]: any;
}

export class schedule6 implements Ischedule6 {

    [key: string]: any;

    constructor(data?: Ischedule6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule6 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule6 {

    [key: string]: any;
}

export class schedule7 implements Ischedule7 {

    [key: string]: any;

    constructor(data?: Ischedule7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): schedule7 {
        data = typeof data === 'object' ? data : {};
        let result = new schedule7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ischedule7 {

    [key: string]: any;
}

export class Cooling_schedule implements ICooling_schedule {

    [key: string]: any;

    constructor(data?: ICooling_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Cooling_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Cooling_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICooling_schedule {

    [key: string]: any;
}

export class Heating_schedule implements IHeating_schedule {

    [key: string]: any;

    constructor(data?: IHeating_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Heating_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Heating_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeating_schedule {

    [key: string]: any;
}

export class Humidifying_schedule implements IHumidifying_schedule {

    [key: string]: any;

    constructor(data?: IHumidifying_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Humidifying_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Humidifying_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHumidifying_schedule {

    [key: string]: any;
}

export class Dehumidifying_schedule implements IDehumidifying_schedule {

    [key: string]: any;

    constructor(data?: IDehumidifying_schedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Dehumidifying_schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Dehumidifying_schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IDehumidifying_schedule {

    [key: string]: any;
}

export class Construction_sets implements IConstruction_sets {

    [key: string]: any;

    constructor(data?: IConstruction_sets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Construction_sets {
        data = typeof data === 'object' ? data : {};
        let result = new Construction_sets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IConstruction_sets {

    [key: string]: any;
}

export class constructions implements Iconstructions {

    [key: string]: any;

    constructor(data?: Iconstructions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): constructions {
        data = typeof data === 'object' ? data : {};
        let result = new constructions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iconstructions {

    [key: string]: any;
}

export class materials3 implements Imaterials3 {

    [key: string]: any;

    constructor(data?: Imaterials3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): materials3 {
        data = typeof data === 'object' ? data : {};
        let result = new materials3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imaterials3 {

    [key: string]: any;
}

export class Hvacs implements IHvacs {

    [key: string]: any;

    constructor(data?: IHvacs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Hvacs {
        data = typeof data === 'object' ? data : {};
        let result = new Hvacs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHvacs {

    [key: string]: any;
}

export class Program_types implements IProgram_types {

    [key: string]: any;

    constructor(data?: IProgram_types) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Program_types {
        data = typeof data === 'object' ? data : {};
        let result = new Program_types();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IProgram_types {

    [key: string]: any;
}

export class Schedules implements ISchedules {

    [key: string]: any;

    constructor(data?: ISchedules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Schedules {
        data = typeof data === 'object' ? data : {};
        let result = new Schedules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISchedules {

    [key: string]: any;
}

export class Exterior_modifier implements IExterior_modifier {

    [key: string]: any;

    constructor(data?: IExterior_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Exterior_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Exterior_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IExterior_modifier {

    [key: string]: any;
}

export class Interior_modifier implements IInterior_modifier {

    [key: string]: any;

    constructor(data?: IInterior_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Interior_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Interior_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IInterior_modifier {

    [key: string]: any;
}

export class Modifiers implements IModifiers {

    [key: string]: any;

    constructor(data?: IModifiers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Modifiers {
        data = typeof data === 'object' ? data : {};
        let result = new Modifiers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IModifiers {

    [key: string]: any;
}

export class exterior_modifier implements Iexterior_modifier {

    [key: string]: any;

    constructor(data?: Iexterior_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): exterior_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new exterior_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iexterior_modifier {

    [key: string]: any;
}

export class interior_modifier implements Iinterior_modifier {

    [key: string]: any;

    constructor(data?: Iinterior_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier {

    [key: string]: any;
}

export class exterior_modifier2 implements Iexterior_modifier2 {

    [key: string]: any;

    constructor(data?: Iexterior_modifier2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): exterior_modifier2 {
        data = typeof data === 'object' ? data : {};
        let result = new exterior_modifier2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iexterior_modifier2 {

    [key: string]: any;
}

export class interior_modifier2 implements Iinterior_modifier2 {

    [key: string]: any;

    constructor(data?: Iinterior_modifier2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier2 {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier2 {

    [key: string]: any;
}

export class Window_modifier implements IWindow_modifier {

    [key: string]: any;

    constructor(data?: IWindow_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Window_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Window_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IWindow_modifier {

    [key: string]: any;
}

export class interior_modifier3 implements Iinterior_modifier3 {

    [key: string]: any;

    constructor(data?: Iinterior_modifier3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier3 {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier3 {

    [key: string]: any;
}

export class Skylight_modifier implements ISkylight_modifier {

    [key: string]: any;

    constructor(data?: ISkylight_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Skylight_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Skylight_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISkylight_modifier {

    [key: string]: any;
}

export class Operable_modifier implements IOperable_modifier {

    [key: string]: any;

    constructor(data?: IOperable_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Operable_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Operable_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IOperable_modifier {

    [key: string]: any;
}

export class exterior_modifier3 implements Iexterior_modifier3 {

    [key: string]: any;

    constructor(data?: Iexterior_modifier3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): exterior_modifier3 {
        data = typeof data === 'object' ? data : {};
        let result = new exterior_modifier3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iexterior_modifier3 {

    [key: string]: any;
}

export class interior_modifier4 implements Iinterior_modifier4 {

    [key: string]: any;

    constructor(data?: Iinterior_modifier4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier4 {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier4 {

    [key: string]: any;
}

export class Interior_glass_modifier implements IInterior_glass_modifier {

    [key: string]: any;

    constructor(data?: IInterior_glass_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Interior_glass_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Interior_glass_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IInterior_glass_modifier {

    [key: string]: any;
}

export class Exterior_glass_modifier implements IExterior_glass_modifier {

    [key: string]: any;

    constructor(data?: IExterior_glass_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Exterior_glass_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Exterior_glass_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IExterior_glass_modifier {

    [key: string]: any;
}

export class Overhead_modifier implements IOverhead_modifier {

    [key: string]: any;

    constructor(data?: IOverhead_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Overhead_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Overhead_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IOverhead_modifier {

    [key: string]: any;
}

export class exterior_modifier4 implements Iexterior_modifier4 {

    [key: string]: any;

    constructor(data?: Iexterior_modifier4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): exterior_modifier4 {
        data = typeof data === 'object' ? data : {};
        let result = new exterior_modifier4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iexterior_modifier4 {

    [key: string]: any;
}

export class interior_modifier5 implements Iinterior_modifier5 {

    [key: string]: any;

    constructor(data?: Iinterior_modifier5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier5 {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier5 {

    [key: string]: any;
}

export class Air_boundary_modifier implements IAir_boundary_modifier {

    [key: string]: any;

    constructor(data?: IAir_boundary_modifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Air_boundary_modifier {
        data = typeof data === 'object' ? data : {};
        let result = new Air_boundary_modifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAir_boundary_modifier {

    [key: string]: any;
}

export class Modifier_sets implements IModifier_sets {

    [key: string]: any;

    constructor(data?: IModifier_sets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Modifier_sets {
        data = typeof data === 'object' ? data : {};
        let result = new Modifier_sets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IModifier_sets {

    [key: string]: any;
}

export class modifiers implements Imodifiers {

    [key: string]: any;

    constructor(data?: Imodifiers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): modifiers {
        data = typeof data === 'object' ? data : {};
        let result = new modifiers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Imodifiers {

    [key: string]: any;
}

export class Spacing implements ISpacing {

    [key: string]: any;

    constructor(data?: ISpacing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Spacing {
        data = typeof data === 'object' ? data : {};
        let result = new Spacing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISpacing {

    [key: string]: any;
}

export class spacing implements Ispacing {

    [key: string]: any;

    constructor(data?: Ispacing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): spacing {
        data = typeof data === 'object' ? data : {};
        let result = new spacing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Ispacing {

    [key: string]: any;
}

export class Mesh_radius implements IMesh_radius {

    [key: string]: any;

    constructor(data?: IMesh_radius) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Mesh_radius {
        data = typeof data === 'object' ? data : {};
        let result = new Mesh_radius();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IMesh_radius {

    [key: string]: any;
}

export class Grid_parameters implements IGrid_parameters {

    [key: string]: any;

    constructor(data?: IGrid_parameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Grid_parameters {
        data = typeof data === 'object' ? data : {};
        let result = new Grid_parameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IGrid_parameters {

    [key: string]: any;
}

export class Boundary_conditions implements IBoundary_conditions {

    [key: string]: any;

    constructor(data?: IBoundary_conditions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Boundary_conditions {
        data = typeof data === 'object' ? data : {};
        let result = new Boundary_conditions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IBoundary_conditions {

    [key: string]: any;
}

export class Window_parameters implements IWindow_parameters {

    [key: string]: any;

    constructor(data?: IWindow_parameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Window_parameters {
        data = typeof data === 'object' ? data : {};
        let result = new Window_parameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IWindow_parameters {

    [key: string]: any;
}

export class Shading_parameters implements IShading_parameters {

    [key: string]: any;

    constructor(data?: IShading_parameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Shading_parameters {
        data = typeof data === 'object' ? data : {};
        let result = new Shading_parameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IShading_parameters {

    [key: string]: any;
}

export class Skylight_parameters implements ISkylight_parameters {

    [key: string]: any;

    constructor(data?: ISkylight_parameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Skylight_parameters {
        data = typeof data === 'object' ? data : {};
        let result = new Skylight_parameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ISkylight_parameters {

    [key: string]: any;
}

export class Floor_to_floor_height implements IFloor_to_floor_height {

    [key: string]: any;

    constructor(data?: IFloor_to_floor_height) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Floor_to_floor_height {
        data = typeof data === 'object' ? data : {};
        let result = new Floor_to_floor_height();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IFloor_to_floor_height {

    [key: string]: any;
}

export class Floor_height implements IFloor_height {

    [key: string]: any;

    constructor(data?: IFloor_height) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Floor_height {
        data = typeof data === 'object' ? data : {};
        let result = new Floor_height();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IFloor_height {

    [key: string]: any;
}

export class Geometry implements IGeometry {

    [key: string]: any;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IGeometry {

    [key: string]: any;
}

export class exterior_modifier5 implements Iexterior_modifier5 {

    [key: string]: any;

    constructor(data?: Iexterior_modifier5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): exterior_modifier5 {
        data = typeof data === 'object' ? data : {};
        let result = new exterior_modifier5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iexterior_modifier5 {

    [key: string]: any;
}

export class interior_modifier6 implements Iinterior_modifier6 {

    [key: string]: any;

    constructor(data?: Iinterior_modifier6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): interior_modifier6 {
        data = typeof data === 'object' ? data : {};
        let result = new interior_modifier6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface Iinterior_modifier6 {

    [key: string]: any;
}

